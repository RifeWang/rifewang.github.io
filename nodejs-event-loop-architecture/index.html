<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>深入理解 Node.js 事件循环架构【译】 - 凌虚 Blog</title><meta name=Description content="深入理解 Node.js 事件循环架构【译】"><meta property="og:title" content="深入理解 Node.js 事件循环架构【译】">
<meta property="og:description" content="深入理解 Node.js 事件循环架构【译】"><meta property="og:type" content="article"><meta property="og:url" content="https://rifewang.github.io/nodejs-event-loop-architecture/"><meta property="og:image" content="https://rifewang.github.io/images/avatar.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-05-28T15:53:48+08:00"><meta property="article:modified_time" content="2023-02-27T15:51:36+08:00"><meta property="og:site_name" content="凌虚 Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://rifewang.github.io/images/avatar.png"><meta name=twitter:title content="深入理解 Node.js 事件循环架构【译】"><meta name=twitter:description content="深入理解 Node.js 事件循环架构【译】"><meta name=application-name content="凌虚的博客"><meta name=apple-mobile-web-app-title content="凌虚的博客"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel=canonical href=https://rifewang.github.io/nodejs-event-loop-architecture/><link rel=prev href=https://rifewang.github.io/kafka/><link rel=next href=https://rifewang.github.io/lets-encrypt/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=/lib/fontawesome-free/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload href=/lib/animate/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"深入理解 Node.js 事件循环架构【译】","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/rifewang.github.io\/nodejs-event-loop-architecture\/"},"image":["https:\/\/rifewang.github.io\/images\/avatar.png"],"genre":"posts","keywords":"Node.js","wordcount":2935,"url":"https:\/\/rifewang.github.io\/nodejs-event-loop-architecture\/","datePublished":"2019-05-28T15:53:48+08:00","dateModified":"2023-02-27T15:51:36+08:00","license":"Attribution-NonCommercial 4.0 International (CC BY-NC 4.0)","publisher":{"@type":"Organization","name":"凌虚","logo":"https:\/\/rifewang.github.io\/images\/avatar.png"},"author":{"@type":"Person","name":"凌虚"},"description":"深入理解 Node.js 事件循环架构【译】"}</script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-VRMQFEVL7J"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VRMQFEVL7J")</script><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"light"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"light"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="凌虚 Blog">凌虚的博客</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/about>作者 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i>
</span></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="凌虚 Blog">凌虚的博客</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/about title>作者</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class="toc-content always-active" id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">深入理解 Node.js 事件循环架构【译】</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>凌虚</a></span>&nbsp;<span class=post-category>included in <a href=/categories/uncate/><i class="far fa-folder fa-fw" aria-hidden=true></i>Uncate</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2019-05-28>2019-05-28</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;2935 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;6 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#01>01</a></li><li><a href=#02>02</a></li><li><a href=#03>03</a></li><li><a href=#04>04</a></li><li><a href=#05>05</a></li></ul></nav></div></div><div class=content id=content><p><em>本文翻译自：
<a href=https://medium.com/preezma/node-js-event-loop-architecture-go-deeper-node-core-c96b4cec7aa4 target=_blank rel="noopener noreffer">https://medium.com/preezma/node-js-event-loop-architecture-go-deeper-node-core-c96b4cec7aa4</a></em></p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/uncate/node-event-loop1.jpeg data-srcset="/images/uncate/node-event-loop1.jpeg, /images/uncate/node-event-loop1.jpeg 1.5x, /images/uncate/node-event-loop1.jpeg 2x" data-sizes=auto alt=/images/uncate/node-event-loop1.jpeg title=/images/uncate/node-event-loop1.jpeg></p><p>关于 Node.js ，相信你已经了解过不少内容，诸如 Node.js 内核、事件循环、单线程、setTimeout 或 setImmediate 函数的执行机制等等。</p><p>当然最重要的，你应该知道 Node.js 使用的是非阻塞 IO 模型以及异步的编程风格。本文仍将深入核心进行相关内容的探讨。</p><h2 id=01>01</h2><p>事件循环到底是什么？Node.js 到底是单线程还是多线程？</p><p>关于这个问题，网络上充斥着各种不清晰甚至错误的答案。本文将会深入 Node.js 内核，阐述它是如何实现的以及它的工作机制。 Node.js 并不仅仅只是 " JavaScript on the Server " ，更重要的是，其中约 30% 的部分是 C++ 而不是 JS 。本文将会讲述这些 C++ 部分在 Node.js 中实际做了什么。</p><p>Node.js 是单线程？</p><p>答案：Node.js 既是单线程，但同时也不是。</p><p>一些相关名词：multitasking（多任务）、single-threaded（单线程）、multi-threaded（多线程），thread pool（线程池）、epoll loop（epoll 循环）、event loop（事件循环）。</p><p>让我们从头开始深入了解 Node.js 内核中发生了什么？</p><ul><li>处理器可以一次处理一件事，也可以一次并行地处理多个任务（multitasking）。</li></ul><p>对于单核处理器，其只能一次处理一个任务，应用程序在完成任务后调用 yield 去通知处理器开始处理下一个任务，就像 JavaScript 中的 generator 函数一样，否则没有 yield 则将返回当前任务。在过去，当应用程序无法调用 yield 时，其服务将处于无法访问的状态。</p><ul><li>进程是一个 top level 执行容器，它有自己专用的内存系统。</li></ul><p>这意味着在一个进程中无法直接获取另一个进程的内存中的数据，为了使两个进程进行通信，我们必须要另外做一些工作，称之为 inter-process communication（ IPC ，进程间通信），它依赖于 system sockets（系统套接字）。</p><p>Unix 系统中的工作基于 sockets 套接字。Socket 就是一个整数，返回一个 Socket() 系统调用，它被称为 socket descriptor（套接字描述符）或者 file descriptor（文件描述符）。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/uncate/node-event-loop2.jpeg data-srcset="/images/uncate/node-event-loop2.jpeg, /images/uncate/node-event-loop2.jpeg 1.5x, /images/uncate/node-event-loop2.jpeg 2x" data-sizes=auto alt=/images/uncate/node-event-loop2.jpeg title=/images/uncate/node-event-loop2.jpeg></p><p>Sockets 通过虚拟的接口（ read / write / pool / close 等）指向系统内核中的对象。</p><p>System sockets 系统套接字的工作方式类似于 TCP sockets ：将数据转换为 buffer 然后发送。由于我们在进行进程间通信时使用的是 JavaScript ，因此我们必须多次调用 JSON.stringify ，显然这是很低效的。</p><p>然而，我们拥有线程！</p><ul><li>执行线程是可由调度器独立管理的最小程序指令序列。</li></ul><p>线程在进程中运行，一个进程可以包含许多线程，并且由于这些线程处于同一个进程中，因此它们共享同一个内存。</p><p>这也就是说线程间通信不需要做任何额外的事情。如果我们在一个线程中托管一个全局变量，那么我们可以直接在另一个线程中访问它，因为它们都保持对同一个内存的引用，这种方式非常高效。</p><p>但是我们假设在一个线程中有一个函数，它写入一个 foo 变量，另一个线程则从中读取，这将会发生什么？</p><p>答案无从得知，因为我们无法确定读和写的先后顺序。这也正是多线程编程的难点所在。让我们看看 Node.js 如何处理这个问题。</p><p>Node.js 说：我只有一个线程。</p><p>实际上，Node.js 基于 V8 引擎，代码在主线程中执行，事件循环也运行在主线程中，这就是为什么我们说 Node.js 是单线程的。</p><p>但是，Node.js 不仅仅只是 V8，它有许多 APIs（C++），并且这些 API 都由 Event Loop 事件循环管理，通过 libuv（C++）实现。</p><p>C++ 在后台执行 JavaScript 代码并且拥有访问线程的权限。如果你执行从 Node.js 中调用的 JavaScript 同步方法，它将始终在主线程中运行。但是如果你执行一些异步的任务，它不会总是在主线程中执行：根据你使用的方法，事件循环可以将它路由到 APIs 中的某一个，并且它可以在另一个线程中执行。</p><p>看一个示例 CRYPTO ，它有许多 CPU 密集型方法，一些是同步的，一些是异步的。这里看一下 pbkdf2 方法。如果我们在 2 核处理器中执行其同步版本并进行 4 次调用，假设一次调用的执行时间是 2 ms ，则总耗时为 4 * 2 ms = 8 ms 。</p><p>但是如果在同一个 CPU（2核）中执行这个方法的异步版本，总耗时则为 2 * 2 ms = 4 ms ，因为处理器将使用默认 4 个线程（下文将会说明），将它托管到两个进程中并执行。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/uncate/node-event-loop3.jpeg data-srcset="/images/uncate/node-event-loop3.jpeg, /images/uncate/node-event-loop3.jpeg 1.5x, /images/uncate/node-event-loop3.jpeg 2x" data-sizes=auto alt=/images/uncate/node-event-loop3.jpeg title=/images/uncate/node-event-loop3.jpeg></p><p>这也就是：Node.js 并发地执行异步方法。</p><p>Node.js 使用一组预先分配的线程，称之为线程池，如果我们没有指定要打开的线程数，它默认就是使用 4 个线程。</p><p>我们可以通过 UV_THREADPOOL_SIZE 进行设置。</p><p>所以，Node.js 是多线程的吗？
当然，Node.js 使用了多线程。
然而，Node.js 到底是单线程还是多线程，这取决于 when ？</p><h2 id=02>02</h2><p>我们来看看 TCP 连接。</p><p>Thread per connection ：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/uncate/node-event-loop4.png data-srcset="/images/uncate/node-event-loop4.png, /images/uncate/node-event-loop4.png 1.5x, /images/uncate/node-event-loop4.png 2x" data-sizes=auto alt=/images/uncate/node-event-loop4.png title=/images/uncate/node-event-loop4.png></p><p>创建一个 TCP server 最简单的方式就是创建一个 socket ，绑定这个 socket 到某个端口上然后 listen 监听。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/uncate/node-event-loop5.png data-srcset="/images/uncate/node-event-loop5.png, /images/uncate/node-event-loop5.png 1.5x, /images/uncate/node-event-loop5.png 2x" data-sizes=auto alt=/images/uncate/node-event-loop5.png title=/images/uncate/node-event-loop5.png></p><p>在我们调用 listen 之前，该 socket 可用于建立连接或接受连接。当我们调用 listen 时，我们准备接受连接。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/uncate/node-event-loop6.png data-srcset="/images/uncate/node-event-loop6.png, /images/uncate/node-event-loop6.png 1.5x, /images/uncate/node-event-loop6.png 2x" data-sizes=auto alt=/images/uncate/node-event-loop6.png title=/images/uncate/node-event-loop6.png></p><p>当连接到达并且我们需要写入它时，直到我们完成写入之前，我们都无法接受另一个连接，这就是我们将它推入另一个线程的原因。所以我们将 socket descriptor 和 function pointer 传递给线程。</p><p>现在，系统可以轻松处理几千个线程，但在这种情况下，我们必须为每个连接向线程发送大量数据，并且这样做并不能很好的扩展到两万到四万个并发连接。</p><p>但是，我们实际需要的仅仅只是 socket descriptor 套接字描述符，并记住我们要做的事情（也就是如何使用这些套接字）。所以有一种更好的方法：使用 Epoll（unix系统）或着 Kqueue（BSD系统，其实跟 Epoll 是同一个东西，不同系统名称不一样而已）。</p><p>Epoll 是 unix 系统相关底层知识。</p><p>Epoll 循环：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/uncate/node-event-loop7.png data-srcset="/images/uncate/node-event-loop7.png, /images/uncate/node-event-loop7.png 1.5x, /images/uncate/node-event-loop7.png 2x" data-sizes=auto alt=/images/uncate/node-event-loop7.png title=/images/uncate/node-event-loop7.png></p><p>Epoll 能为我们带来什么，为什么要使用它。使用 Epoll 允许我们告诉 Kernel（系统内核）我们关注的事件，并且 Kernel 将会告诉我们这些事件何时发生。在上面的例子中，我们关注的是传入的 TCP 连接，因此，我们创建一个 Epoll 描述符并将其添加到 Epoll 循环中，并调用 wait 。每当有 TCP 连接传入时便会唤醒，然后将它添加到 Epoll 循环中并等待来自它的数据。这就是事件循环为我们做的事情。</p><p>举个例子：</p><p>当我们通过 http 请求向同一个 2 核处理器下载数据时，4 个，6 个，甚至 8 个请求需要的时间相同。这意味着什么？这意味着这里的限制与我们在线程池中的限制不同。</p><p>因为操作系统负责下载，我们只是要求它下载，然后问它：完成了吗？还没好吗？完成了吗？（监听 Epoll 中的 data 事件）。</p><h2 id=03>03</h2><p>APIs</p><p>哪些 API 对应于哪种方式呢？（线程，Epoll）</p><p>所有 fs.* 方法使用 uv thread pool，除非是同步方法。阻塞调用由线程完成，完成后将信号发送回事件循环。我们无法直接在 Epoll 中 wait ，只能 pipe 。Pipe 管道连接两端：一端是线程，当它完成时，往管道中写入数据，另一端在 Epoll 循环中等待，当它获取到数据时，Epoll 循环唤醒。因此 pipe 是由 Epoll 响应的。</p><p>一些主要的方法及其对应的响应方式：</p><p>EPOLL ：</p><ul><li>TCP/UDP servers and clients</li><li>pipes</li><li>dns.resolve</li></ul><p>NGINX ：</p><ul><li>nginx signals ( sigterm )</li><li>Child processes ( exec, spawn )</li><li>TTY input ( console )</li></ul><p>THREAD POOL ：</p><ul><li>fs.</li><li>dns.lookup</li></ul><p>事件循环负责发送和接受结果，如同中央调度器一般，将请求路由到 C++ API，然后将结果返回给 JavaScript 。</p><h2 id=04>04</h2><p>Event loop</p><p>事件循环到底是什么？它是一个无限的 while 循环，调用 Epoll wait 或者 pool ，当 Node.js 中我们关注的事情如 callback 回调、event 事件、fs 发生时，它将返回给 Node.js ，然后当 Epoll 不再有 wait 时退出。这就是 Node.js 中的异步工作方式，以及为什么我们称之为事件驱动。事件循环允许 Node.js 执行非阻塞 IO 操作。尽管 JavaScript 是单线程的，但只要有可能就会将操作丢给系统内核。</p><p>事件循环的一次迭代称之为 Tick，它有自己的 phases（阶段）。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/uncate/node-event-loop8.jpeg data-srcset="/images/uncate/node-event-loop8.jpeg, /images/uncate/node-event-loop8.jpeg 1.5x, /images/uncate/node-event-loop8.jpeg 2x" data-sizes=auto alt=/images/uncate/node-event-loop8.jpeg title=/images/uncate/node-event-loop8.jpeg></p><p>更多关于 event loop 的 phases、Timers、process.nextTick() 等请查阅官方文档。</p><h2 id=05>05</h2><p>Node.js v10.5.0 版本之后，新增了 worker_threads 工作线程模块，允许用户多线程并行执行 JavaScript 。</p><p>工作线程对于执行 CPU 密集型 JavaScript 操作非常有用，但对于 IO 密集型工作没有多大帮助，因为 Node.js 内置的异步 IO 操作比这些 workers 更高效。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2023-02-27</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://rifewang.github.io/nodejs-event-loop-architecture/ data-title="深入理解 Node.js 事件循环架构【译】" data-hashtags=Node.js><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://rifewang.github.io/nodejs-event-loop-architecture/ data-hashtag=Node.js><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=https://rifewang.github.io/nodejs-event-loop-architecture/ data-title="深入理解 Node.js 事件循环架构【译】"><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=https://rifewang.github.io/nodejs-event-loop-architecture/ data-title="深入理解 Node.js 事件循环架构【译】"><i data-svg-src=/lib/simple-icons/icons/line.min.svg aria-hidden=true></i></a><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=https://rifewang.github.io/nodejs-event-loop-architecture/ data-title="深入理解 Node.js 事件循环架构【译】"><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/node.js/>Node.js</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/kafka/ class=prev rel=prev title="流平台 Kafka"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>流平台 Kafka</a>
<a href=/lets-encrypt/ class=next rel=next title="Let's Encrypt 配置 HTTPS 免费泛域名证书">Let's Encrypt 配置 HTTPS 免费泛域名证书<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2017 - 2024</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>凌虚</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=/lib/katex/katex.min.css><script type=text/javascript src=/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/lib/lunr/lunr.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/sharer/sharer.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/contrib/auto-render.min.js></script><script type=text/javascript src=/lib/katex/contrib/copy-tex.min.js></script><script type=text/javascript src=/lib/katex/contrib/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrIndexURL:"/index.json",maxResultLength:10,noResultsFound:"No results found",snippetLength:50,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>