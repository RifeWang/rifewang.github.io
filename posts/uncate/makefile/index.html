<!doctype html><html lang=en><head><title>使用 Makefile 构建指令集 · 凌虚 Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="凌虚"><meta name=description content="使用 Makefile 构建指令集"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="使用 Makefile 构建指令集"><meta name=twitter:description content="使用 Makefile 构建指令集"><meta property="og:title" content="使用 Makefile 构建指令集"><meta property="og:description" content="使用 Makefile 构建指令集"><meta property="og:type" content="article"><meta property="og:url" content="https://rifewang.github.io/posts/uncate/makefile/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-12-15T13:39:47+08:00"><meta property="article:modified_time" content="2019-12-15T13:39:47+08:00"><link rel=canonical href=https://rifewang.github.io/posts/uncate/makefile/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.0fa2dc75ed1b76894ac0e062b10a6c4730daa745096fa120114b290ed8a48788.css integrity="sha256-D6Lcde0bdolKwOBisQpsRzDap0UJb6EgEUspDtikh4g=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.593028e7f7ac55c003b79c230d1cd411bb4ca53b31556c3abb7f027170e646e9.css integrity="sha256-WTAo5/esVcADt5wjDRzUEbtMpTsxVWw6u38CcXDmRuk=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.110.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>凌虚 Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/translation/>Translation</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://rifewang.github.io/posts/uncate/makefile/>使用 Makefile 构建指令集</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2019-12-15T13:39:47+08:00>December 15, 2019</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
2-minute read</span></div></div></header><div class=post-content><h1 id=使用-makefile-构建指令集>使用 Makefile 构建指令集
<a class=heading-link href=#%e4%bd%bf%e7%94%a8-makefile-%e6%9e%84%e5%bb%ba%e6%8c%87%e4%bb%a4%e9%9b%86><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p><code>make</code> 是一个历史悠久的构建工具，通过配置 <code>Makefile</code> 文件就可以很方便的使用你自己自定义的各种指令集，且与具体的编程语言无关。
例如配置如下的 <code>Makefile</code> :</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>run dev:
</span></span><span style=display:flex><span>	NODE_ENV=development nodemon server.js
</span></span></code></pre></div><p>这样当你在命令行执行 <code>make run dev</code> 时其实就会执行 <code>NODE_ENV=development nodemon server.js</code> 指令。</p><p>使用 <code>Makefile</code> 构建指令集可以很大的提升工作效率。</p><h2 id=makefile-基本语法>Makefile 基本语法
<a class=heading-link href=#makefile-%e5%9f%ba%e6%9c%ac%e8%af%ad%e6%b3%95><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>&lt;target&gt;: &lt;prerequisites&gt;
</span></span><span style=display:flex><span>    &lt;commands&gt;
</span></span></code></pre></div><p><code>target</code> 其实就是执行的目标，<code>prerequisites</code> 是执行这条指令的前置条件，<code>commands</code> 就是具体的指令内容。</p><p>示例：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>build: clean
</span></span><span style=display:flex><span>	go build -o myapp main.go
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>clean:
</span></span><span style=display:flex><span>	rm -rf myapp
</span></span></code></pre></div><p>这里的 <code>build</code> 有一个前置条件 <code>clean</code> ，意思就是当你执行 <code>make build</code> 时，会先执行 <code>clean</code> 的指令内容 <code>rm -rf myapp</code> ，然后再执行 <code>build</code> 的内容 <code>go build -o myapp main.go</code> 。</p><h2 id=变量>变量
<a class=heading-link href=#%e5%8f%98%e9%87%8f><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>自定义变量，示例：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>APP=myapp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>build: clean
</span></span><span style=display:flex><span>	go build -o ${APP} main.go
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>clean:
</span></span><span style=display:flex><span>	rm -rf ${APP}
</span></span></code></pre></div><h2 id=phony>PHONY
<a class=heading-link href=#phony><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>上例中的定义了 <code>target</code> 目标有 <code>build</code> 和 <code>clean</code> ，如果当前目录中正好有一个文件叫做 <code>build</code> 或 <code>clean</code>，那么其指令内容不会执行，这是因为 make 会把 <code>target</code> 视为文件，只有当文件不存在或发生改变时才会去执行命令。</p><p>为了解决这个问题，我们需要使用 <code>PHONY</code> 声明 <code>target</code> 其实是伪目标：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>APP=myapp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.PHONY: build
</span></span><span style=display:flex><span>build: clean
</span></span><span style=display:flex><span>	go build -o ${APP} main.go
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.PHONY: clean
</span></span><span style=display:flex><span>clean:
</span></span><span style=display:flex><span>	rm -rf ${APP}
</span></span></code></pre></div><p>多个 PHONY 也可以统一声明在一行中:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>.PHONY: build clean
</span></span></code></pre></div><h2 id=递归的目标>递归的目标
<a class=heading-link href=#%e9%80%92%e5%bd%92%e7%9a%84%e7%9b%ae%e6%a0%87><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>假设我们的工程目录结构如下：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>~/project
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>├── main.go
</span></span><span style=display:flex><span>├── Makefile
</span></span><span style=display:flex><span>└── mymodule/
</span></span><span style=display:flex><span>      ├── main.go
</span></span><span style=display:flex><span>      └── Makefile
</span></span></code></pre></div><p>文件根目录下还有一个文件夹 <code>mymodule</code>，它可能是一个单独的模块，也需要打包构建，并且定义有自己的 <code>Makefile</code> :</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span># ~/project/mymodule/Makefile
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>APP=module
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>build:
</span></span><span style=display:flex><span>	go build -o ${APP} main.go
</span></span></code></pre></div><p>现在当你处于项目的根目录时，如何去执行 mymodule 子目录下定义的 <code>Makefile</code> 呢？</p><p>使用 <code>cd</code> 命令也可以，不过我们有其它的方式去解决这个问题：使用 <code>-C</code> 标志和特定的 <code>${MAKE}</code> 变量。</p><p>修改项目根目录中的 <code>Makefile</code> 为：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-v data-lang=v><span style=display:flex><span><span style=font-weight:700>APP</span>=myapp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.<span style=font-weight:700>PHONY</span>: build
</span></span><span style=display:flex><span>build: clean
</span></span><span style=display:flex><span>	<span style=font-weight:700>go</span> build -o <span>$</span>{<span style=font-weight:700>APP</span>} main.<span style=font-weight:700>go</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.<span style=font-weight:700>PHONY</span>: clean
</span></span><span style=display:flex><span>clean:
</span></span><span style=display:flex><span>	rm -rf <span>$</span>{<span style=font-weight:700>APP</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.<span style=font-weight:700>PHONY</span>: build-mymodule
</span></span><span style=display:flex><span>build-mymodule:
</span></span><span style=display:flex><span>	<span>$</span>{<span style=font-weight:700>MAKE</span>} -<span style=font-weight:700>C</span> mymodule build
</span></span></code></pre></div><p>这样，当你执行 <code>make build-mymodule</code> 时，其将会自动切换到 <code>mymodule</code> 目录，并且执行 <code>mymodule</code> 目录下的 <code>Makefile</code> 中定义的 <code>build</code> 指令。</p><h2 id=shell-输出作为变量>shell 输出作为变量
<a class=heading-link href=#shell-%e8%be%93%e5%87%ba%e4%bd%9c%e4%b8%ba%e5%8f%98%e9%87%8f><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>我们可以把 shell 中执行的指令的输出作为变量：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>V=$(shell go version)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>gv:
</span></span><span style=display:flex><span>	echo ${V}
</span></span></code></pre></div><p>这里执行 <code>make gv</code> 就会先执行 <code>go version</code> 指令然后把输出的内容赋值给变量 V 。</p><h2 id=判断语句>判断语句
<a class=heading-link href=#%e5%88%a4%e6%96%ad%e8%af%ad%e5%8f%a5><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>假设我们的指令依赖于环境变量 <code>ENV</code> ，我们可以使用一个前置条件去检查是否忘了输入 <code>ENV</code> ：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>.PHONY: run
</span></span><span style=display:flex><span>run: <span style=font-weight:700>check</span>-env
</span></span><span style=display:flex><span>	echo <span>${</span>ENV<span>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>check</span>-env:
</span></span><span style=display:flex><span>ifndef ENV
</span></span><span style=display:flex><span>    <span>$</span>(error ENV <span style=font-weight:700>not</span> <span>set</span>, allowed <span style=font-weight:700>values</span> - `staging` <span style=font-weight:700>or</span> `production`)
</span></span><span style=display:flex><span>endif
</span></span></code></pre></div><p>这里当我们执行 <code>make run</code> 时，因为有前置条件 <code>check-env</code> 会先执行前置条件中的内容，指令内容是一个判断语句，判断 <code>ENV</code> 是否未定义，如果未定义，则会抛出一个错误，错误提示就是 <code>error</code> 后面的内容。</p><h2 id=帮助提示>帮助提示
<a class=heading-link href=#%e5%b8%ae%e5%8a%a9%e6%8f%90%e7%a4%ba><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>添加 <code>help</code> 帮助提示：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>.PHONY: build
</span></span><span style=display:flex><span>## build: build the application
</span></span><span style=display:flex><span>build: clean
</span></span><span style=display:flex><span>    @echo &#34;Building...&#34;
</span></span><span style=display:flex><span>    @go build -o ${APP} main.go
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.PHONY: run
</span></span><span style=display:flex><span>## run: runs go run main.go
</span></span><span style=display:flex><span>run:
</span></span><span style=display:flex><span>	go run -race main.go
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.PHONY: clean
</span></span><span style=display:flex><span>## clean: cleans the binary
</span></span><span style=display:flex><span>clean:
</span></span><span style=display:flex><span>    @echo &#34;Cleaning&#34;
</span></span><span style=display:flex><span>    @rm -rf ${APP}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.PHONY: setup
</span></span><span style=display:flex><span>## setup: setup go modules
</span></span><span style=display:flex><span>setup:
</span></span><span style=display:flex><span>	@go mod init \
</span></span><span style=display:flex><span>		&amp;&amp; go mod tidy \
</span></span><span style=display:flex><span>		&amp;&amp; go mod vendor
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.PHONY: help
</span></span><span style=display:flex><span>## help: prints this help message
</span></span><span style=display:flex><span>help:
</span></span><span style=display:flex><span>	@echo &#34;Usage: \n&#34;
</span></span><span style=display:flex><span>	@sed -n &#39;s/^##//p&#39; ${MAKEFILE_LIST} | column -t -s &#39;:&#39; |  sed -e &#39;s/^/ /&#39;
</span></span></code></pre></div><p>这样当你执行 <code>make help</code> 时，就是打印如下的提示内容：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Usage:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  build   build the application
</span></span><span style=display:flex><span>  run     runs go run main.go
</span></span><span style=display:flex><span>  clean   cleans the binary
</span></span><span style=display:flex><span>  setup   setup go modules
</span></span><span style=display:flex><span>  help    prints this help message
</span></span></code></pre></div><h2 id=参考资料>参考资料
<a class=heading-link href=#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><ul><li><a href=https://danishpraka.sh/2019/12/07/using-makefiles-for-go.html>https://danishpraka.sh/2019/12/07/using-makefiles-for-go.html</a></li><li><a href=http://www.ruanyifeng.com/blog/2015/02/make.html>http://www.ruanyifeng.com/blog/2015/02/make.html</a></li><li><a href=https://www.gnu.org/software/make/manual/make.html>https://www.gnu.org/software/make/manual/make.html</a></li></ul></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2019 -
2023
凌虚
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>