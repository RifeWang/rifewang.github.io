<!doctype html><html lang=en><head><title>从 V8 优化看高效 JavaScript【译】 · 凌虚 Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="凌虚"><meta name=description content="从 V8 优化看高效 JavaScript【译】"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="从 V8 优化看高效 JavaScript【译】"><meta name=twitter:description content="从 V8 优化看高效 JavaScript【译】"><meta property="og:title" content="从 V8 优化看高效 JavaScript【译】"><meta property="og:description" content="从 V8 优化看高效 JavaScript【译】"><meta property="og:type" content="article"><meta property="og:url" content="https://rifewang.github.io/posts/uncate/efficient-js-from-v8-optimization/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-09-18T19:15:57+08:00"><meta property="article:modified_time" content="2019-09-18T19:15:57+08:00"><link rel=canonical href=https://rifewang.github.io/posts/uncate/efficient-js-from-v8-optimization/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.0fa2dc75ed1b76894ac0e062b10a6c4730daa745096fa120114b290ed8a48788.css integrity="sha256-D6Lcde0bdolKwOBisQpsRzDap0UJb6EgEUspDtikh4g=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.593028e7f7ac55c003b79c230d1cd411bb4ca53b31556c3abb7f027170e646e9.css integrity="sha256-WTAo5/esVcADt5wjDRzUEbtMpTsxVWw6u38CcXDmRuk=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.110.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>凌虚 Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>博客</a></li><li class=navigation-item><a class=navigation-link href=/translation/>译文</a></li><li class=navigation-item><a class=navigation-link href=/about/>关于</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://rifewang.github.io/posts/uncate/efficient-js-from-v8-optimization/>从 V8 优化看高效 JavaScript【译】</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2019-09-18T19:15:57+08:00>September 18, 2019</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
2-minute read</span></div><div class=categories><i class="fa fa-folder" aria-hidden=true></i>
<a href=/categories/node.js/>Node.js</a></div></div></header><div class=post-content><p><em>文本翻译自:
<a href=https://blog.logrocket.com/how-javascript-works-optimizing-the-v8-compiler-for-efficiency>https://blog.logrocket.com/how-javascript-works-optimizing-the-v8-compiler-for-efficiency</a></em></p><hr><p>理解 JavaScript 是如何工作的对于编写高效的 JS 大有帮助。</p><p>V8 执行 JS 分为三个阶段：</p><ul><li>源代码转换为 AST 抽象语法树。</li><li>语法树转换为字节码：这个过程由 V8 的 Ignition 完成，2017年之前是没有的。</li><li>字节码编译成机器码：由 V8 的编译器 TurboFan 来完成。</li></ul><p>第一个阶段并不是文本的讨论范围，第二三阶段对于编写优化 JS 有直接影响。</p><p>实际上第二三阶段是紧耦合的，它们都在 just-in-time（ JIT ）内运作。为了理解 JIT ，我们先回顾下源代码转换为机器码的两种方法：</p><p>1、解释器
解释器逐行转换和执行代码，其优点是易于实现和理解、及时反馈、更宽泛的编程环境，缺点也非常明显，那就是速度慢，慢的原因在于（1）反复解释的开销和（2）无法优化程序的各个部分。</p><p>换句话说，解释器在处理不同的代码段时无法识别重复的工作量。如果你通过解释器运行相同的代码 100 次，那么解释器将会翻译并执行相同的代码 100 次，其中不必要的重新翻译了 99 次。</p><p>解释器很简单、启动快速，但执行速度慢。</p><p>2、编译器
编译器在执行之前翻译所有的源代码。编译器更加复杂，但是可以进行全局优化（例如，共享重复代码），其执行速度也更快。</p><p>编译器更复杂、启动慢，但执行速度更快。</p><p>JIT 的作用就是尽可能结合解释器和编译器的优点，以使翻译代码和执行都能快速。</p><p>基本思想是尽可能避免重新翻译。首先，探测器通过解释器运行代码，在执行期间，探测器会追踪代码段并将其会被划分为 warm（运行少数几次） 和 hot（运行重复多次）。</p><p>JIT 把 warm 代码段直接丢给基准编译器，尽可能重用已编译的代码。</p><p>JIT 把 hot 代码段丢给优化编译器，其根据解释器收集来的信息（1）作出假设，（2）基于假设（比如，对象属性始终以特定顺序出现）进行优化。
然而，一旦假设不成立，优化编译器就会进行 deoptimization 去优化，就是丢弃优化的代码。</p><p>优化和去优化的周期是昂贵的。由于需要存储优化过的机器码和探测器的信息，JIT 引入了额外的内存成本。这种成本激发了 V8 的解释器 Ignition 。</p><p>Ignition 将 AST 转换为字节码，字节码序列被执行，其反馈信息被 inline caches 内联高速缓存。 反馈信息被用于（1）Ignition 随后的解释，和（2）TurboFan 推测性优化。
TurboFan 基于反馈推测性的优化将字节码转换为机器码。</p><hr><h2 id=如何优化你的-javascript>如何优化你的 JavaScript
<a class=heading-link href=#%e5%a6%82%e4%bd%95%e4%bc%98%e5%8c%96%e4%bd%a0%e7%9a%84-javascript><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><h3 id=1在构造函数中声明对象属性>1、在构造函数中声明对象属性
<a class=heading-link href=#1%e5%9c%a8%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e4%b8%ad%e5%a3%b0%e6%98%8e%e5%af%b9%e8%b1%a1%e5%b1%9e%e6%80%a7><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>改变对象的属性将会导致新的隐藏类：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>class Point {
</span></span><span style=display:flex><span>  constructor(x, y) {
</span></span><span style=display:flex><span>    this.x = x;
</span></span><span style=display:flex><span>    this.y = y;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var p1 = new Point(11, 22);  // hidden class Point created
</span></span><span style=display:flex><span>var p2 = new Point(33, 44);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>p1.z = 55;  // another hidden class Point created
</span></span></code></pre></div><p>本来 p1 和 p2 应该使用的是同一个隐藏类，但是由于 p1.z 的原因将会导致它们使用不同的隐藏类，这将导致 TurboFan 的去优化，这是应该避免的。</p><h3 id=2保持对象属性排序不变>2、保持对象属性排序不变
<a class=heading-link href=#2%e4%bf%9d%e6%8c%81%e5%af%b9%e8%b1%a1%e5%b1%9e%e6%80%a7%e6%8e%92%e5%ba%8f%e4%b8%8d%e5%8f%98><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>改变对象属性的排序也将会导致新的隐藏类：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const a1 = { a: 1 };  # hidden class a1 created
</span></span><span style=display:flex><span>a1.b = 3;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const a2 = { b: 3 };  # different hidden class a2 created
</span></span><span style=display:flex><span>a2.a = 1;
</span></span></code></pre></div><p>保持对象属性的排序有利于重用相同的隐藏类，效率更高。</p><h3 id=3注意函数的参数类型>3、注意函数的参数类型
<a class=heading-link href=#3%e6%b3%a8%e6%84%8f%e5%87%bd%e6%95%b0%e7%9a%84%e5%8f%82%e6%95%b0%e7%b1%bb%e5%9e%8b><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>函数参数类型的更改也将会导致去优化和重新优化：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>function add(x, y) {
</span></span><span style=display:flex><span>  return x + y
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>add(1, 2);  # monomorphic
</span></span><span style=display:flex><span>add(&#34;a&#34;, &#34;b&#34;);  # polymorphic
</span></span><span style=display:flex><span>add(true, false);
</span></span><span style=display:flex><span>add([], []);
</span></span><span style=display:flex><span>add({}, {});  # megamorphic
</span></span></code></pre></div><p>比如这个函数，由于参数类型的易变将会导致编译器无法优化。</p><h3 id=4在-script-域声明类>4、在 script 域声明类
<a class=heading-link href=#4%e5%9c%a8-script-%e5%9f%9f%e5%a3%b0%e6%98%8e%e7%b1%bb><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>不要在函数范围内定义类：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>function createPoint(x, y) {
</span></span><span style=display:flex><span>  class Point {
</span></span><span style=display:flex><span>    constructor(x, y) {
</span></span><span style=display:flex><span>      this.x = x;
</span></span><span style=display:flex><span>      this.y = y;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  return new Point(x, y);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>function length(point) {
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个函数每被调用一次，一个新的原型就被会创建，每个新的原型都会对应一个新的对象 shape ，这也是无法优化的。</p><h3 id=5使用-for--in>5、使用 <code>for ... in</code>
<a class=heading-link href=#5%e4%bd%bf%e7%94%a8-for--in><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p><code>for ... in</code> 循环是 V8 引擎特别优化过的，可以快 4 到 6 倍。</p><h3 id=6不相关的字符不会影响性能>6、不相关的字符不会影响性能
<a class=heading-link href=#6%e4%b8%8d%e7%9b%b8%e5%85%b3%e7%9a%84%e5%ad%97%e7%ac%a6%e4%b8%8d%e4%bc%9a%e5%bd%b1%e5%93%8d%e6%80%a7%e8%83%bd><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>早期使用的是函数的字节计数来确定是否内联函数，但是现在使用的是 AST 的节点数量来确定函数的大小。这就是说，诸如空格、注释、变量名称长度、函数签名之类的不相关字符不会影响函数的性能。</p><h3 id=7try--catch--finally-并不是毁灭性的>7、Try / catch / finally 并不是毁灭性的
<a class=heading-link href=#7try--catch--finally-%e5%b9%b6%e4%b8%8d%e6%98%af%e6%af%81%e7%81%ad%e6%80%a7%e7%9a%84><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>Try 以前会导致昂贵的优化和去优化循环，但是现在并不会导致明显的性能影响。</p><p>文本翻译有部分删减，全部内容可查看原始文章。</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2019 -
2023
凌虚
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>