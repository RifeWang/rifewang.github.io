<!doctype html><html lang=en><head><title>微服务互通的桥梁: gRPC 入门示例 · 凌虚 Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="凌虚"><meta name=description content="微服务互通的桥梁: gRPC 入门示例"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="微服务互通的桥梁: gRPC 入门示例"><meta name=twitter:description content="微服务互通的桥梁: gRPC 入门示例"><meta property="og:title" content="微服务互通的桥梁: gRPC 入门示例"><meta property="og:description" content="微服务互通的桥梁: gRPC 入门示例"><meta property="og:type" content="article"><meta property="og:url" content="https://rifewang.github.io/posts/middleware/grpc/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-08-23T00:25:31+08:00"><meta property="article:modified_time" content="2019-08-23T00:25:31+08:00"><link rel=canonical href=https://rifewang.github.io/posts/middleware/grpc/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.0fa2dc75ed1b76894ac0e062b10a6c4730daa745096fa120114b290ed8a48788.css integrity="sha256-D6Lcde0bdolKwOBisQpsRzDap0UJb6EgEUspDtikh4g=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.593028e7f7ac55c003b79c230d1cd411bb4ca53b31556c3abb7f027170e646e9.css integrity="sha256-WTAo5/esVcADt5wjDRzUEbtMpTsxVWw6u38CcXDmRuk=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.110.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>凌虚 Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>博客</a></li><li class=navigation-item><a class=navigation-link href=/translation/>译文</a></li><li class=navigation-item><a class=navigation-link href=/about/>关于</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://rifewang.github.io/posts/middleware/grpc/>微服务互通的桥梁: gRPC 入门示例</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2019-08-23T00:25:31+08:00>August 23, 2019</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
2-minute read</span></div><div class=categories><i class="fa fa-folder" aria-hidden=true></i>
<a href=/categories/golang/>Golang</a></div></div></header><div class=post-content><p>RPC 是什么？Remote Procedure Call ，远程过程调用，一种通信协议。你可以理解为，在某台机器上调用另外一台机器上的服务或方法。</p><p>应用服务对外可以提供 REST 接口以供进行服务的调用，那么对于分布式系统内部的微服务之间的相互调用呢？REST 的方式仍然可行，但是效率不高，因此 RPC 出现了。</p><p>gRPC 是谷歌开源的一套 RPC 实现机制，低延迟、高性能，其基于 HTTP/2 和 Protocol Buffers 。HTTP/2 在现行 HTTP/1.1 的基础上进行了大量优化，比如由文本传输变为二进制传输，同时具有多路复用、双向流等等特点，总之就是更牛了。Protocol Buffers 是一个序列化或反序列化数据的协议，说白了就是文本数据与二进制数据之间的相互转换。</p><p>文本将会带你入门 gRPC ，并且提供 Node.js 和 Go 两个版本的示例。</p><hr><h2 id=protocol-buffers>Protocol Buffers
<a class=heading-link href=#protocol-buffers><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>服务之间相互调用需要定义统一的数据格式（比如请求和响应），同时还要声明具体的服务及其方法，因此我们首先要做的就是定义一个 <code>.proto</code> 后缀的文件。</p><p>示例：</p><p><img src=/images/middleware/grpc1.png alt></p><p>1、<code>syntax</code> 声明使用的 protocol buffers 协议版本，现行的是第三版。
2、<code>package</code> 声明自定义的包名，这里的 package 可以理解为 go 中的包，或者 node.js 中的 module 。
3、<code>message</code> 定义数据格式，比如这里的 ReqBody 是请求的数据，响应结果则是 UserOrders ，名称都是自定义的，message 可以嵌套使用，message 内部需要定义具体的字段名称和数据类型，字段需要从 1 开始依次编号，但是枚举类型比较特别，枚举值从 0 开始编号。通过 repeated 声明某个字段可以重复，也就是这个数据是一个数组的形式。
4、<code>service</code> 定义服务名称，<code>rpc</code> 定义该服务下具体的方法，以及请求和响应的数据格式。</p><p>这个示例定义的是，我有一个服务叫 RPCService ，这个服务有一个方法叫 QueryUserOrders ，调用这个方法需要传递的请求数据的格式是 ReqBody ，响应结果的数据格式是 UserOrders 。</p><p>很简单是不是，<code>.proto</code> 协议文件清晰的定义了 RPC 服务、服务下的方法、请求和响应的数据格式，而 RPC 服务的客户端和服务端则将根据这个协议进行相互。</p><p>下面将会构建 RPC 服务端响应数据，以及 RPC 客户端发起请求。</p><h2 id=nodejs-版本>Node.js 版本
<a class=heading-link href=#nodejs-%e7%89%88%e6%9c%ac><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>在 Node.js 中使用 gRPC 非常简单，我们需要依赖 <code>grpc</code> 和 <code>@grpc/proto-loader</code> 这两个官方包。</p><p>1、构建 gRPC 服务端：</p><p><img src=/images/middleware/grpc2.jpeg alt></p><p>如图所示，我们需要导入前面定义好的 .proto 文件，同时由于语言本身数据类型的不同，可以设置类型转换，比如将 .proto 中定义的枚举类型转换为 node.js 中的 string 类型。</p><p>gRPC 服务端需要按照 .proto 的约定，绑定服务以及实现具体的方法，同时由于其底层基于 HTTP/2 协议通信，因此还需要监听一个具体的端口并且启动这个 gRPC 服务。</p><p>2、构建 gRPC 客户端发起 RPC 调用：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span># --proto_path 源路径， --go_out 输出路径，一定要指明 plugins=grpc
</span></span><span style=display:flex><span>protoc --proto_path=grpc --go_out=plugins=grpc:grpc test.proto
</span></span></code></pre></div><p>需要注意的是，包名、服务名、方法名必须和 .proto 文件定义的保持一致。</p><h2 id=go-版本>Go 版本
<a class=heading-link href=#go-%e7%89%88%e6%9c%ac><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>与 Node.js 不同的是 Go 是一个静态语言，需要先编译才能运行，因此使用 gRPC 有一点不同，我们先要去官网
<a href=https://github.com/protocolbuffers/protobuf/releases>https://github.com/protocolbuffers/protobuf/releases</a>
下载并安装 protoc（ protocol buffers 编译器）。</p><p>1、执行 protoc 指令：</p><p><img src=/images/middleware/grpc3.png alt></p><p>编译 .proto 文件生成 .pb.go 代码包，在后续的使用中需要导入这个代码包。</p><p>2、构造 gRPC 服务端：</p><p><img src=/images/middleware/grpc4.jpeg alt></p><p>3、构建 gRPC 客户端发起 RPC 调用：</p><p><img src=/images/middleware/grpc5.png alt></p><p><code>protoc</code> 编译 <code>.proto</code> 文件生成的 <code>.pb.go</code> 代码包里面包含了所有的服务、方法、数据结构等等，在我们的 go 代码中引用它们即可。</p><h2 id=结语>结语
<a class=heading-link href=#%e7%bb%93%e8%af%ad><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>不论是 gRPC 的客户端还是服务端并没有限制具体的语言，这意味着你完全可以使用 node.js 客户端去调用 go 服务端，或者其它任意语言的组合。</p><p>但是 gRPC 官方当前支持的语言是有限的，只有 Android、C#、C++、Dart、Go、Java、Node、PHP、Python、Ruby、Web（ js + envoy ）。</p><p>其次，gRPC 并不是万能的，比如大数据集（单条消息超过 1 MB ）就不适合用 gRPC ，即使你可以通过分块流式的方法来实现，但是复杂度会成倍的增加。</p><hr><p><em>更多参考资料：</em></p><ul><li><em><a href=https://developers.google.com/protocol-buffers/docs/overview>https://developers.google.com/protocol-buffers/docs/overview</a></em></li><li><em><a href=https://www.grpc.io/docs/guides>https://www.grpc.io/docs/guides</a></em></li><li><em><a href=https://github.com/grpc/grpc-node>https://github.com/grpc/grpc-node</a></em></li><li><em><a href=https://github.com/grpc/grpc-go>https://github.com/grpc/grpc-go</a></em></li></ul></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2019 -
2023
凌虚
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>