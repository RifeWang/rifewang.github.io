<!doctype html><html lang=en><head><title>解读 MySQL Client/Server Protocol: Connection & Replication · 凌虚 Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="凌虚"><meta name=description content="解读 MySQL Client/Server Protocol: Connection & Replication Link to heading MySQL 客户端与服务器之间的通信基于特定的 TCP 协议，本文将会详解其中的 Connection 和 Replication 部分，这两个部分分别对应的是客户端与服务器建立连接、完成认证鉴权，以及客户端注册成为一个 slave 并获取 master 的 binlog 日志。
Connetcion Phase Link to heading MySQL 客户端想要与服务器进行通信，第一步就是需要成功建立连接，整个过程如下图所示：
client 发起一个 TCP 连接。 server 响应一个 Initial Handshake Packet（初始化握手包），内容会包含一个默认的认证方式。 这一步是可选的，双方建立 SSL 加密连接。 client 回应 Handshake Response Packet，内容需要包括用户名和按照指定方式进行加密后的密码数据。 server 响应 OK_Packet 确认认证成功，或者 ERR_Packet 表示认证失败并关闭连接。 Packet Link to heading 一个 Packet 其实就是一个 TCP 包，所有包都有一个最基本的结构：
如上图所示，所有包都可以看作由 header 和 body 两部分构成：第一部分 header 总共有 4 个字节，3 个字节用来标识 body 即 payload 的大小，1 个字节记录 sequence ID；第二部分 body 就是 payload 实际的负载数据。"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="解读 MySQL Client/Server Protocol: Connection & Replication"><meta name=twitter:description content="解读 MySQL Client/Server Protocol: Connection & Replication Link to heading MySQL 客户端与服务器之间的通信基于特定的 TCP 协议，本文将会详解其中的 Connection 和 Replication 部分，这两个部分分别对应的是客户端与服务器建立连接、完成认证鉴权，以及客户端注册成为一个 slave 并获取 master 的 binlog 日志。
Connetcion Phase Link to heading MySQL 客户端想要与服务器进行通信，第一步就是需要成功建立连接，整个过程如下图所示：
client 发起一个 TCP 连接。 server 响应一个 Initial Handshake Packet（初始化握手包），内容会包含一个默认的认证方式。 这一步是可选的，双方建立 SSL 加密连接。 client 回应 Handshake Response Packet，内容需要包括用户名和按照指定方式进行加密后的密码数据。 server 响应 OK_Packet 确认认证成功，或者 ERR_Packet 表示认证失败并关闭连接。 Packet Link to heading 一个 Packet 其实就是一个 TCP 包，所有包都有一个最基本的结构：
如上图所示，所有包都可以看作由 header 和 body 两部分构成：第一部分 header 总共有 4 个字节，3 个字节用来标识 body 即 payload 的大小，1 个字节记录 sequence ID；第二部分 body 就是 payload 实际的负载数据。"><meta property="og:title" content="解读 MySQL Client/Server Protocol: Connection & Replication"><meta property="og:description" content="解读 MySQL Client/Server Protocol: Connection & Replication Link to heading MySQL 客户端与服务器之间的通信基于特定的 TCP 协议，本文将会详解其中的 Connection 和 Replication 部分，这两个部分分别对应的是客户端与服务器建立连接、完成认证鉴权，以及客户端注册成为一个 slave 并获取 master 的 binlog 日志。
Connetcion Phase Link to heading MySQL 客户端想要与服务器进行通信，第一步就是需要成功建立连接，整个过程如下图所示：
client 发起一个 TCP 连接。 server 响应一个 Initial Handshake Packet（初始化握手包），内容会包含一个默认的认证方式。 这一步是可选的，双方建立 SSL 加密连接。 client 回应 Handshake Response Packet，内容需要包括用户名和按照指定方式进行加密后的密码数据。 server 响应 OK_Packet 确认认证成功，或者 ERR_Packet 表示认证失败并关闭连接。 Packet Link to heading 一个 Packet 其实就是一个 TCP 包，所有包都有一个最基本的结构：
如上图所示，所有包都可以看作由 header 和 body 两部分构成：第一部分 header 总共有 4 个字节，3 个字节用来标识 body 即 payload 的大小，1 个字节记录 sequence ID；第二部分 body 就是 payload 实际的负载数据。"><meta property="og:type" content="article"><meta property="og:url" content="https://rifewang.github.io/posts/mysql/protocol-connectionreplication/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-12-20T00:00:00+08:00"><meta property="article:modified_time" content="2020-12-20T00:00:00+08:00"><link rel=canonical href=https://rifewang.github.io/posts/mysql/protocol-connectionreplication/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.0fa2dc75ed1b76894ac0e062b10a6c4730daa745096fa120114b290ed8a48788.css integrity="sha256-D6Lcde0bdolKwOBisQpsRzDap0UJb6EgEUspDtikh4g=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.593028e7f7ac55c003b79c230d1cd411bb4ca53b31556c3abb7f027170e646e9.css integrity="sha256-WTAo5/esVcADt5wjDRzUEbtMpTsxVWw6u38CcXDmRuk=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.110.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>凌虚 Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/translation/>Translation</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://rifewang.github.io/posts/mysql/protocol-connectionreplication/>解读 MySQL Client/Server Protocol: Connection & Replication</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2020-12-20T00:00:00+08:00>December 20, 2020</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
4-minute read</span></div><div class=categories><i class="fa fa-folder" aria-hidden=true></i>
<a href=/categories/mysql/>MySQL</a></div></div></header><div class=post-content><h1 id=解读-mysql-clientserver-protocol-connection--replication>解读 MySQL Client/Server Protocol: Connection & Replication
<a class=heading-link href=#%e8%a7%a3%e8%af%bb-mysql-clientserver-protocol-connection--replication><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>MySQL 客户端与服务器之间的通信基于特定的 TCP 协议，本文将会详解其中的 Connection 和 Replication 部分，这两个部分分别对应的是客户端与服务器建立连接、完成认证鉴权，以及客户端注册成为一个 slave 并获取 master 的 binlog 日志。</p><h2 id=connetcion-phase>Connetcion Phase
<a class=heading-link href=#connetcion-phase><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>MySQL 客户端想要与服务器进行通信，第一步就是需要成功建立连接，整个过程如下图所示：</p><p><img src=https://raw.githubusercontent.com/RifeWang/images/master/mysql-protocol-connection-phase.png alt=connection-phase></p><ol><li>client 发起一个 TCP 连接。</li><li>server 响应一个 <a href=#Initial_Handshake_Packet><code>Initial Handshake Packet</code></a>（初始化握手包），内容会包含一个默认的认证方式。</li><li>这一步是可选的，双方建立 SSL 加密连接。</li><li>client 回应 <a href=#Handshake_Response_Packet><code>Handshake Response Packet</code></a>，内容需要包括用户名和按照指定方式进行加密后的密码数据。</li><li>server 响应 <a href=#OK_ERR><code>OK_Packet</code></a> 确认认证成功，或者 <a href=#OK_ERR><code>ERR_Packet</code></a> 表示认证失败并关闭连接。</li></ol><h3 id=packet>Packet
<a class=heading-link href=#packet><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>一个 Packet 其实就是一个 TCP 包，所有包都有一个最基本的结构：</p><p><img src=https://raw.githubusercontent.com/RifeWang/images/master/mysql-protocol-packet.png alt=packet></p><p>如上图所示，所有包都可以看作由 header 和 body 两部分构成：第一部分 header 总共有 4 个字节，3 个字节用来标识 body 即 payload 的大小，1 个字节记录 sequence ID；第二部分 body 就是 payload 实际的负载数据。</p><p>由于 payload length 只有 3 个字节来记录，所以一个 packet 的 payload 的大小不能超过 2^24 = 16 MB ，示例：</p><p><img src=https://raw.githubusercontent.com/RifeWang/images/master/mysql-protocol-packet-example.png alt=packet-example></p><p>Packet :</p><ul><li>当数据不超过 16 MB 时，准确来说是 payload 的大小不超过 2^24-1 Byte（三个字节所能表示的最大整数 0xFFFFFF），发送一个 packet 就够了。</li><li>当数据大小超过了 16 MB 时，就需要把数据切分成多个 packet 传输。</li><li>当数据 payload 的刚好是 2^24-1 Byte 时，一个包虽然足够了，但是为了表示数据传输完毕，仍然会多传一个 payload 为空的 packet 。</li></ul><p>Sequence ID：包的序列号，从 0 开始递增。在一个完整的会话过程中，每个包的序列号依次加一，当开始一个新的会话时，序列号重新从 0 开始。例如：在建立连接的阶段，server 发送 Initial Handshake Packet（ Sequence ID 为 0 ），client 回应 Handshake Response Packet（ Sequence ID 为 1 ），server 再响应 OK_Packet 或者 ERR_Packet（ Sequence ID 为 2 ），然后建立连接的阶段就结束了，再有后续的命令数据，包的 Sequence ID 就重新从 0 开始；在命令阶段（client 向 server 发送增删改查这些都属于命令阶段），一个命令的请求和响应就可以看作一个完整的会话过程，比如 client 先向 server 发送了一个查询请求，然后 server 对这个查询请求进行了响应，那么这一次会话就结束了，下一个命令就是新的会话，Sequence ID 也就重新从 0 开始递增。</p><h3 id=initial-handshake-packet-span-idinitial_handshake_packetspan>Initial Handshake Packet
<a class=heading-link href=#initial-handshake-packet-span-idinitial_handshake_packetspan><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>建立连接时，当客户端发起一个 TCP 连接后，MySQL 服务端就会回应一个 <code>Initial Handshake Packet</code> ，这个初始化握手包的数据格式如下图所示：</p><p><img src=https://raw.githubusercontent.com/RifeWang/images/master/mysql-protocol-handshakeV10.png alt=handshakeV10></p><p>这个图从上往下依次是：</p><ul><li>1 个字节的整数，表示 handshake protocol 的版本，现在都是 10 。</li><li>以 NUL（即一个字节 0x00）结尾的字符串，表示 MySQL 服务器的版本，例如 <code>5.7.18-log</code> 。</li><li>4 个字节的整数，表示线程 id，也是这个连接的 id。</li><li>8 个字节的字符串，<code>auth-plugin-data-part-1</code> 后续密码加密需要用到的随机数的前 8 位。</li><li>1 个字节的填充位。</li><li>2 个字节的整数，<code>capability_flags_1</code> 即 <code>Capabilities Flags</code> 的低位 2 位字节。</li><li>1 个字节的整数，表示服务器默认的字符编码格式，比如 <code>utf8_general_ci</code>。</li><li>2 个字节的整数，服务器的状态标识。</li><li>2 个字节的整数，<code>capability_flags_2</code> 即 <code>Capabilities Flags</code> 的高位 2 位字节。</li><li>1 个字节的整数，如果服务器具有 CLIENT_PLUGIN_AUTH 的能力（其实就是能够进行客户端身份验证，基本都支持），那么传递的是 <code>auth_plugin_data_len</code> 即加密随机数的长度，否则传递的是 0x00 。</li><li>10 个字节的填充位，全部是 0x00 。</li><li>由 <code>auth_plugin_data_len</code> 指定长度的字符串，<code>auth-plugin-data-part-2</code> 加密随机数的后 13 位。</li><li>如果服务器具有 CLIENT_PLUGIN_AUTH 的能力（其实就是能够进行客户端身份验证，基本都支持），那么传递的是 <code>auth_plugin_name</code> 即用户认证方式的名称。</li></ul><p>对于 MySQL 5.x 版本，默认的用户身份认证方式叫做 <code>mysql_native_password</code>（对应上面的 <code>auth_plugin_name</code>），这种认证方式的算法是：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>SHA1( password ) XOR SHA1( &#34;20-bytes random data from server&#34; &lt;concat&gt; SHA1( SHA1( password ) ) )
</span></span></code></pre></div><p>其中加密所需的 20 个字节的随机数就是 <code>auth-plugin-data-part-1</code>（ 8 位数）和 <code>auth-plugin-data-part-2</code>（ 13 位中的前 12 位数）组成。</p><p>注意：MySQL 使用的小端字节序。</p><p>看到这，你可能还对 <code>Capabilities Flags</code> 感到很困惑。</p><h4 id=capabilities-flags>Capabilities Flags
<a class=heading-link href=#capabilities-flags><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h4><p><code>Capabilities Flags</code> 其实就是一个功能标志，用来表明服务端和客户端支持并希望使用哪些功能。为什么需要这个功能标志？因为首先 MySQL 有众多版本，每个版本可能支持的功能有区别，所以服务端需要表明它支持哪些功能；其次，对服务端来说，连接它的客户端可以是各种各样的，这些客户端希望使用哪些功能也是需要表明的。</p><p><code>Capabilities Flags</code> 一般是 4 个字节的整数：</p><p><img src=https://raw.githubusercontent.com/RifeWang/images/master/mysql-protocol-capability.png alt=capability></p><p>如上图所示，每个功能都独占一个 bit 位。</p><p><code>Capabilities Flags</code> 通常都是多个功能的组合表示，例如要表示 <code>CLIENT_PROTOCOL_41</code>、<code>CLIENT_PLUGIN_AUTH</code>、<code>CLIENT_SECURE_CONNECTION</code> 这三个功能，那么就把他们对应的 <code>0x00000200</code>、<code>0x00080000</code>、<code>0x00008000</code> 进行比特位或运算就能得到最终的值 <code>0x00088200</code> 也就是最终的 <code>Capabilities Flags</code>。</p><p>根据 <code>Capabilities Flags</code> 判断是否支持某个功能，例如 <code>Capabilities Flags</code> 的值是 <code>0x00088200</code>，要判断它是否支持 <code>CLIENT_SECURE_CONNECTION</code> 的功能，则直接进行比特位与运算即可，即 <code>Capabilities Flags</code> & <code>CLIENT_SECURE_CONNECTION</code> == <code>CLIENT_SECURE_CONNECTION</code> 。</p><h3 id=handshake-response-packet-span-idhandshake_response_packetspan>Handshake Response Packet
<a class=heading-link href=#handshake-response-packet-span-idhandshake_response_packetspan><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>建立连接的过程中，当客户端收到了服务端的 <code>Initial Handshake Packet</code> 后，需要向服务端回应一个 <code>Handshake Response Packet</code> ，包的数据格式如下图所示：</p><p><img src=https://raw.githubusercontent.com/RifeWang/images/master/mysql-protocol-handshakeResponse41.png alt=handshake_response_41></p><p>依次是：</p><ul><li>4 个字节的整数，<code>Capabilities Flags</code>，一定要设置 <code>CLIENT_PROTOCOL_41</code>，对于 MySQL 5.x 版本，使用默认的身份认证方式，还需要对应的设置 <code>CLIENT_PLUGIN_AUTH</code> 和 <code>CLIENT_SECURE_CONNECTION</code>。</li><li>4 个字节的整数，包大小的最大值，这里指的是命令包的大小，比如一条 SQL 最多能多大。</li><li>1 个字节的整数，字符编码方式。</li><li>23 个字节的填充位，全是 0x00。</li><li>以 NUL（0x00）结尾的字符串，登录的用户名。</li><li><code>CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA</code> 一般不使用。</li><li>1 个字节的整数，<code>auth_response_length</code>，密码加密后的长度。</li><li><code>auth_response_length</code> 指定长度的字符串，密码与随机数加密后的数据。</li><li>如果 <code>CLIENT_CONNECT_WITH_DB</code> 直接指定了连接的数据库，则需要传递以 NUL（0x00）结尾的字符串，内容是数据库名。</li><li><code>CLIENT_PLUGIN_AUTH</code> 一般都需要，默认方式需要传递的值就是 <code>mysql_native_password</code> 。</li></ul><p>可以看到，<code>Handshake Response Packet</code> 与 <code>Initial Handshake Packet</code> 其实是相对应的。</p><h3 id=ok_packet--err_packet-span-idok_errspan><code>OK_Packet</code> & <code>ERR_Packet</code>
<a class=heading-link href=#ok_packet--err_packet-span-idok_errspan><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p><code>OK_Packet</code> 和 <code>ERR_Packet</code> 是 MySQL 服务端通用的响应包。</p><p><img src=https://raw.githubusercontent.com/RifeWang/images/master/mysql-protocol-ok_packet.png alt=OK_Packet></p><p>MySQL 5.7.5 版本以后，<code>OK_Packet</code> 还包含了 <code>EOF_Packet</code>（用来显示警告和状态信息）。区分 <code>OK_Packet</code> 和 <code>EOF_Packet</code>:</p><ul><li>OK: header = 0x00 and length of packet > 7</li><li>EOF: header = 0xfe and length of packet &lt; 9</li></ul><p>MySQL 5.7.5 版本之前，<code>EOF_Packet</code> 是一个单独格式的包：</p><p><img src=https://raw.githubusercontent.com/RifeWang/images/master/mysql-protocol-EOF_Packet.png alt=EOF_Packet></p><p>如果身份认证通过、连接建立成功，返回的 <code>OK_Packet</code> 就会是：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>0x07 0x00 0x00 0x02 0x00 0x00 0x00 0x02 0x00 0x00 0x00
</span></span></code></pre></div><p>如果连接失败，或者出现错误则会返回 <code>ERR_Packet</code> 格式的包：</p><p><img src=https://raw.githubusercontent.com/RifeWang/images/master/mysql-protocol-err_packet.png alt=ERR_Packet></p><h2 id=replication>Replication
<a class=heading-link href=#replication><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>想要获取到 master 的 binlog 吗？只要你对接实现 replication 协议即可。</p><p><img src=https://raw.githubusercontent.com/RifeWang/images/master/mysql-protocol-replication.png alt=replication></p><ol><li>client 与 server 之间成功建立连接、完成身份认证，这个过程就是上文所述的 connection phase 。</li><li>client 向 server 发送 <code>COM_REGISTER_SLAVE</code> 包，表明要注册成为一个 slave ，server 响应 <code>OK_Packet</code> 或者 <code>ERR_Packet</code>，只有成功才能进行后续步骤。</li><li>client 向 server 发送 <code>COM_BINLOG_DUMP</code> 包，表明要开始获取 binlog 的内容。</li><li>server 响应数据，可能是：<ul><li><code>binlog network stream</code>（ binlog 网络流）。</li><li><code>ERR_Packet</code>，表示有错误发生。</li><li><code>EOF_Packet</code>，如果 <code>COM_BINLOG_DUMP</code> 中的 flags 设置为了 0x01 ，则在 binlog 没有更多新事件时发送 <code>EOF_Packet</code>，而不是阻塞连接继续等待后续 binlog event 。</li></ul></li></ol><h3 id=com_register_slave><code>COM_REGISTER_SLAVE</code>
<a class=heading-link href=#com_register_slave><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>客户端向 MySQL 发送 <code>COM_REGISTER_SLAVE</code> ，表明它要注册成为一个 slave，包格式如下图：
<img src=https://raw.githubusercontent.com/RifeWang/images/master/mysql-protocol-com_register_slave.png alt=com_register_slave></p><p>除了 1 个字节的固定内容 0x15 和 4 个字节的 server-id ，其他内容通常都是空或者忽略，需要注意的是这里的 user 和 password 并不是登录 MySQL 的用户名和密码，只是 slave 的一种标识而已。</p><h3 id=com_binlog_dump><code>COM_BINLOG_DUMP</code>
<a class=heading-link href=#com_binlog_dump><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>注册成为 slave 之后，发送 <code>COM_BINLOG_DUMP</code> 就可以开始接受 binlog event 了。</p><p><img src=https://raw.githubusercontent.com/RifeWang/images/master/mysql-protocol-com_binlog_dump.png alt=com_binlog_dump></p><ul><li>1 个字节的整数，固定内容 0x12 。</li><li>4 个字节的整数，<code>binlog-pos</code> 即 binlog 文件开始的位置。</li><li>2 个字节的整数，<code>flags</code>，一般情况下 slave 会一直保持连接等待接受 binlog event，但是当 flags 设置为了 0x01 时，如果当前 binlog 全部接收完了，则服务端会发送 <code>EOF_Packet</code> 然后结束整个过程，而不是保持连接继续等待后续 binlog event 。</li><li>4 个字节的整数，<code>server-id</code>，slave 的身份标识，MySQL 可以同时存在多个 slave ，每个 slave 必须拥有不同的 <code>server-id</code>。</li><li>不定长字符串，<code>binlog-filename</code>，开始的 binlog 文件名。查看当前的 binlog 文件名和 pos 位置，可以执行 SQL 语句 <code>show master status</code> ，查看所有的 binlog 文件，可以执行 SQL 语句 <code>show binary logs</code> 。</li></ul><h3 id=binlog-event>Binlog Event
<a class=heading-link href=#binlog-event><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>客户端注册 slave 成功，并且发送 <code>COM_BINLOG_DUMP</code> 正确，那么 MySQL 就会向客户端发送 binlog network stream 即 binlog 网络流，所谓的 binlog 网络流其实就是源源不断的 binlog event 包（对 MySQL 进行的操作，例如 inset、update、delete 等，在 binlog 中是以一个或多个 binlog event 的形式存在的）。</p><p>Replication 的两种方式：</p><ul><li>异步，默认方式，master 不断地向 slave 发送 binlog event ，无需 slave 进行 ack 确认。</li><li>半同步，master 向 slave 每发送一个 binlog event 都需要等待 ack 确认回复。</li></ul><p>Binlog 有三种模式：</p><ul><li><code>statement</code> ，binlog 存储的是原始 SQL 语句。</li><li><code>row</code> ，binlog 存储的是每行的实际前后变化。</li><li><code>mixed</code> ，混合模式，binlog 存储的一部分是 SQL 语句，一部分是每行变化。</li></ul><p>Binlog Event 的包格式如下图：</p><p><img src=https://raw.githubusercontent.com/RifeWang/images/master/mysql-protocol-binlog_event.png alt=binlog_event></p><p>每个 Binlog Event 包都有一个确定的 event header ，根据 event 类型的不同，可能还会有 post header 以及 payload 。</p><p>Binlog Event 的类型非常多：</p><ul><li>Binlog Management:<ul><li><code>START_EVENT_V3</code></li><li><code>FORMAT_DESCRIPTION_EVENT</code>: MySQL 5.x 及以上版本 binlog 文件中的第一个 event，内容是 binlog 的基本描述信息。</li><li><code>STOP_EVENT</code></li><li><code>ROTATE_EVENT</code>: binlog 文件发生了切换，binlog 文件中的最后一个 event。</li><li><code>SLAVE_EVENT</code></li><li><code>INCIDENT_EVENT</code></li><li><code>HEARTBEAT_EVENT</code>: 心跳信息，表明 slave 落后了 master 多少秒（执行 SQL 语句 <code>SHOW SLAVE STATUS</code> 输出的 <code>Seconds_Behind_Master</code> 字段）。</li></ul></li><li>Statement Based Replication Events（binlog 为 statement 模式时相关的事件）:<ul><li><code>QUERY_EVENT</code>: 原始 SQL 语句，例如 insert、update &mldr; 。</li><li><code>INTVAR_EVENT</code>: 基于会话变量的整数，例如把主键设置为了 auto_increment 自增整数，那么进行插入时，这个字段实际写入的值就记录在这个事件中。</li><li><code>RAND_EVENT</code>: 内部 RAND() 函数的状态。</li><li><code>USER_VAR_EVENT</code>: 用户变量事件。</li><li><code>XID_EVENT</code>: 记录事务 ID，事务 commit 提交了才会写入。</li></ul></li><li>Row Based Replication Events（binlog 为 row 模式时相关的事件）:<ul><li><code>TABLE_MAP_EVENT</code>: 记录了后续事件涉及到的表结构的映射关系。</li><li>v0 事件对应 MySQL 5.1.0 to 5.1.15 版本</li><li><code>DELETE_ROWS_EVENTv0</code>: 记录了行数据的删除。</li><li><code>UPDATE_ROWS_EVENTv0</code>: 记录了行数据的更新。</li><li><code>WRITE_ROWS_EVENTv0</code>: 记录了行数据的新增。</li><li>v1 事件对应 MySQL 5.1.15 to 5.6.x 版本</li><li><code>DELETE_ROWS_EVENTv1</code>: 记录了行数据的删除。</li><li><code>UPDATE_ROWS_EVENTv1</code>: 记录了行数据的更新。</li><li><code>WRITE_ROWS_EVENTv1</code>: 记录了行数据的新增。</li><li>v2 事件对应 MySQL 5.6.x 及其以上版本</li><li><code>DELETE_ROWS_EVENTv2</code>: 记录了行数据的删除。</li><li><code>UPDATE_ROWS_EVENTv2</code>: 记录了行数据的更新。</li><li><code>WRITE_ROWS_EVENTv2</code>: 记录了行数据的新增。</li></ul></li><li>LOAD INFILE replication（加载文件的特殊场景，本文不做介绍）:<ul><li><code>LOAD_EVENT</code></li><li><code>CREATE_FILE_EVENT</code></li><li><code>APPEND_BLOCK_EVENT</code></li><li><code>EXEC_LOAD_EVENT</code></li><li><code>DELETE_FILE_EVENT</code></li><li><code>NEW_LOAD_EVENT</code></li><li><code>BEGIN_LOAD_QUERY_EVENT</code></li><li><code>EXECUTE_LOAD_QUERY_EVENT</code></li></ul></li></ul><p>想要解析具体某个 binlog event 的内容，只要对照官方文档数据包的格式即可。</p><h2 id=结语>结语
<a class=heading-link href=#%e7%bb%93%e8%af%ad><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>MySQL Client/Server Protocol 协议其实很简单，就是相互之间按照约定的格式发包，而理解了协议，相信你自己就可以实现一个 lib 去注册成为一个 slave 然后解析 binlog 。</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2019 -
2023
凌虚
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>