<!doctype html><html lang=en><head><title>时序数据库 InfluxDB（六） · 凌虚 Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="凌虚"><meta name=description content="时序数据库 InfluxDB（六）"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="时序数据库 InfluxDB（六）"><meta name=twitter:description content="时序数据库 InfluxDB（六）"><meta property="og:title" content="时序数据库 InfluxDB（六）"><meta property="og:description" content="时序数据库 InfluxDB（六）"><meta property="og:type" content="article"><meta property="og:url" content="https://rifewang.github.io/posts/influxdb/6/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-11-06T13:36:39+08:00"><meta property="article:modified_time" content="2019-11-06T13:36:39+08:00"><link rel=canonical href=https://rifewang.github.io/posts/influxdb/6/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.0fa2dc75ed1b76894ac0e062b10a6c4730daa745096fa120114b290ed8a48788.css integrity="sha256-D6Lcde0bdolKwOBisQpsRzDap0UJb6EgEUspDtikh4g=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.593028e7f7ac55c003b79c230d1cd411bb4ca53b31556c3abb7f027170e646e9.css integrity="sha256-WTAo5/esVcADt5wjDRzUEbtMpTsxVWw6u38CcXDmRuk=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.110.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>凌虚 Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/translation/>Translation</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://rifewang.github.io/posts/influxdb/6/>时序数据库 InfluxDB（六）</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2019-11-06T13:36:39+08:00>November 6, 2019</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
5-minute read</span></div><div class=categories><i class="fa fa-folder" aria-hidden=true></i>
<a href=/categories/influxdb/>InfluxDB</a></div></div></header><div class=post-content><hr><h1 id=cq-连续查询>CQ 连续查询
<a class=heading-link href=#cq-%e8%bf%9e%e7%bb%ad%e6%9f%a5%e8%af%a2><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><hr><p>连续查询 Continuous Queries（ CQ ）是 InfluxDB 很重要的一项功能，它的作用是在 InfluxDB 数据库内部自动定期的执行查询，然后将查询结果存储到指定的 measurement 里。</p><p>配置文件中的相关配置：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>[continuous_queries]
</span></span><span style=display:flex><span>  enabled = true
</span></span><span style=display:flex><span>  log-enabled = true
</span></span><span style=display:flex><span>  query-stats-enabled = false
</span></span><span style=display:flex><span>  run-interval = &#34;1s&#34;
</span></span></code></pre></div><ul><li>enabled = true ：开启CQ</li><li>log-enabled = true ：输出 CQ 日志</li><li>query-stats-enabled = false ：关闭 CQ 执行相关的监控，不会将统计数据写入默认的监控数据库 _internal</li><li>run-interval = &ldquo;1s&rdquo; ：InfluxDB 每隔 1s 检查是否有 CQ 需要执行</li></ul><hr><h1 id=基本语法>基本语法
<a class=heading-link href=#%e5%9f%ba%e6%9c%ac%e8%af%ad%e6%b3%95><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><hr><h4 id=一->一 、
<a class=heading-link href=#%e4%b8%80-><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h4><p>基本语法：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>CREATE CONTINUOUS QUERY &lt;cq_name&gt; ON &lt;database_name&gt;
</span></span><span style=display:flex><span>BEGIN
</span></span><span style=display:flex><span>  &lt;cq_query&gt;
</span></span><span style=display:flex><span>END
</span></span></code></pre></div><p>在某个数据库上创建一个 CQ ，而查询的具体内容 cq_query 的语法为：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>SELECT &lt;function[s]&gt;
</span></span><span style=display:flex><span>  INTO &lt;destination_measurement&gt;
</span></span><span style=display:flex><span>  FROM &lt;measurement&gt;
</span></span><span style=display:flex><span>  [WHERE &lt;stuff&gt;]
</span></span><span style=display:flex><span>  GROUP BY time(&lt;interval&gt;)[,&lt;tag_key[s]&gt;]
</span></span></code></pre></div><ul><li>SELECT function[s] : 连续查询并不只是简单的查询原始数据，而是基于原始数据进行聚合、特选、转换、预测等处理，所以 CQ 必须要有一个或多个数据处理函数。</li><li>INTO &lt;destination_measurement> : 将 CQ 的结果存储到指定的 measurement 中。</li><li>FROM : 原始数据的来源 measurement 。</li><li>[WHERE ] : 可选项，原始数据的筛选条件。</li><li>GROUP BY time()[,&lt;tag_key[s]>] : 连续查询不是查一次就完了，而是每次查询指定时间范围内的数据，不断周期性的执行下去。</li></ul><p>定位一个 measurement 的完整格式是：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>&lt;database&gt;.&lt;RP&gt;.&lt;measurement&gt;
</span></span></code></pre></div><p>使用当前数据库和默认 RP 的情况就只需要 measurement 。</p><p>InfluxDB 支持的时长单位：</p><ul><li>ns : 纳秒</li><li>u / µ : 微秒</li><li>ms : 毫秒</li><li>s : 秒</li><li>m : 分钟</li><li>h : 小时</li><li>d : 天</li><li>w : 周</li></ul><h4 id=二>二、
<a class=heading-link href=#%e4%ba%8c><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h4><h5 id=1cq-在何时执行>1、CQ 在何时执行？
<a class=heading-link href=#1cq-%e5%9c%a8%e4%bd%95%e6%97%b6%e6%89%a7%e8%a1%8c><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h5><p>CQ 在何时执行取决于 CQ 创建完成的时间点、GROUP BY time() 设置的时间间隔、以及 InfluxDB 数据库预设的时间边界（这个预设的时间边界其实就是 1970.01.01 00:00:00 UTC 时间，对应 Unix timestamp 的 0 值）。</p><p>假设我在 2019.11.05（北京时间）创建好了一个 GROUP BY time(30d) 的 CQ（也就是时间间隔为 30 天），那么这个 CQ 会在什么时间点执行？</p><p>首先，2019.11.05 号转换为 timestamp 是 1572883200 秒；
再算1572883200 距离 0 值隔了多少个 30 天（一天是 86400 秒），1572883200/86400/30 = 606.8 ；
那么下一个 30 天就是 606.8 向上取整 607 ，607<em>86400</em>30 = 1573344000 ，转换为对应的日期就是 2019.11.10 号，这也就是第一次执行 CQ 的时间，之后每次执行就是往后推 30 天。</p><p>如果每次都这样算就很麻烦，但其实我们更常使用的时间间隔没有那么长，通常都是秒、分钟、小时单位，这种情况下直接从 0 速算就可以了，比如：</p><ul><li>在时间点 16:09:35 创建了 CQ ，GROUP BY time(30s) ，那么 CQ 的执行时间就是 16:10:00、16:10:30、16:11:00 以此类推（从 0s 开始速算）。</li><li>在时间点 16:16:08 创建了 CQ ，GROUP BY time(5m) ，那么 CQ 的执行时间就是 16:20:00、16:25:00、16:30:00 以此类推（从 0m 开始速算）。</li><li>在时间点 16:38:27 创建了 CQ ，GROUP BY time(2h) ，那么 CQ 的执行时间就是 18:00:00 、20:00:00 、22:00:00 以此类推（从 0h 开始速算）。</li></ul><h5 id=2cq-执行的数据范围>2、CQ 执行的数据范围？
<a class=heading-link href=#2cq-%e6%89%a7%e8%a1%8c%e7%9a%84%e6%95%b0%e6%8d%ae%e8%8c%83%e5%9b%b4><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h5><p>连续查询会根据 GROUP BY time() 的时间间隔确定作用的数据，每次执行所针对的数据的时间范围是 [ now() - GROUP BY time() ，now() ) 。</p><p>例如，GROUP BY time(1h) ：</p><ul><li>在 8:00 执行时，数据是时间大于等于 7:00，小于 8:00，即 [ 7:00 , 8:00 ) 范围内的数据。</li><li>在 9:00 执行时，数据是时间大于等于 8:00，小于 9:00，即 [ 8:00 , 9:00 ) 范围内的数据。</li></ul><p>你可以使用 WHERE 去过滤数据，但是 WHERE 里指定的时间范围会被忽略掉。</p><h5 id=3cq-的执行结果>3、CQ 的执行结果？
<a class=heading-link href=#3cq-%e7%9a%84%e6%89%a7%e8%a1%8c%e7%bb%93%e6%9e%9c><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h5><p>CQ 会将执行结果存储到指定的 measurement ，但是存储的具体字段有哪些呢？首先 time 是必不可少的，time 写入的是 CQ 执行时数据范围的开始时间点；其次就是 function 的处理结果，如果只有单一字段，那么 field key 就是 function 的名称，如果有多个字段，那么 field key 就是 function 名称_作用字段。</p><p>例如，GROUP BY time(30m) ，UTC 7:30 执行：
单一字段：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>SELECT mean(&#34;field&#34;)
</span></span><span style=display:flex><span>  INTO &#34;result_measurement&#34;
</span></span><span style=display:flex><span>  FROM &#34;source_measurement&#34;
</span></span><span style=display:flex><span>  GROUP BY time(30m)
</span></span></code></pre></div><p>CQ 结果：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>time                      mean
</span></span><span style=display:flex><span>2019-11-05T07:00:00Z      7
</span></span></code></pre></div><p>多字段：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>SELECT mean(&#34;*&#34;)
</span></span><span style=display:flex><span>  INTO &#34;result_measurement&#34;
</span></span><span style=display:flex><span>  FROM &#34;source_measurement&#34;
</span></span><span style=display:flex><span>  GROUP BY time(30m)
</span></span></code></pre></div><p>CQ 结果：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>time                      mean_field1    mean_field2
</span></span><span style=display:flex><span>2019-11-05T07:00:00Z      7              6.5
</span></span></code></pre></div><p>这里的 mean 对应的是 function 里的平均值函数。</p><h4 id=三>三、
<a class=heading-link href=#%e4%b8%89><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h4><p>GROUP BY time() 的完整格式是：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>GROUP BY time(&lt;interval&gt;[,&lt;offset_interval&gt;])
</span></span></code></pre></div><p>第二个参数 offset_interval 偏移量是可选的，这个偏移量会对 CQ 的执行时间和数据范围产生影响。</p><p>如果 GROUP BY time(1h) ，在 8:00 执行，数据范围是 [ 7:00 , 8:00 ) 。
那么 GROUP BY time(1h, 15m) 会使 CQ 的执行时间向后推迟 15m ，即在 8:15 执行，数据范围也就变成了 [ 7:15 , 8:15 ) 。</p><hr><h1 id=高级语法>高级语法
<a class=heading-link href=#%e9%ab%98%e7%ba%a7%e8%af%ad%e6%b3%95><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><hr><p>高级语法：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>CREATE CONTINUOUS QUERY &lt;cq_name&gt; ON &lt;database_name&gt;
</span></span><span style=display:flex><span>RESAMPLE EVERY &lt;interval&gt; FOR &lt;interval&gt;
</span></span><span style=display:flex><span>BEGIN
</span></span><span style=display:flex><span>  &lt;cq_query&gt;
</span></span><span style=display:flex><span>END
</span></span></code></pre></div><p>与基本语法不同的是，高级语法多了</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>RESAMPLE EVERY &lt;interval&gt; FOR &lt;interval&gt;
</span></span></code></pre></div><h4 id=1resample--every>1、RESAMPLE EVERY
<a class=heading-link href=#1resample--every><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h4><p>EVERY 定义了 CQ 执行的间隔：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>RESAMPLE EVERY 30m
</span></span></code></pre></div><p>意思就是每隔 30m 执行一次 CQ 。</p><p>示例：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>CREATE CONTINUOUS QUERY &#34;cq_every&#34; ON &#34;db&#34;
</span></span><span style=display:flex><span>RESAMPLE EVERY 30m
</span></span><span style=display:flex><span>BEGIN
</span></span><span style=display:flex><span>  SELECT mean(&#34;field&#34;)
</span></span><span style=display:flex><span>    INTO &#34;result_measurement&#34;
</span></span><span style=display:flex><span>    FROM &#34;source_measurement&#34;
</span></span><span style=display:flex><span>    GROUP BY time(1h)
</span></span><span style=display:flex><span>END
</span></span></code></pre></div><p>如果没有 RESAMPLE EVERY 30m ，只有 GROUP BY time(1h) 将会：</p><ul><li>在 8:00 执行 CQ ，数据范围是 [ 7:00 , 8:00 )</li><li>在 9:00 执行 CQ ，数据范围是 [ 8:00 , 9:00 )</li></ul><p>增加了 RESAMPLE EVERY 30m 之后，每 30m 执行一次 CQ ：</p><ul><li>在 8:00 执行 CQ ，数据范围是 [ 7:00 , 8:00 )</li><li>在 8:30 执行 CQ ，数据范围是 [ 8:00 , 9:00 )</li><li>在 9:00 执行 CQ ，数据范围是 [ 8:00 , 9:00 ) ，由于执行结果的 time 字段是 8:00 与上一次 CQ 一致，因此会覆盖上一次 CQ 的结果。</li></ul><p>当 EVERY 的时间间隔小于 GROUP BY time() 时，会增加 CQ 的执行频率（如上述示例）。</p><p>当 EVERY 与 GROUP BY time() 的时间间隔一致时，无影响。</p><p>当 EVERY 的时间间隔大于 GROUP BY time() 时，CQ 执行时间和数据范围完全由 EVERY 控制，例如 EVERY 30m ，GROUP BY time(10m) ：</p><ul><li>在 8:00 执行 CQ ，数据范围是 [ 7:30 , 8:00 )</li><li>在 8:30 执行 CQ ，数据范围是 [ 8:00 , 8:30 )</li></ul><h4 id=2resample--for>2、RESAMPLE FOR
<a class=heading-link href=#2resample--for><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h4><p>FOR 定义了数据的时间范围：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>RESAMPLE FOR 1h
</span></span></code></pre></div><p>意思就是每次 CQ 的数据的时间范围是 1h 。</p><p>示例：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>CREATE CONTINUOUS QUERY &#34;cq_for&#34; ON &#34;db&#34;
</span></span><span style=display:flex><span>RESAMPLE FOR 1h
</span></span><span style=display:flex><span>BEGIN
</span></span><span style=display:flex><span>  SELECT mean(&#34;field&#34;)
</span></span><span style=display:flex><span>    INTO &#34;result_measurement&#34;
</span></span><span style=display:flex><span>    FROM &#34;source_measurement&#34;
</span></span><span style=display:flex><span>    GROUP BY time(30m)
</span></span><span style=display:flex><span>END
</span></span></code></pre></div><p>如果没有 RESAMPLE FOR 1h ，只有 GROUP BY time(30m) 将会：</p><ul><li>在 8:00 执行 CQ ，数据范围是 [ 7:30 , 8:00 )</li><li>在 8:30 执行 CQ ，数据范围是 [ 8:00 , 8:30 )</li></ul><p>增加了 RESAMPLE FOR 1h 之后，每次 CQ 的时间范围是 1h ，但是因为 GROUP BY time(30m) ，每次 CQ 将会按照 30m 写入两点数据：</p><ul><li>在 8:00 执行 CQ ，数据总范围是 [ 7:00 , 8:00 ) ，实际会拆分成两点 [ 7:00 , 7:30 ) 和 [ 7:30 , 8:00 )</li><li>在 8:30 执行 CQ ，数据总范围是 [ 7:30 , 8:30 ) ，实际会拆分成两点 [ 7:30 , 8:00 ) 和 [ 8:00 , 8:30 )</li></ul><p>当 FOR 的时间间隔大于 GROUP BY time() 时，每次 CQ 的时间范围被扩大，但是每一个点仍然按照 GROUP BY time() 的时间间隔，因此每次 CQ 会写入多个点（如上述示例）。</p><p>当 FOR 与 GROUP BY time() 的时间间隔一致时，无影响。</p><p>当 FOR 的时间间隔小于 GROUP BY time() 时，创建 CQ 时报错，不允许这种情况。</p><h4 id=3every--for>3、EVERY &mldr; FOR
<a class=heading-link href=#3every--for><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h4><p>EVERY 和 FOR 可以一起使用。</p><p>示例：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>CREATE CONTINUOUS QUERY &#34;cq_every_for&#34; ON &#34;db&#34;
</span></span><span style=display:flex><span>RESAMPLE EVERY 1h FOR 90m
</span></span><span style=display:flex><span>BEGIN
</span></span><span style=display:flex><span>  SELECT mean(&#34;field&#34;)
</span></span><span style=display:flex><span>    INTO &#34;result_measurement&#34;
</span></span><span style=display:flex><span>    FROM &#34;source_measurement&#34;
</span></span><span style=display:flex><span>    GROUP BY time(30m)
</span></span><span style=display:flex><span>END
</span></span></code></pre></div><p>EVERY 1h 大于 GROUP BY time(30m)，因此 CQ 每隔 1h 执行一次；FOR 90m ，每次 CQ 执行的时间范围是 90m，按照 30m 拆分成三个点：</p><ul><li>在 8:00 执行 CQ ，数据总范围 [ 6:30 , 8:00 ) ，实际会拆分为三个点 [ 6:30 , 7:00 )、 [ 7:00 , 7:30 )、 [ 7:30 , 8:00 )</li><li>在 9:00 执行 CQ ，数据总范围 [ 7:30 , 9:00 ) ，实际会拆分为三个点 [ 7:30 , 8:00 )、 [ 8:00 , 8:30 )、 [ 8:30 , 9:00 )</li></ul><p>最后，CQ 只能创建和删除，无法修改。</p><hr><p>相关文章：</p><ul><li><a href=/posts/influxdb/1/>时序数据库 InfluxDB（一）</a></li><li><a href=/posts/influxdb/2/>时序数据库 InfluxDB（二）</a></li><li><a href=/posts/influxdb/3/>时序数据库 InfluxDB（三）</a></li><li><a href=/posts/influxdb/4/>时序数据库 InfluxDB（四）</a></li><li><a href=/posts/influxdb/5/>时序数据库 InfluxDB（五）</a></li><li><a href=/posts/influxdb/6/>时序数据库 InfluxDB（六）</a></li><li><a href=/posts/influxdb/7/>时序数据库 InfluxDB（七）</a></li></ul></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2019 -
2023
凌虚
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>