<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>All Posts - 凌虚 Blog</title><link>https://rifewang.github.io/posts/</link><description>All Posts | 凌虚 Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>Attribution-NonCommercial 4.0 International (CC BY-NC 4.0)</copyright><lastBuildDate>Sun, 29 Sep 2024 17:11:31 +0800</lastBuildDate><atom:link href="https://rifewang.github.io/posts/" rel="self" type="application/rss+xml"/><item><title>Kubernetes CSI 简介：工作流程和原理</title><link>https://rifewang.github.io/k8s-csi/</link><pubDate>Sun, 29 Sep 2024 17:11:31 +0800</pubDate><author>凌虚</author><guid>https://rifewang.github.io/k8s-csi/</guid><description><![CDATA[<p>本文将会以 <a href="https://github.com/kubernetes-csi/csi-driver-nfs" target="_blank" rel="noopener noreffer ">CSI driver - NFS</a> 为例，讲述 <code>CSI</code> 驱动的工作流程和原理。</p>
<h2 id="csi-概述">CSI 概述</h2>
<p><code>CSI</code> 驱动通常分为两个部分：</p>
<ul>
<li><code>Controller plugin</code>: 负责存储资源的管理，如卷的创建、删除、扩容、快照等。</li>
<li><code>Node plugin</code>: 处理节点级别的存储操作，负责在具体的节点上执行卷的挂载和卸载等任务。</li>
</ul>
<p></p>]]></description></item><item><title>OCI 简介：Kubernetes 环境下从代码到容器的全流程</title><link>https://rifewang.github.io/oci/</link><pubDate>Thu, 26 Sep 2024 14:30:07 +0800</pubDate><author>凌虚</author><guid>https://rifewang.github.io/oci/</guid><description><![CDATA[<h2 id="oci-简介">OCI 简介</h2>
<p>在容器化技术的演进中，<code>OCI</code>（Open Container Initiative）提供了一套标准化的规范，帮助统一容器的构建、分发和运行。<code>OCI</code> 规范包含三个部分：</p>]]></description></item><item><title>kubectl 执行一条命令之后发生了什么？</title><link>https://rifewang.github.io/kubectl-to-k8s/</link><pubDate>Sun, 22 Sep 2024 14:34:08 +0800</pubDate><author>凌虚</author><guid>https://rifewang.github.io/kubectl-to-k8s/</guid><description><![CDATA[<p><code>kubectl</code> 是与 Kubernetes 集群交互的命令行工具，用户通过它可以对集群资源进行操作和管理。你有没有想过，当我们执行一条 <code>kubectl</code> 命令之后，背后都发生了什么？</p>
<h2 id="详细过程">详细过程</h2>
<h3 id="kubectl---kube-api-server">kubectl -&gt; kube-api-server</h3>
<p>根据通信类型，我把 <code>kubectl</code> 命令分为两类：单向通信和双向通信。</p>]]></description></item><item><title>Kubernetes 集群内 DNS</title><link>https://rifewang.github.io/k8s-dns/</link><pubDate>Tue, 17 Sep 2024 19:50:36 +0800</pubDate><author>凌虚</author><guid>https://rifewang.github.io/k8s-dns/</guid><description><![CDATA[<h2 id="dns-简介">DNS 简介</h2>
<p>在互联网早期，随着连接设备数量的增加，IP 地址的管理与记忆变得越来越复杂。为了简化网络资源的访问，<code>DNS</code>（Domain Name System）应运而生。<code>DNS</code> 的核心作用是将用户可读的域名（如 <a href="https://www.example.com" target="_blank" rel="noopener noreffer ">www.example.com</a>）解析为对应的 IP 地址（如 93.184.215.34），从而使用户无需记忆复杂的数字串，便能轻松访问全球各地的网络资源。</p>]]></description></item><item><title>Kubernetes CNI 网络模型概览：VETH &amp; Bridge / Overlay / BGP</title><link>https://rifewang.github.io/k8s-cni-network-model/</link><pubDate>Fri, 13 Sep 2024 12:11:23 +0800</pubDate><author>凌虚</author><guid>https://rifewang.github.io/k8s-cni-network-model/</guid><description><![CDATA[<h2 id="序言">序言</h2>
<p>网络是容器通信的基础，Kubernetes 本身并未提供开箱即用的网络互通功能，只提出了两点基本要求：</p>
<blockquote>
<ul>
<li>pods can communicate with all other pods on any other node without NAT</li>
<li>agents on a node (e.g. system daemons, kubelet) can communicate with all pods on that node</li>
</ul>
</blockquote>
<p>至于如何实现这些通信能力，通常依赖于 <code>CNI</code> 插件来完成。</p>]]></description></item><item><title>Kubernetes 之 kubelet 与 CRI、CNI 的交互过程</title><link>https://rifewang.github.io/kubelet-cri-cni/</link><pubDate>Sat, 07 Sep 2024 14:46:34 +0800</pubDate><author>凌虚</author><guid>https://rifewang.github.io/kubelet-cri-cni/</guid><description><![CDATA[<h2 id="序言">序言</h2>
<p>当一个新的 Pod 被提交创建之后，<code>Kubelet</code>、<code>CRI</code>、<code>CNI</code> 这三个组件之间进行了哪些交互？</p>
<h2 id="kubelet---cri---cni">Kubelet -&gt; CRI -&gt; CNI</h2>
<p></p>
<p>如上图所示：</p>
<ol>
<li><code>Kubelet</code> 从 kube-api-server 处监听到有新的 pod 被调度到了自己的节点且需要创建。</li>
<li><code>Kubelet</code> 创建 sandbox 并配置好 Pod 的环境，其中包括：
<ul>
<li><code>Kubelet</code> 通过 gRPC 调用 <code>CRI</code> 组件创建 sandbox。</li>
<li><code>CRI</code> 通过命令行调用 <code>CNI</code> 设置 pod 的网络。</li>
</ul>
</li>
<li><code>Kubelet</code> 创建 container 阶段：
<ul>
<li>调用 <code>CRI</code> 拉取镜像。</li>
<li>调用 <code>CRI</code> 创建 container。</li>
<li>调用 <code>CRI</code> 启动 container。</li>
</ul>
</li>
</ol>
<p>注意：</p>]]></description></item><item><title>Kubernetes 网关流量管理：Ingress 与 Gateway API</title><link>https://rifewang.github.io/k8s-ingress-vs-gateway/</link><pubDate>Sat, 31 Aug 2024 17:09:40 +0800</pubDate><author>凌虚</author><guid>https://rifewang.github.io/k8s-ingress-vs-gateway/</guid><description><![CDATA[<h2 id="引言">引言</h2>
<p>随着 Kubernetes 在云原生领域的广泛使用，流量管理成为了至关重要的一环。为了有效地管理从外部流入集群的流量，Kubernetes 提供了多种解决方案，其中最常见的是 <code>Ingress</code> 和新兴的 <code>Gateway API</code>。</p>]]></description></item><item><title>图解计算机网络：一条 HTTP 请求的网络拓扑之旅</title><link>https://rifewang.github.io/http-network-travel/</link><pubDate>Sat, 24 Aug 2024 13:24:29 +0800</pubDate><author>凌虚</author><guid>https://rifewang.github.io/http-network-travel/</guid><description><![CDATA[<h2 id="引言">引言</h2>
<p>常见的网络拓扑结构如下图所示：</p>
<p></p>
<p>在此拓扑中，终端设备通过 WiFi 连接到路由器，路由器再连接到光猫（或终端设备通过移动网络 4G/5G 连接到基站），之后 ISP 网络服务提供商接管网络通信，将请求最终转发至应用服务器。</p>]]></description></item><item><title>DDIA 分布式数据的分区与复制 - 基于 Redis、Kafka、Elasticsearch 的深入分析</title><link>https://rifewang.github.io/ddia-partition-replication-redis-kafka-es/</link><pubDate>Thu, 22 Aug 2024 15:05:53 +0800</pubDate><author>凌虚</author><guid>https://rifewang.github.io/ddia-partition-replication-redis-kafka-es/</guid><description><![CDATA[<h2 id="引言">引言</h2>
<p>本文基于《Designing Data-Intensive Applications》一书（设计数据密集型应用，简称 <code>DDIA</code>），深入探讨了 <code>Redis</code>、<code>Kafka</code> 和 <code>Elasticsearch</code> 等常用组件的分区与复制机制。通过这些案例分析，我们可以更好地理解分布式系统的基本原理和实际应用。</p>]]></description></item><item><title>典型系统架构的百万并发理论分析</title><link>https://rifewang.github.io/million-qps-system/</link><pubDate>Thu, 15 Aug 2024 17:06:40 +0800</pubDate><author>凌虚</author><guid>https://rifewang.github.io/million-qps-system/</guid><description><![CDATA[<h2 id="引言">引言</h2>
<p>本文将会描述一个典型的系统架构，然后分析其在理论上是否能够支撑百万并发的请求。</p>
<h2 id="典型系统架构及分析">典型系统架构及分析</h2>
<p>为了降低复杂性，笔者将系统简化为了下图所示：</p>
<p></p>]]></description></item></channel></rss>