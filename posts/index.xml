<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>All Posts - 凌虚 Blog</title><link>https://rifewang.github.io/posts/</link><description>All Posts | 凌虚 Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>Attribution-NonCommercial 4.0 International (CC BY-NC 4.0)</copyright><lastBuildDate>Tue, 15 Oct 2024 14:22:02 +0800</lastBuildDate><atom:link href="https://rifewang.github.io/posts/" rel="self" type="application/rss+xml"/><item><title>AI LLM 利器 Ollama 架构和对话处理流程解析</title><link>https://rifewang.github.io/ollama/</link><pubDate>Tue, 15 Oct 2024 14:22:02 +0800</pubDate><author>凌虚</author><guid>https://rifewang.github.io/ollama/</guid><description><![CDATA[<h2 id="ollama-概述">Ollama 概述</h2>
<p><code>Ollama</code> 是一个快速运行 <code>LLM</code>（Large Language Models，大语言模型）的简便工具。通过 <code>Ollama</code>，用户无需复杂的环境配置，即可轻松与大语言模型对话互动。</p>]]></description></item><item><title>Kubernetes：Seccomp、AppArmor、SELinux &amp; Pod 安全性标准和准入</title><link>https://rifewang.github.io/k8s-pod-security/</link><pubDate>Fri, 11 Oct 2024 16:46:19 +0800</pubDate><author>凌虚</author><guid>https://rifewang.github.io/k8s-pod-security/</guid><description><![CDATA[<p>在云原生环境中，为确保容器化应用的安全运行，Kubernetes 利用了 Linux 内核的三大安全机制：<code>Seccomp</code>、<code>AppArmor</code> 和 <code>SELinux</code>，并引入了 Pod 安全性标准与准入控制来增强 Pod 的安全性。</p>]]></description></item><item><title>Kubernetes: kube-proxy 和 CNI 是如何协作的？</title><link>https://rifewang.github.io/kube-proxy-cni/</link><pubDate>Mon, 07 Oct 2024 19:06:17 +0800</pubDate><author>凌虚</author><guid>https://rifewang.github.io/kube-proxy-cni/</guid><description><![CDATA[<p>在 Kubernetes 中，<code>kube-proxy</code> 和 <code>CNI</code> 插件协同工作，确保集群内 Pod 之间的互联互通。</p>
<h2 id="kube-proxy--cni">Kube-proxy &amp; CNI</h2>
<p></p>
<p>如上图所示，假设我们有一个类型为 <code>ClusterIP</code> 的 <code>Service</code>，它对应两个位于不同节点的 Pod。</p>]]></description></item><item><title>Kubernetes CSI 简介：工作流程和原理</title><link>https://rifewang.github.io/k8s-csi/</link><pubDate>Sun, 29 Sep 2024 17:11:31 +0800</pubDate><author>凌虚</author><guid>https://rifewang.github.io/k8s-csi/</guid><description><![CDATA[<p>本文将会以 <a href="https://github.com/kubernetes-csi/csi-driver-nfs" target="_blank" rel="noopener noreffer ">CSI driver - NFS</a> 为例，讲述 <code>CSI</code> 驱动的工作流程和原理。</p>
<h2 id="csi-概述">CSI 概述</h2>
<p><code>CSI</code> 驱动通常分为两个部分：</p>
<ul>
<li><code>Controller plugin</code>: 负责存储资源的管理，如卷的创建、删除、扩容、快照等。</li>
<li><code>Node plugin</code>: 处理节点级别的存储操作，负责在具体的节点上执行卷的挂载和卸载等任务。</li>
</ul>
<p></p>]]></description></item><item><title>OCI 简介：Kubernetes 环境下从代码到容器的全流程</title><link>https://rifewang.github.io/oci/</link><pubDate>Thu, 26 Sep 2024 14:30:07 +0800</pubDate><author>凌虚</author><guid>https://rifewang.github.io/oci/</guid><description><![CDATA[<h2 id="oci-简介">OCI 简介</h2>
<p>在容器化技术的演进中，<code>OCI</code>（Open Container Initiative）提供了一套标准化的规范，帮助统一容器的构建、分发和运行。<code>OCI</code> 规范包含三个部分：</p>]]></description></item><item><title>kubectl 执行一条命令之后发生了什么？</title><link>https://rifewang.github.io/kubectl-to-k8s/</link><pubDate>Sun, 22 Sep 2024 14:34:08 +0800</pubDate><author>凌虚</author><guid>https://rifewang.github.io/kubectl-to-k8s/</guid><description><![CDATA[<p><code>kubectl</code> 是与 Kubernetes 集群交互的命令行工具，用户通过它可以对集群资源进行操作和管理。你有没有想过，当我们执行一条 <code>kubectl</code> 命令之后，背后都发生了什么？</p>
<h2 id="详细过程">详细过程</h2>
<h3 id="kubectl---kube-api-server">kubectl -&gt; kube-api-server</h3>
<p>根据通信类型，我把 <code>kubectl</code> 命令分为两类：单向通信和双向通信。</p>]]></description></item><item><title>Kubernetes 集群内 DNS</title><link>https://rifewang.github.io/k8s-dns/</link><pubDate>Tue, 17 Sep 2024 19:50:36 +0800</pubDate><author>凌虚</author><guid>https://rifewang.github.io/k8s-dns/</guid><description><![CDATA[<h2 id="dns-简介">DNS 简介</h2>
<p>在互联网早期，随着连接设备数量的增加，IP 地址的管理与记忆变得越来越复杂。为了简化网络资源的访问，<code>DNS</code>（Domain Name System）应运而生。<code>DNS</code> 的核心作用是将用户可读的域名（如 <a href="https://www.example.com" target="_blank" rel="noopener noreffer ">www.example.com</a>）解析为对应的 IP 地址（如 93.184.215.34），从而使用户无需记忆复杂的数字串，便能轻松访问全球各地的网络资源。</p>]]></description></item><item><title>Kubernetes CNI 网络模型概览：VETH &amp; Bridge / Overlay / BGP</title><link>https://rifewang.github.io/k8s-cni-network-model/</link><pubDate>Fri, 13 Sep 2024 12:11:23 +0800</pubDate><author>凌虚</author><guid>https://rifewang.github.io/k8s-cni-network-model/</guid><description><![CDATA[<h2 id="序言">序言</h2>
<p>网络是容器通信的基础，Kubernetes 本身并未提供开箱即用的网络互通功能，只提出了两点基本要求：</p>
<blockquote>
<ul>
<li>pods can communicate with all other pods on any other node without NAT</li>
<li>agents on a node (e.g. system daemons, kubelet) can communicate with all pods on that node</li>
</ul>
</blockquote>
<p>至于如何实现这些通信能力，通常依赖于 <code>CNI</code> 插件来完成。</p>]]></description></item><item><title>Kubernetes 之 kubelet 与 CRI、CNI 的交互过程</title><link>https://rifewang.github.io/kubelet-cri-cni/</link><pubDate>Sat, 07 Sep 2024 14:46:34 +0800</pubDate><author>凌虚</author><guid>https://rifewang.github.io/kubelet-cri-cni/</guid><description><![CDATA[<h2 id="序言">序言</h2>
<p>当一个新的 Pod 被提交创建之后，<code>Kubelet</code>、<code>CRI</code>、<code>CNI</code> 这三个组件之间进行了哪些交互？</p>
<h2 id="kubelet---cri---cni">Kubelet -&gt; CRI -&gt; CNI</h2>
<p></p>
<p>如上图所示：</p>
<ol>
<li><code>Kubelet</code> 从 kube-api-server 处监听到有新的 pod 被调度到了自己的节点且需要创建。</li>
<li><code>Kubelet</code> 创建 sandbox 并配置好 Pod 的环境，其中包括：
<ul>
<li><code>Kubelet</code> 通过 gRPC 调用 <code>CRI</code> 组件创建 sandbox。</li>
<li><code>CRI</code> 通过命令行调用 <code>CNI</code> 设置 pod 的网络。</li>
</ul>
</li>
<li><code>Kubelet</code> 创建 container 阶段：
<ul>
<li>调用 <code>CRI</code> 拉取镜像。</li>
<li>调用 <code>CRI</code> 创建 container。</li>
<li>调用 <code>CRI</code> 启动 container。</li>
</ul>
</li>
</ol>
<p>注意：</p>]]></description></item><item><title>Kubernetes 网关流量管理：Ingress 与 Gateway API</title><link>https://rifewang.github.io/k8s-ingress-vs-gateway/</link><pubDate>Sat, 31 Aug 2024 17:09:40 +0800</pubDate><author>凌虚</author><guid>https://rifewang.github.io/k8s-ingress-vs-gateway/</guid><description><![CDATA[<h2 id="引言">引言</h2>
<p>随着 Kubernetes 在云原生领域的广泛使用，流量管理成为了至关重要的一环。为了有效地管理从外部流入集群的流量，Kubernetes 提供了多种解决方案，其中最常见的是 <code>Ingress</code> 和新兴的 <code>Gateway API</code>。</p>]]></description></item></channel></rss>