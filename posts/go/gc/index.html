<!doctype html><html lang=en><head><title>Go 垃圾回收 · 凌虚 Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="凌虚"><meta name=description content="Go 垃圾回收"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go 垃圾回收"><meta name=twitter:description content="Go 垃圾回收"><meta property="og:title" content="Go 垃圾回收"><meta property="og:description" content="Go 垃圾回收"><meta property="og:type" content="article"><meta property="og:url" content="https://rifewang.github.io/posts/go/gc/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-09-25T00:56:24+08:00"><meta property="article:modified_time" content="2019-09-25T00:56:24+08:00"><link rel=canonical href=https://rifewang.github.io/posts/go/gc/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.0fa2dc75ed1b76894ac0e062b10a6c4730daa745096fa120114b290ed8a48788.css integrity="sha256-D6Lcde0bdolKwOBisQpsRzDap0UJb6EgEUspDtikh4g=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.593028e7f7ac55c003b79c230d1cd411bb4ca53b31556c3abb7f027170e646e9.css integrity="sha256-WTAo5/esVcADt5wjDRzUEbtMpTsxVWw6u38CcXDmRuk=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.110.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>凌虚 Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>博客</a></li><li class=navigation-item><a class=navigation-link href=/translation/>译文</a></li><li class=navigation-item><a class=navigation-link href=/about/>关于</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://rifewang.github.io/posts/go/gc/>Go 垃圾回收</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2019-09-25T00:56:24+08:00>September 25, 2019</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
One-minute read</span></div><div class=categories><i class="fa fa-folder" aria-hidden=true></i>
<a href=/categories/golang/>Golang</a></div></div></header><div class=post-content><p>Garbage Collection（ GC ）也就是垃圾回收到底是什么？内存空间是有限的，诸如变量等需要分配内存才能存储数据，而当这个变量不再使用的时候就需要释放它占用的内存，这就是垃圾回收。</p><p>Go 的垃圾回收运行在后台的守护线程中，会自动追踪检查对象的使用情况，然后回收不再使用的空间，我们一般并不会也不需要直接接触到它。</p><h2 id=gc-模型>GC 模型
<a class=heading-link href=#gc-%e6%a8%a1%e5%9e%8b><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Go 使用的是 Mark-Sweep（标记-清除）方式，其具体的垃圾回收算法一直都在调整优化，本文并不打算去介绍这些算法，而是从一个整体的角度去描述 GC 的过程。</p><p>Collection 可以分为三个阶段：</p><ul><li>Mark Setup - STW</li><li>Marking - Concurrent</li><li>Mark Termination - STW</li></ul><p>STW 是 Stop The World 的缩写，意思是 GC 的时候会暂停其它所有任务，正是如此才导致了延迟的存在。</p><h3 id=1mark-setup---stw>1、Mark Setup - STW
<a class=heading-link href=#1mark-setup---stw><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>垃圾回收开始，首先需要开启 Write Barrier（写屏障），为此所有应用程序 goroutine 必须暂停，这个过程通常很快，平均 10 - 30 微秒。</p><p>假设应用程序当前运行了四个 goroutine :</p><p><img src=/images/go/gc1.png alt></p><p>我们需要等待所有 goroutine 暂停，而暂停操作是需要出现一次函数调用才能完成，如果某个 goroutine 始终没有发生函数调用（比如一直在执行某个非常长的循环操作）而其它 goroutine 却完成了会怎样，就会如下图：</p><p><img src=/images/go/gc2.png alt></p><p>然而，必须所有的 goroutine 全部都暂停，垃圾回收才能继续进行，不然就会卡在这里一直等待，结果就是延迟越来越高。这个问题官方团队计划将在 1.14 版本通过优先策略进行优化。</p><p>一旦这一阶段完成，Write Barrier（写屏障）开启，就会进入下一阶段。</p><h3 id=2marking---concurrent>2、Marking - Concurrent
<a class=heading-link href=#2marking---concurrent><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>进行标记，Concurrent 表示这个过程是并发进行的，不会 STW ，GC 会先征用 25% 的 CPU 资源，如下图：</p><p><img src=/images/go/gc3.png alt></p><p>GC 占用了 P1 逻辑处理器，而其它 goroutine 正常的并发运行。</p><p>但是，有些时候 GC 的任务特别繁重，需要更多的资源，这个时候怎么办？开启 Mark Assit 协助工作，如下图中的 MA ：</p><p><img src=/images/go/gc4.png alt></p><p>标记完成，进行下一个阶段。</p><h3 id=3mark-termination---stw>3、Mark Termination - STW
<a class=heading-link href=#3mark-termination---stw><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>标记终止。关闭 Write Barrier（写屏障），执行各种清理任务，然后计算下一次 GC 的目标，这个阶段也是需要 STW 的，平均 60 - 90 微秒：</p><p><img src=/images/go/gc5.png alt></p><p>一旦 GC 完成，goroutine 继续执行：</p><p><img src=/images/go/gc6.png alt></p><h3 id=sweeping---concurrent>Sweeping - Concurrent
<a class=heading-link href=#sweeping---concurrent><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>Sweeping（清除）需要等待 collection 完成之后，回收被标记为未使用的值的内存，这个过程发生在应用程序 goroutine 尝试给新值分配内存空间时，Sweeping 的延迟将会增加内存分配的成本。</p><hr><h2 id=延迟优化>延迟优化
<a class=heading-link href=#%e5%bb%b6%e8%bf%9f%e4%bc%98%e5%8c%96><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>虽然 Go 的 GC 很优秀，但正如前文所述，GC 的延迟还是会拖累应用程序的，那么我们在应用程序中可以进行怎么的优化呢？
答案是降低内存的压力即分配内存的频率，比如使用 slice 时，尽量避免因为容量不够了而导致分配更多的内存的频率。</p><p>如何调试我们的程序去发现需要优化的地方？</p><p>1、开启 gotrace 追踪各种指标：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>GODEBUG=gctrace=1
</span></span></code></pre></div><p>通过指标数据可以看到各个过程及耗时情况，比如：</p><p><img src=/images/go/gc7.jpeg alt></p><p>2、使用 pprof</p><p>具体用法请自行参考其它资料。</p><hr><p><em>参考：</em></p><p><em><a href=https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html>https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html</a></em>
<em><a href=https://www.ardanlabs.com/blog/2019/05/garbage-collection-in-go-part2-gctraces.html>https://www.ardanlabs.com/blog/2019/05/garbage-collection-in-go-part2-gctraces.html</a></em>
<em><a href=https://www.ardanlabs.com/blog/2019/07/garbage-collection-in-go-part3-gcpacing.html>https://www.ardanlabs.com/blog/2019/07/garbage-collection-in-go-part3-gcpacing.html</a></em></p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2019 -
2023
凌虚
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>