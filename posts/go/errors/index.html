<!doctype html><html lang=en><head><title>Go Errors 错误处理 · 凌虚 Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="凌虚"><meta name=description content="Go Errors 错误处理"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go Errors 错误处理"><meta name=twitter:description content="Go Errors 错误处理"><meta property="og:title" content="Go Errors 错误处理"><meta property="og:description" content="Go Errors 错误处理"><meta property="og:type" content="article"><meta property="og:url" content="https://rifewang.github.io/posts/go/errors/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-10-18T16:41:26+08:00"><meta property="article:modified_time" content="2019-10-18T16:41:26+08:00"><link rel=canonical href=https://rifewang.github.io/posts/go/errors/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.0fa2dc75ed1b76894ac0e062b10a6c4730daa745096fa120114b290ed8a48788.css integrity="sha256-D6Lcde0bdolKwOBisQpsRzDap0UJb6EgEUspDtikh4g=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.593028e7f7ac55c003b79c230d1cd411bb4ca53b31556c3abb7f027170e646e9.css integrity="sha256-WTAo5/esVcADt5wjDRzUEbtMpTsxVWw6u38CcXDmRuk=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.110.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>凌虚 Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>博客</a></li><li class=navigation-item><a class=navigation-link href=/translation/>译文</a></li><li class=navigation-item><a class=navigation-link href=/about/>关于</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://rifewang.github.io/posts/go/errors/>Go Errors 错误处理</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2019-10-18T16:41:26+08:00>October 18, 2019</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
2-minute read</span></div><div class=categories><i class="fa fa-folder" aria-hidden=true></i>
<a href=/categories/golang/>Golang</a></div></div></header><div class=post-content><p>Golang 中的 error 是一个内置的特殊的接口类型：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>type</span> <span>error</span> <span style=font-weight:700>interface</span> {
</span></span><span style=display:flex><span>    Error()  <span>string</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在 Go 1.13 版本之前，有关 error 的方法只有两个：</p><ul><li><code>errors.New</code> :</li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>func</span> New(text <span>string</span>) <span>error</span>
</span></span></code></pre></div><ul><li><code>fmt.Errorf</code> :</li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>func</span> Errorf(format <span>string</span>, a ...<span style=font-weight:700>interface</span>{}) <span>error</span>
</span></span></code></pre></div><p>这两个方法都是用来生成一个新的 error 类型的数据。</p><hr><h2 id=113-版本之前的错误处理>1.13 版本之前的错误处理
<a class=heading-link href=#113-%e7%89%88%e6%9c%ac%e4%b9%8b%e5%89%8d%e7%9a%84%e9%94%99%e8%af%af%e5%a4%84%e7%90%86><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>最常见的，判断是否为 nil ：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>if</span> err != <span style=font-weight:700>nil</span> {
</span></span><span style=display:flex><span>    <span style=font-style:italic>// something went wrong
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>}
</span></span></code></pre></div><p>判断是否为某个特定的错误：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>var</span> ErrNotFound = errors.New(<span style=font-style:italic>&#34;not found&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>if</span> err == ErrNotFound {
</span></span><span style=display:flex><span>    <span style=font-style:italic>// something wasn&#39;t found
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>}
</span></span></code></pre></div><p>error 是一个带有 Error 方法的接口类型，这意味着你可以自己去实现这个接口：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>type</span> NotFoundError <span style=font-weight:700>struct</span> {
</span></span><span style=display:flex><span>    Name <span>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>func</span> (e *NotFoundError) Error() <span>string</span> {
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> e.Name + <span style=font-style:italic>&#34;: not found&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=font-weight:700>if</span> e, ok := err.(*NotFoundError); ok {
</span></span><span style=display:flex><span>    <span style=font-style:italic>// e.Name wasn&#39;t found
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>}
</span></span></code></pre></div><p>处理错误的时候我们通常会添加一些额外的信息，记录错误的上下文以便于后续排查：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>if</span> err != <span style=font-weight:700>nil</span> {
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> fmt.Errorf(<span style=font-style:italic>&#34;错误上下文 %v: %v&#34;</span>, name, err)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>fmt.Errorf</code> 方法会创建一个包含有原始错误文本信息的新的 error ，但是与原始错误之间是没有任何关联的。</p><p>然而我们有时候是需要保留这种关联性的，这时候就需要我们自己去定义一个包含有原始错误的新的错误类型，比如自定义一个 QueryError ：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>type</span> QueryError <span style=font-weight:700>struct</span> {
</span></span><span style=display:flex><span>    Query <span>string</span>
</span></span><span style=display:flex><span>    Err   <span>error</span>  <span style=font-style:italic>// 与原始错误关联
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>}
</span></span></code></pre></div><p>然后可以判断这个原始错误是否为某个特定的错误，比如 ErrPermission ：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>if</span> e, ok := err.(*QueryError); ok &amp;&amp; e.Err == ErrPermission {
</span></span><span style=display:flex><span>    <span style=font-style:italic>// query failed because of a permission problem
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>}
</span></span></code></pre></div><p>写到这里，你可以发现对于错误的关联嵌套情况处理起来是比较麻烦的，而 Go 1.13 版本对此做了改进。</p><hr><h2 id=113-版本之后的错误处理>1.13 版本之后的错误处理
<a class=heading-link href=#113-%e7%89%88%e6%9c%ac%e4%b9%8b%e5%90%8e%e7%9a%84%e9%94%99%e8%af%af%e5%a4%84%e7%90%86><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>首先需要说明的是，Go 是向下兼容的，上文中的 1.13 版本之前的用法完全可以继续使用。</p><p>1.13 版本的改进是：</p><ul><li>新增方法 <code>errors.Unwrap</code> :</li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>func</span> Unwrap(err <span>error</span>) <span>error</span>
</span></span></code></pre></div><ul><li>新增方法 <code>errors.Is</code> :</li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>func</span> Is(err, target <span>error</span>) <span>bool</span>
</span></span></code></pre></div><ul><li>新增方法 <code>errors.As</code> :</li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>func</span> As(err <span>error</span>, target <span style=font-weight:700>interface</span>{}) <span>bool</span>
</span></span></code></pre></div><ul><li><code>fmt.Errorf</code> 方法新增了 <code>%w</code> 格式化动词，返回的 error 自动实现了 <code>Unwrap</code> 方法。</li></ul><p>下面进行详细说明。</p><p>对于错误嵌套的情况，<code>Unwrap</code> 方法可以用来返回某个错误所包含的底层错误，例如 e1 包含了 e2 ，这里 Unwrap e1 就可以得到 e2 。Unwrap 支持链式调用（处理错误的多层嵌套）。</p><p>使用 errors.Is 和 errors.As 方法检查错误：</p><ul><li><code>errors.Is</code> 方法检查值：</li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>if</span> errors.Is(err, ErrNotFound) {
</span></span><span style=display:flex><span>    <span style=font-style:italic>// something wasn&#39;t found
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>}
</span></span></code></pre></div><ul><li><code>errors.As</code> 方法检查特定错误类型：</li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>var</span> e *QueryError
</span></span><span style=display:flex><span><span style=font-weight:700>if</span> errors.As(err, &amp;e) {
</span></span><span style=display:flex><span>    <span style=font-style:italic>// err is a *QueryError, and e is set to the error&#39;s value
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>}
</span></span></code></pre></div><p><code>errors.Is</code> 方法会对嵌套的情况展开判断，这意味着：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>if</span> e, ok := err.(*QueryError); ok &amp;&amp; e.Err == ErrPermission {
</span></span><span style=display:flex><span>    <span style=font-style:italic>// query failed because of a permission problem
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>}
</span></span></code></pre></div><p>可以直接简写为：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>if</span> errors.Is(err, ErrPermission) {
</span></span><span style=display:flex><span>    <span style=font-style:italic>// err, or some error that it wraps, is a permission problem
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>}
</span></span></code></pre></div><p><code>fmt.Errorf</code> 方法通过 <code>%w</code> 包装错误：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>if</span> err != <span style=font-weight:700>nil</span> {
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> fmt.Errorf(<span style=font-style:italic>&#34;错误上下文 %v: %v&#34;</span>, name, err)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面通过 <code>%v</code> 是直接返回一个与原始错误无法关联的新的错误。
我们使用 <code>%w</code> 就可以进行关联了：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>if</span> err != <span style=font-weight:700>nil</span> {
</span></span><span style=display:flex><span>    <span style=font-style:italic>// Return an error which unwraps to err.
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>    <span style=font-weight:700>return</span> fmt.Errorf(<span style=font-style:italic>&#34;错误上下文 %v: %w&#34;</span>, name, err)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>一旦使用 <code>%w</code> 进行了关联，就可以使用 <code>errors.Is</code> 和 <code>errors.As</code> 方法了：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>err := fmt.Errorf(<span>&#34;</span>access denied: %w<span>”</span>, ErrPermission)
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=font-weight:700>if</span> errors.Is(err, ErrPermission) ...
</span></span></code></pre></div><p>对于是否包装错误以及如何包装错误并没有统一的答案。</p><hr><p><em>本文参考资料:
<a href=https://blog.golang.org/go1.13-errors>https://blog.golang.org/go1.13-errors</a></em></p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2019 -
2023
凌虚
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>