<!doctype html><html lang=en><head><title>又拍图片管家亿级图像之搜图系统的两代演进及底层原理 · 凌虚 Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="凌虚"><meta name=description content="又拍图片管家亿级图像之搜图系统的两代演进及底层原理"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="又拍图片管家亿级图像之搜图系统的两代演进及底层原理"><meta name=twitter:description content="又拍图片管家亿级图像之搜图系统的两代演进及底层原理"><meta property="og:title" content="又拍图片管家亿级图像之搜图系统的两代演进及底层原理"><meta property="og:description" content="又拍图片管家亿级图像之搜图系统的两代演进及底层原理"><meta property="og:type" content="article"><meta property="og:url" content="https://rifewang.github.io/posts/engineering/image-search-total/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-06-04T00:00:00+08:00"><meta property="article:modified_time" content="2020-06-04T00:00:00+08:00"><link rel=canonical href=https://rifewang.github.io/posts/engineering/image-search-total/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.0fa2dc75ed1b76894ac0e062b10a6c4730daa745096fa120114b290ed8a48788.css integrity="sha256-D6Lcde0bdolKwOBisQpsRzDap0UJb6EgEUspDtikh4g=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.593028e7f7ac55c003b79c230d1cd411bb4ca53b31556c3abb7f027170e646e9.css integrity="sha256-WTAo5/esVcADt5wjDRzUEbtMpTsxVWw6u38CcXDmRuk=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.110.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>凌虚 Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>博客</a></li><li class=navigation-item><a class=navigation-link href=/translation/>译文</a></li><li class=navigation-item><a class=navigation-link href=/about/>关于</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://rifewang.github.io/posts/engineering/image-search-total/>又拍图片管家亿级图像之搜图系统的两代演进及底层原理</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2020-06-04T00:00:00+08:00>June 4, 2020</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
2-minute read</span></div><div class=categories><i class="fa fa-folder" aria-hidden=true></i>
<a href=/categories/engineering/>Engineering</a></div></div></header><div class=post-content><h1 id=又拍图片管家亿级图像之搜图系统的两代演进及底层原理>又拍图片管家亿级图像之搜图系统的两代演进及底层原理
<a class=heading-link href=#%e5%8f%88%e6%8b%8d%e5%9b%be%e7%89%87%e7%ae%a1%e5%ae%b6%e4%ba%bf%e7%ba%a7%e5%9b%be%e5%83%8f%e4%b9%8b%e6%90%9c%e5%9b%be%e7%b3%bb%e7%bb%9f%e7%9a%84%e4%b8%a4%e4%bb%a3%e6%bc%94%e8%bf%9b%e5%8f%8a%e5%ba%95%e5%b1%82%e5%8e%9f%e7%90%86><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><h2 id=前言>前言
<a class=heading-link href=#%e5%89%8d%e8%a8%80><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>又拍图片管家当前服务了千万级用户，管理了百亿级图片。当用户的图库变得越来越庞大时，业务上急切的需要一种方案能够快速定位图像，即直接输入图像，然后根据输入的图像内容来找到图库中的原图及相似图，而以图搜图服务就是为了解决这个问题。</p><p>本人于在职期间独立负责并实施了整个以图搜图系统从技术调研、到设计验证、以及最后工程实现的全过程。而整个以图搜图服务也是经历了两次的整体演进：从 2019 年初开始第一次技术调研，经历春节假期，2019 年 3、4 月份第一代系统整体上线；2020 年初着手升级方案调研，经历春节及疫情，2020 年 4 月份开始第二代系统的整体升级。</p><p>本文将会简述两代搜图系统背后的技术选型及基本原理。</p><hr><h2 id=基础概要>基础概要
<a class=heading-link href=#%e5%9f%ba%e7%a1%80%e6%a6%82%e8%a6%81><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><h3 id=图像是什么>图像是什么？
<a class=heading-link href=#%e5%9b%be%e5%83%8f%e6%98%af%e4%bb%80%e4%b9%88><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>与图像打交道，我们必须要先知道：图像是什么？</p><p>答案：像素点的集合。</p><p>比如：</p><p><img src=/images/pixel-example.png alt=image-pixel-example></p><p>左图红色圈中的部分其实就是右图中一系列的像素点。</p><p>再举例：</p><p><img src=/images/pixel2.png alt=image-pixel2></p><p>假设上图红色圈的部分是一幅图像，其中每一个独立的小方格就是一个像素点（简称像素），像素是最基本的信息单元，而这幅图像的大小就是 11 x 11 px 。</p><h3 id=图像的数学表示>图像的数学表示
<a class=heading-link href=#%e5%9b%be%e5%83%8f%e7%9a%84%e6%95%b0%e5%ad%a6%e8%a1%a8%e7%a4%ba><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>每个图像都可以很自然的用矩阵来表示，每个像素点对应的就是矩阵中的一个元素。</p><h4 id=二值图像>二值图像
<a class=heading-link href=#%e4%ba%8c%e5%80%bc%e5%9b%be%e5%83%8f><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h4><p>二值图像的像素点只有黑白两种情况，因此每个像素点可以由 0 和 1 来表示。</p><p>比如一张 4 * 4 二值图像：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>0 1 0 1
</span></span><span style=display:flex><span>1 0 0 0
</span></span><span style=display:flex><span>1 1 1 0
</span></span><span style=display:flex><span>0 0 1 0
</span></span></code></pre></div><h4 id=rgb-图像>RGB 图像
<a class=heading-link href=#rgb-%e5%9b%be%e5%83%8f><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h4><p>红（Red）、绿（Green）、蓝（Blue）作为三原色可以调和成任意的颜色，对于 RGB 图像，每个像素点包含 RGB 共三个通道的基本信息，类似的，如果每个通道用 8 bit 表示即 256 级灰度，那么一个像素点可以表示为：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>( [0 ... 255], [0 ... 255], [0 ... 255] )
</span></span></code></pre></div><p>比如一张 4 * 4 RGB 图像：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>(156, 22, 45)  (255, 0, 0)  (0, 156, 32)  (14, 2, 90)
</span></span><span style=display:flex><span>(12, 251, 88)  (78, 12, 3)  (94, 90, 87)  (134, 0, 2)
</span></span><span style=display:flex><span>(240, 33, 44)  (5, 66, 77)  (1, 28, 167)  (11, 11, 11)
</span></span><span style=display:flex><span>(0, 0, 0)      (4, 4, 4)    (50, 50, 50)  (100, 10, 10)
</span></span></code></pre></div><p>图像处理的本质实际上就是对这些像素矩阵进行计算。</p><h3 id=搜图的技术问题>搜图的技术问题
<a class=heading-link href=#%e6%90%9c%e5%9b%be%e7%9a%84%e6%8a%80%e6%9c%af%e9%97%ae%e9%a2%98><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>如果只是找原图，也就是像素点完全相同的图像，那么直接对比它们的 <code>MD5</code> 值即可。然而，图像在网络的传输过程中，常常会遇到诸如压缩、水印等等情况，而 <code>MD5</code> 算法的特点是，即使是小部分内容变动，其最终的结果却是天差地别，换句话说只要图片有一个像素点不一致，最后都是无法对比的。</p><p>对于一个以图搜图系统而言，我们要搜的本质上其实是内容相似的图片，为此，我们需要解决两个基本的问题：</p><ul><li>把图像表示或抽象为一个计算机数据</li><li>这个数据必须是可以进行对比计算的</li></ul><p>直接用专业点的话说就是：</p><ul><li>图像的特征提取</li><li>特征计算（相似性计算）</li></ul><hr><h2 id=第一代搜图系统>第一代搜图系统
<a class=heading-link href=#%e7%ac%ac%e4%b8%80%e4%bb%a3%e6%90%9c%e5%9b%be%e7%b3%bb%e7%bb%9f><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><h3 id=特性提取---图像抽象>特性提取 - 图像抽象
<a class=heading-link href=#%e7%89%b9%e6%80%a7%e6%8f%90%e5%8f%96---%e5%9b%be%e5%83%8f%e6%8a%bd%e8%b1%a1><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>第一代搜图系统在特征提取上使用的是 <code>Perceptual hash</code> 即 <code>pHash</code> 算法，这个算法的基本原理是什么？</p><p><img src=/images/phash.png alt=pHash></p><p>如上图所示，<code>pHash</code> 算法就是对图像整体进行一系列变换最后构造 hash 值，而变换的过程可以理解为对图像进行不断的抽象，此时如果对另外一张相似内容的图像进行同样的整体抽象，那么其结果一定是非常接近的。</p><h3 id=特性计算---相似性计算>特性计算 - 相似性计算
<a class=heading-link href=#%e7%89%b9%e6%80%a7%e8%ae%a1%e7%ae%97---%e7%9b%b8%e4%bc%bc%e6%80%a7%e8%ae%a1%e7%ae%97><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>对于两张图像的 <code>pHash</code> 值，具体如何计算其相似的程度？答案是 <code>Hamming distance</code> 汉明距离，汉明距离越小，图像内容越相似。</p><p>汉明距离又是什么？就是对应位置不同比特位的个数。</p><p>例如：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>第一个值： 0 1 0 1 0
</span></span><span style=display:flex><span>第二个值： 0 0 0 1 1
</span></span></code></pre></div><p>以上两个值的对应位置上有 2 个比特位是不相同的，因此它们的汉明距离就是 2 。</p><p>OK ，相似性计算的原理我们知道了，那么下一个问题是：如何去计算亿级图片对应的亿级数据的汉明距离？简而言之，就是如何搜索？</p><p>在项目早期其实我并没有找到一个满意的能够快速计算汉明距离的工具（或者说是计算引擎），因此我的方案进行了一次变通。</p><p>变通的思想是：如果两个 pHash 值的汉明距离是接近的，那么将 pHash 值进行切割后，切割后的每一个小部分大概率相等。</p><p>例如：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>第一个值： 8 a 0 3 0 3 f 6
</span></span><span style=display:flex><span>第二个值： 8 a 0 3 0 3 d 8
</span></span></code></pre></div><p>我们把上面这两个值分割成了 8 块，其中 6 块的值是完全相同的，因此可以推断它们的汉明距离接近，从而图像内容也相似。</p><p>经过变换之后，其实你可以发现，汉明距离的计算问题，变成了等值匹配的问题，我把每一个 pHash 值给分成了 8 段，只要里面有超过 5 段的值是完全相同的，那么我就认为他们相似。</p><p>等值匹配如何解决？这就很简单了，传统数据库的条件过滤不就可以用了嘛。</p><p>当然，我这里用的是 <code>ElasticSearch</code>（ <code>ES</code> 的原理本文就不介绍了，读者可以另行了解），在 <code>ES</code> 里的具体操作就是多 <code>term</code> 匹配然后 <code>minimum_should_match</code> 指定匹配程度。</p><p>为什么搜索会选择 <code>ElasticSearch</code> ？第一点，它能实现上述的搜索功能；第二点，图片管家项目本身就正在用 <code>ES</code> 提供全文搜索的功能，使用现有资源，成本是非常低的。</p><h3 id=第一代系统总结>第一代系统总结
<a class=heading-link href=#%e7%ac%ac%e4%b8%80%e4%bb%a3%e7%b3%bb%e7%bb%9f%e6%80%bb%e7%bb%93><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>第一代搜图系统在技术上选择了 <code>pHash</code> + <code>ElasticSearch</code> 的方案，它拥有如下特点：</p><ul><li><code>pHash</code> 算法计算简单，可以对抗一定程度的压缩、水印、噪声等影响。</li><li><code>ElasticSearch</code> 直接使用了项目现有资源，在搜索上没有增加额外的成本。</li></ul><p>当然这套系统的局限性也很明显：由于 <code>pHash</code> 算法是对图像的整体进行抽象表示，一旦我们对整体性进行了破坏，比如在原图加一个黑边，就会几乎无法判断相似性。</p><p>为了突破这个局限性，底层技术截然不同的第二代搜图系统应运而生。</p><hr><h2 id=第二代搜图系统>第二代搜图系统
<a class=heading-link href=#%e7%ac%ac%e4%ba%8c%e4%bb%a3%e6%90%9c%e5%9b%be%e7%b3%bb%e7%bb%9f><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><h3 id=特性提取>特性提取
<a class=heading-link href=#%e7%89%b9%e6%80%a7%e6%8f%90%e5%8f%96><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>在计算机视觉领域，使用人工智能相关的技术基本上已经成了主流，同样，我们第二代搜图系统的特征提取在底层技术上使用的是 <code>CNN</code> 卷积神经网络。</p><p><code>CNN</code> 卷积神经网络这个词让人比较难以理解，重点是回答两个问题：</p><ul><li><code>CNN</code> 能干什么？</li><li>搜图为什么能用 <code>CNN</code> ?</li></ul><p>AI 领域有很多赛事，图像分类是其中一项重要的比赛内容，而图像分类就是要去判断图片的内容到底是猫、是狗、是苹果、是梨子、还是其它对象类别。</p><p><code>CNN</code> 能干什么？提取特征，进而识物，我把这个过程简单的理解为，从多个不同的维度去提取特征，衡量一张图片的内容或者特征与猫的特征有多接近，与狗的特征有多接近，等等等等，选择最接近的就可以作为我们的识别结果，也就是判断这张图片的内容是猫，还是狗，还是其它。</p><p><code>CNN</code> 识物又跟我们找相似的图像有什么关系？我们要的不是最终的识物结果，而是从多个维度提取出来的特征向量，两张内容相似的图像的特征向量一定是接近的。</p><p>具体使用哪种 <code>CNN</code> 模型？</p><p>我使用的是 <code>VGG16</code> ，为什么选择它？首先，<code>VGG16</code> 拥有很好的泛化能力，也就是很通用；其次，<code>VGG16</code> 提取出来的特征向量是 <code>512</code> 维，维度适中，如果维度太少，精度可能会受影响，如果维度太多，存储和计算这些特征向量的成本会比较高。</p><h3 id=向量搜索引擎>向量搜索引擎
<a class=heading-link href=#%e5%90%91%e9%87%8f%e6%90%9c%e7%b4%a2%e5%bc%95%e6%93%8e><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>从图像提取特征向量的问题已经解决了，那么剩下的问题就是：</p><ul><li>特征向量如何存储？</li><li>特征向量如何计算相似性，即如何搜索？</li></ul><p>对于这两个问题，直接使用开源的向量搜索引擎 <a href=https://www.milvus.io/>Milvus</a> 就可以很好的解决，截至目前，<a href=https://www.milvus.io/>Milvus</a> 在我们的生产环境一直运行良好。</p><h3 id=第二代系统总结>第二代系统总结
<a class=heading-link href=#%e7%ac%ac%e4%ba%8c%e4%bb%a3%e7%b3%bb%e7%bb%9f%e6%80%bb%e7%bb%93><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>第二代搜图系统在技术上选择了 <code>CNN</code> + <code>Milvus</code> 的方案，而这种基于特征向量的搜索在业务上也提供了更好的支持。</p><hr><h2 id=相关文章>相关文章
<a class=heading-link href=#%e7%9b%b8%e5%85%b3%e6%96%87%e7%ab%a0><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>本人之前已经写过两篇相关的文章：</p><ul><li><a href=/posts/engineering/image-search-system/>以图搜图系统概述</a></li><li><a href=/posts/engineering/image-search-system2/>以图搜图系统工程实践</a></li></ul><p>英文版：</p><ul><li><a href=https://medium.com/unstructured-data-service/the-journey-to-optimize-billion-scale-image-search-part-1-a270c519246d>The Journey to Optimizing Billion-scale Image Similarity Search (1/2)</a></li><li><a href=https://medium.com/unstructured-data-service/the-journey-to-optimizing-billion-scale-image-search-2-2-572a36d5d0d>The Journey to Optimizing Billion-scale Image Similarity Search (2/2)</a></li></ul></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2019 -
2023
凌虚
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>