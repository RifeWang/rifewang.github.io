<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Uncate - Category - 凌虚 Blog</title><link>https://rifewang.github.io/categories/uncate/</link><description>Uncate - Category - 凌虚 Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>Attribution-NonCommercial 4.0 International (CC BY-NC 4.0)</copyright><lastBuildDate>Fri, 07 Apr 2023 11:27:16 +0800</lastBuildDate><atom:link href="https://rifewang.github.io/categories/uncate/" rel="self" type="application/rss+xml"/><item><title>什么？修改 JSON 内容居然还有个 JSON PATCH 标准</title><link>https://rifewang.github.io/rfc6902-json-patch/</link><pubDate>Fri, 07 Apr 2023 11:27:16 +0800</pubDate><author>凌虚</author><guid>https://rifewang.github.io/rfc6902-json-patch/</guid><description><![CDATA[<h2 id="引言">引言</h2>
<p>你一定知道 JSON 吧，那专门用于修改 JSON 内容的 JSON PATCH 标准你是否知道呢？</p>
<p><a href="https://www.rfc-editor.org/rfc/rfc6902" target="_blank" rel="noopener noreffer ">RFC 6902</a> 就定义了这么一种 JSON PATCH 标准，本文将对其进行介绍。</p>
<h2 id="json-patch">JSON PATCH</h2>
<p>JSON Patch 本身也是一种 JSON 文档结构，用于表示要应用于 JSON 文档的操作序列；它适用于 HTTP <code>PATCH</code> 方法，其 MIME 媒体类型为 <code>&quot;application/json-patch+json&quot;</code>。</p>]]></description></item><item><title>GitHub Actions 指南</title><link>https://rifewang.github.io/github-actions/</link><pubDate>Mon, 23 Dec 2019 00:00:00 +0800</pubDate><author>凌虚</author><guid>https://rifewang.github.io/github-actions/</guid><description>&lt;h1 id="github-actions-指南">GitHub Actions 指南&lt;/h1>
&lt;p>GitHub Actions 使你可以直接在你的 GitHub 库中创建自定义的工作流，工作流指的就是自动化的流程，比如构建、测试、打包、发布、部署等等，也就是说你可以直接进行 CI（持续集成）和 CD （持续部署）。&lt;/p></description></item><item><title>给你的库加上酷炫的小徽章</title><link>https://rifewang.github.io/ava-codecov-travis/</link><pubDate>Sat, 21 Dec 2019 13:36:00 +0800</pubDate><author>凌虚</author><guid>https://rifewang.github.io/ava-codecov-travis/</guid><description><![CDATA[<h1 id="给库加上酷炫的小徽章--avacodecovtravis-示例">给库加上酷炫的小徽章 &amp; ava、codecov、travis 示例</h1>
<p>GitHub 很多开源库都会有几个酷炫的小徽章，比如：</p>
<p>    </p>]]></description></item><item><title>使用 Makefile 构建指令集</title><link>https://rifewang.github.io/makefile/</link><pubDate>Sun, 15 Dec 2019 13:39:47 +0800</pubDate><author>凌虚</author><guid>https://rifewang.github.io/makefile/</guid><description><![CDATA[<h1 id="使用-makefile-构建指令集">使用 Makefile 构建指令集</h1>
<p><code>make</code> 是一个历史悠久的构建工具，通过配置 <code>Makefile</code> 文件就可以很方便的使用你自己自定义的各种指令集，且与具体的编程语言无关。
例如配置如下的 <code>Makefile</code> :</p>]]></description></item><item><title>实现 memcached 客户端：TCP、连接池、一致性哈希、自定义协议</title><link>https://rifewang.github.io/create-memcached-client/</link><pubDate>Mon, 09 Dec 2019 13:41:38 +0800</pubDate><author>凌虚</author><guid>https://rifewang.github.io/create-memcached-client/</guid><description><![CDATA[<h1 id="实现-memcached-客户端tcp连接池一致性哈希自定义协议">实现 memcached 客户端：TCP、连接池、一致性哈希、自定义协议。</h1>
<p>废话不多说，文本将带你实现一个简单的 memcached 客户端。</p>
<h2 id="集群一致性哈希">集群：一致性哈希</h2>
<p>memcached 本身并不支持集群，为了使用集群，我们可以自己在客户端实现路由分发，将相同的 key 路由到同一台 memcached 上去即可。
路由算法有很多，这里我们使用一致性哈希算法。</p>]]></description></item><item><title>CPU 密集型任务会阻塞 Node.js 吗【译】</title><link>https://rifewang.github.io/nodejs-thread-block/</link><pubDate>Tue, 24 Sep 2019 17:19:31 +0800</pubDate><author>凌虚</author><guid>https://rifewang.github.io/nodejs-thread-block/</guid><description><![CDATA[<p><em>本文翻译自：
<a href="https://betterprogramming.pub/is-node-js-really-single-threaded-7ea59bcc8d64" target="_blank" rel="noopener noreffer ">https://betterprogramming.pub/is-node-js-really-single-threaded-7ea59bcc8d64</a></em></p>
<p>CPU密集型任务会阻塞 Node.js 吗？</p>
<p>让我们使用加密任务做个简单测试：</p>
<p></p>
<p>如图所示，连续执行四次加密任务，打印耗时，结果会发生什么？</p>]]></description></item><item><title>Let's Encrypt 配置 HTTPS 免费泛域名证书</title><link>https://rifewang.github.io/lets-encrypt/</link><pubDate>Thu, 27 Jun 2019 16:26:45 +0800</pubDate><author>凌虚</author><guid>https://rifewang.github.io/lets-encrypt/</guid><description>&lt;p>想要使用 HTTPS ，你必须先拥有权威 CA（证书签发机构）签发的证书（对于自签名的证书，浏览器是不认账的）。Let&amp;rsquo;s Encrypt 就是一家权威的 CA 证书签发机构，你可以向他申请免费的证书（一般商业证书的价格比较贵）。&lt;/p></description></item><item><title>深入理解 Node.js 事件循环架构【译】</title><link>https://rifewang.github.io/nodejs-event-loop-architecture/</link><pubDate>Tue, 28 May 2019 15:53:48 +0800</pubDate><author>凌虚</author><guid>https://rifewang.github.io/nodejs-event-loop-architecture/</guid><description><![CDATA[<p><em>本文翻译自：
<a href="https://medium.com/preezma/node-js-event-loop-architecture-go-deeper-node-core-c96b4cec7aa4" target="_blank" rel="noopener noreffer ">https://medium.com/preezma/node-js-event-loop-architecture-go-deeper-node-core-c96b4cec7aa4</a></em></p>
<p></p>
<p>关于 Node.js ，相信你已经了解过不少内容，诸如 Node.js 内核、事件循环、单线程、setTimeout 或 setImmediate 函数的执行机制等等。</p>]]></description></item><item><title>使用 Puppeteer 构建自动化端到端测试</title><link>https://rifewang.github.io/puppeteer/</link><pubDate>Fri, 22 Mar 2019 15:04:16 +0800</pubDate><author>凌虚</author><guid>https://rifewang.github.io/puppeteer/</guid><description><![CDATA[<p>端到端测试指的是将系统作为一个黑盒，模拟正常用户行为，跨越从前端到后端整个软件系统，是一种全局性的整体测试。</p>
<p>来看本文的示例：</p>
<video autoplay="true" width="100%" class="video-shortcode" preload="" controls>
    <source src="/videos/puppeteer-eg.mp4" type="">
    There should have been a video here but your browser does not seem
    to support it.
</video>
<p>你在视频中看到的所有操作全部都是由程序自动完成的，就像真实的用户一样，通过这种自动化的方式可以很好的提升我们的测试效率从而保证交付的质量。</p>]]></description></item><item><title>图像相似性：哈希和特征</title><link>https://rifewang.github.io/image-similarity/</link><pubDate>Thu, 14 Mar 2019 15:15:10 +0800</pubDate><author>凌虚</author><guid>https://rifewang.github.io/image-similarity/</guid><description><![CDATA[<h2 id="引言">引言</h2>
<p>如何判断图像的相似性？</p>
<p>直接比较图像内容的 md5 值肯定是不行的，md5 的方式只能判断像素级别完全一致。图像的基本单元是像素，如果两张图像完全相同，那么图像内容的 md5 值一定相同，然而一旦小部分像素发生变化，比如经过缩放、水印、噪声等处理，那么它们的 md5 值就会天差地别。</p>]]></description></item></channel></rss>