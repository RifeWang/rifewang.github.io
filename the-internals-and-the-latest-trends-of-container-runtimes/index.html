<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>容器运行时的内部结构和最新趋势（2023） - 凌虚 Blog</title><meta name=Description content="容器运行时的内部结构和最新趋势（2023）"><meta property="og:title" content="容器运行时的内部结构和最新趋势（2023）">
<meta property="og:description" content="容器运行时的内部结构和最新趋势（2023）"><meta property="og:type" content="article"><meta property="og:url" content="https://rifewang.github.io/the-internals-and-the-latest-trends-of-container-runtimes/"><meta property="og:image" content="https://rifewang.github.io/images/avatar.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-11T10:07:05+08:00"><meta property="article:modified_time" content="2023-07-11T12:35:50+08:00"><meta property="og:site_name" content="凌虚 Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://rifewang.github.io/images/avatar.png"><meta name=twitter:title content="容器运行时的内部结构和最新趋势（2023）"><meta name=twitter:description content="容器运行时的内部结构和最新趋势（2023）"><meta name=application-name content="凌虚的博客"><meta name=apple-mobile-web-app-title content="凌虚的博客"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel=canonical href=https://rifewang.github.io/the-internals-and-the-latest-trends-of-container-runtimes/><link rel=prev href=https://rifewang.github.io/k8s-memory-management-for-java-applications/><link rel=next href=https://rifewang.github.io/k8s-crd-operator/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=/lib/fontawesome-free/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload href=/lib/animate/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"容器运行时的内部结构和最新趋势（2023）","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/rifewang.github.io\/the-internals-and-the-latest-trends-of-container-runtimes\/"},"image":["https:\/\/rifewang.github.io\/images\/avatar.png"],"genre":"posts","keywords":"Container, Docker, Kubernetes","wordcount":7269,"url":"https:\/\/rifewang.github.io\/the-internals-and-the-latest-trends-of-container-runtimes\/","datePublished":"2023-07-11T10:07:05+08:00","dateModified":"2023-07-11T12:35:50+08:00","license":"Attribution-NonCommercial 4.0 International (CC BY-NC 4.0)","publisher":{"@type":"Organization","name":"凌虚","logo":"https:\/\/rifewang.github.io\/images\/avatar.png"},"author":{"@type":"Person","name":"凌虚"},"description":"容器运行时的内部结构和最新趋势（2023）"}</script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-VRMQFEVL7J"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VRMQFEVL7J")</script><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"light"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"light"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="凌虚 Blog">凌虚的博客</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/about>作者 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i>
</span></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="凌虚 Blog">凌虚的博客</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/about title>作者</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class="toc-content always-active" id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">容器运行时的内部结构和最新趋势（2023）</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>凌虚</a></span>&nbsp;<span class=post-category>included in <a href=/categories/kubernetes/><i class="far fa-folder fa-fw" aria-hidden=true></i>Kubernetes</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2023-07-11>2023-07-11</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;7269 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;15 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-容器简介>1. 容器简介</a><ul><li><a href=#什么是容器>什么是容器？</a></li><li><a href=#docker>Docker</a></li><li><a href=#kubernetes>Kubernetes</a></li><li><a href=#docker-与-docker-之前的容器>Docker 与 Docker 之前的容器</a></li></ul></li><li><a href=#2-容器运行时的内部结构>2. 容器运行时的内部结构</a><ul><li><a href=#docker-底层>Docker 底层</a></li><li><a href=#namespace-命名空间>Namespace 命名空间</a></li><li><a href=#cgroups>Cgroups</a></li><li><a href=#capabilities>Capabilities</a></li><li><a href=#可选seccomp>（可选）Seccomp</a></li><li><a href=#可选apparmor-或-selinux>（可选）AppArmor 或 SELinux</a></li><li><a href=#适用于-macwin-的-docker>适用于 Mac/Win 的 Docker</a></li></ul></li><li><a href=#3容器运行时的最新趋势>3.容器运行时的最新趋势</a><ul><li><a href=#docker-的替代品作为-kubernetes-运行时>Docker 的替代品（作为 Kubernetes 运行时）</a></li><li><a href=#docker-的替代方案作为-cli>Docker 的替代方案（作为 CLI）</a></li><li><a href=#在-mac-上运行容器>在 Mac 上运行容器</a></li><li><a href=#docker-正在重构>Docker 正在重构</a></li><li><a href=#lazy-pulling-惰性拉取>Lazy-pulling 惰性拉取</a></li><li><a href=#扩大-user-namespace-的采用>扩大 User namespace 的采用</a></li><li><a href=#rootless-容器>Rootless 容器</a></li><li><a href=#更多-lsm>更多 LSM</a></li><li><a href=#kata-containers>Kata Containers</a></li><li><a href=#gvisor>gVisor</a></li><li><a href=#webassembly>WebAssembly</a></li></ul></li><li><a href=#总结>总结</a></li></ul></nav></div></div><div class=content id=content><h1 id=容器运行时的内部结构和最新趋势2023>容器运行时的内部结构和最新趋势（2023）</h1><p>原文为 Akihiro Suda 在日本京都大学做的在线讲座，完整的 PPT 可 <a href=https://github.com/AkihiroSuda/AkihiroSuda/raw/5d9f0b1cd9b8c37cb1951768a3bebdb08a3a469e/slides/2023/20230615%20%5BKyoto%20University%5D%20The%20internals%20and%20the%20latest%20trends%20of%20container%20runtimes.pdf target=_blank rel="noopener noreffer">点击此处下载</a></p><p>本文内容分为以下三个部分：</p><ol><li>容器简介</li><li>容器运行时的内部结构</li><li>容器运行时的最新趋势</li></ol><hr><h2 id=1-容器简介>1. 容器简介</h2><h3 id=什么是容器>什么是容器？</h3><p>容器是一组用于隔离文件系统、CPU 资源、内存资源、系统权限等的各种轻量级方法。容器在很多意义上类似于虚拟机，但它们比虚拟机更高效，而安全性则往往低于虚拟机。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://miro.medium.com/1*OVsYlSmH_L15vparu4VrWg.png data-srcset="https://miro.medium.com/1*OVsYlSmH_L15vparu4VrWg.png, https://miro.medium.com/1*OVsYlSmH_L15vparu4VrWg.png 1.5x, https://miro.medium.com/1*OVsYlSmH_L15vparu4VrWg.png 2x" data-sizes=auto alt=https://miro.medium.com/1*OVsYlSmH_L15vparu4VrWg.png title=https://miro.medium.com/1*OVsYlSmH_L15vparu4VrWg.png></p><p>有趣的是，“<em>容器</em>”目前还没有严格的定义。当虚拟机提供类似容器的接口时，例如，当它们实现 <a href=https://specs.opencontainers.org/ target=_blank rel="noopener noreffer">OCI（开放容器）规范</a> 时，甚至虚拟机也可以被称为“<em>容器</em>”。这种“非容器”的容器将在后面的第三部分中讨论。</p><h3 id=docker>Docker</h3><p><a href=https://www.docker.com/ target=_blank rel="noopener noreffer">Docker</a> 是最流行的容器引擎。Docker 本身支持 Linux 容器和 Windows 容器，但 Windows 容器不在本次讨论的范围之内。</p><p>启动 Docker 容器的典型命令行如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>docker run -p 8080:80 -v .:/usr/share/nginx/html nginx:1.25
</span></span></code></pre></td></tr></table></div></div><p>执行该命令后，可以在 <code>http://&lt;the host’s IP>:8080/</code> 中看到当前目录下 <code>index.html</code> 的内容。</p><p>命令中的 <code>-p 8080:80</code> 部分指定将主机的 TCP 8080 端口转发到容器的 80 端口。</p><p>命令中的 <code>-v .:/usr/share/nginx/html</code> 部分指定将主机上的当前目录挂载到容器中的 <code>/usr/share/nginx/html</code>。</p><p>命令中的 <code>nginx:1.25</code> 指定使用 <a href=https://hub.docker.com/ target=_blank rel="noopener noreffer">Docker Hub</a> 上的 <a href=https://hub.docker.com/_/nginx target=_blank rel="noopener noreffer">官方 nginx 镜像</a>。Docker 镜像与虚拟机镜像有些相似，但是它们通常不包含额外的诸如 systemd 和 sshd 等守护进程。</p><p>您也可以在 <a href=https://hub.docker.com/search target=_blank rel="noopener noreffer">Docker Hub</a> 上找到其他应用程序的官方镜像。您还可以使用称为 <code>Dockerfile</code> 的语言自行构建自己的镜像：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Dockerfile data-lang=Dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> debian:12</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span>  apt-get update <span class=o>&amp;&amp;</span> apt-get install -y openjdk-17-jre<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> myapp.jar /myapp.jar<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span>  <span class=p>[</span><span class=s2>&#34;java&#34;</span><span class=p>,</span> <span class=s2>&#34;-jar&#34;</span><span class=p>,</span> <span class=s2>&#34;/myapp.jar&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>可以使用 <a href=https://docs.docker.com/engine/reference/commandline/build/ target=_blank rel="noopener noreffer">docker build</a> 命令构建镜像，并使用 <a href=https://docs.docker.com/engine/reference/commandline/push/ target=_blank rel="noopener noreffer">docker push</a> 命令将其推送到 Docker Hub 或其它镜像仓库。</p><h3 id=kubernetes>Kubernetes</h3><p><a href=https://kubernetes.io/ target=_blank rel="noopener noreffer">Kubernetes</a> 将多个容器主机（例如（但不限于）Docker 主机）集群化，以提供负载平衡和容错功能。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://miro.medium.com/1*An2qZhoR6_OGaz7Z4mG8Zg.png data-srcset="https://miro.medium.com/1*An2qZhoR6_OGaz7Z4mG8Zg.png, https://miro.medium.com/1*An2qZhoR6_OGaz7Z4mG8Zg.png 1.5x, https://miro.medium.com/1*An2qZhoR6_OGaz7Z4mG8Zg.png 2x" data-sizes=auto alt=https://miro.medium.com/1*An2qZhoR6_OGaz7Z4mG8Zg.png title=https://miro.medium.com/1*An2qZhoR6_OGaz7Z4mG8Zg.png></p><p>值得注意的是，Kubernetes 也是一个抽象框架，用于与 <a href=https://kubernetes.io/docs/concepts/workloads/pods/ target=_blank rel="noopener noreffer">Pods</a>（始终在同一主机上共同调度的容器组）、<a href=https://kubernetes.io/docs/concepts/services-networking/service/ target=_blank rel="noopener noreffer">Services</a>（网络连接实体）和 <a href=https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/ target=_blank rel="noopener noreffer">其它类型的对象</a> 进行交互，但是本次演讲不会深入介绍 kubernetes。</p><h3 id=docker-与-docker-之前的容器>Docker 与 Docker 之前的容器</h3><p>虽然容器直到 2013 年 Docker 发布才受到太多关注，但 Docker 并不是第一个容器平台：</p><ul><li><strong>1999</strong>：<a href="https://svnweb.freebsd.org/base?view=revision&amp;revision=46155" target=_blank rel="noopener noreffer">FreeBSD Jail</a></li><li><strong>2000</strong>：<a href=https://lkml.iu.edu/hypermail/linux/kernel/0008.2/0042.html target=_blank rel="noopener noreffer">Linux 虚拟环境系统（Virtuozzo 和 OpenVZ 的前身）</a></li><li><strong>2001</strong>：<a href=https://www.cs.helsinki.fi/linux/linux-kernel/2001-40/1065.html target=_blank rel="noopener noreffer">Linux Vserver</a></li><li><strong>2002</strong>：<a href=https://wiki.openvz.org/History target=_blank rel="noopener noreffer">Virtuozzo</a></li><li><strong>2004</strong>：<a href=https://lkml.iu.edu/hypermail/linux/kernel/0409.1/0994.html target=_blank rel="noopener noreffer">BSD Jail for Linux</a></li><li><strong>2004</strong>：<a href=https://web.archive.org/web/20041116174148/http://www.sun.com/smi/Press/sunflash/2004-11/sunflash.20041115.2.html target=_blank rel="noopener noreffer">Solaris Containers（显然，“容器”这个词就是这次创造的）</a></li><li><strong>2005</strong>：<a href=https://wiki.openvz.org/History target=_blank rel="noopener noreffer">OpenVZ</a></li><li><strong>2008</strong>：<a href=https://github.com/lxc/lxc/tree/5e97c3fcce787a5bc0f8ceef43aa3e05195b480a target=_blank rel="noopener noreffer">LXC</a></li><li><strong>2013</strong>：<a href="https://www.youtube.com/watch?v=9xciauwbsuo" target=_blank rel="noopener noreffer">Docker</a></li></ul><p>人们普遍认为 FreeBSD Jail（大约 1999 年）是类 Unix 操作系统的第一个实用容器实现，尽管“容器”这个术语并不是在那时创造的。</p><p>从那时起，Linux 上也出现了几种实现。然而，Docker 之前的容器与 Docker 容器有本质上的不同。前者专注于模仿整个机器，其中包含 System V init、sshd、syslogd 等。当时经常将 Web 服务器、应用服务器、数据库服务器和所有内容放入一个容器中。</p><p>Docker 改变了整个范式。就 Docker 而言，一个容器通常只包含一个服务，因此容器可以是无状态且不可变的。这种设计显着降低了维护成本，因为容器现在是一次性的；当需要更新某些内容时，您只需删除容器并从最新镜像重新创建它即可。您也不再需要在容器内安装 sshd 和其他实用程序，因为您永远不需要对其进行 shell 访问。这也简化了多主机集群的负载平衡和容错。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://miro.medium.com/1*Xzpc72NV3fxpZfDrUfCHCA.png data-srcset="https://miro.medium.com/1*Xzpc72NV3fxpZfDrUfCHCA.png, https://miro.medium.com/1*Xzpc72NV3fxpZfDrUfCHCA.png 1.5x, https://miro.medium.com/1*Xzpc72NV3fxpZfDrUfCHCA.png 2x" data-sizes=auto alt=https://miro.medium.com/1*Xzpc72NV3fxpZfDrUfCHCA.png title=https://miro.medium.com/1*Xzpc72NV3fxpZfDrUfCHCA.png></p><hr><h2 id=2-容器运行时的内部结构>2. 容器运行时的内部结构</h2><p>本节假设使用 Docker v24 及其默认配置，但大多数部分也适用于非 Docker 容器。</p><h3 id=docker-底层>Docker 底层</h3><p>Docker 由客户端程序（<code>docker</code> CLI）和守护进程（<code>dockerd</code>）组成。<code>docker</code> CLI 通过 Unix 套接字 (<code>/var/run/docker.sock</code>) 连接到 <code>dockerd</code> 守护进程来创建容器。</p><p>然而，<code>dockerd</code> 守护进程本身并不创建容器，它将控制权委托给 <a href=https://containerd.io/ target=_blank rel="noopener noreffer"><code>containerd</code></a> 守护进程来创建容器。但 <code>containerd</code> 也不创建容器，而是进一步将控制权委托给 <a href=https://github.com/opencontainers/runc target=_blank rel="noopener noreffer"><code>runc</code></a> 运行时，它包含了多个 Linux 内核功能，例如 Namespaces、Cgroups 和 Capabilities，以实现“<em>容器</em>”的概念。Linux 内核中并没有“<em>容器</em>”对象。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://miro.medium.com/1*RWzcHdOheUfu_cdEwCRRmQ.png data-srcset="https://miro.medium.com/1*RWzcHdOheUfu_cdEwCRRmQ.png, https://miro.medium.com/1*RWzcHdOheUfu_cdEwCRRmQ.png 1.5x, https://miro.medium.com/1*RWzcHdOheUfu_cdEwCRRmQ.png 2x" data-sizes=auto alt=https://miro.medium.com/1*RWzcHdOheUfu_cdEwCRRmQ.png title=https://miro.medium.com/1*RWzcHdOheUfu_cdEwCRRmQ.png></p><h3 id=namespace-命名空间>Namespace 命名空间</h3><p><a href=https://man7.org/linux/man-pages/man7/namespaces.7.html target=_blank rel="noopener noreffer">Namespace 命名空间</a> 将资源与主机和其他容器隔离。</p><p>最知名的命名空间是 <a href=https://man7.org/linux/man-pages/man7/mount_namespaces.7.html target=_blank rel="noopener noreffer">mount namespace</a>。Mount 命名空间隔离文件系统视图，以便容器可以使用 <a href=https://man7.org/linux/man-pages/man2/pivot_root.2.html target=_blank rel="noopener noreffer"><code>pivot_root(2)</code></a> 系统调用将 rootfs 更改为 <code>/var/lib/docker/.../&lt;container's rootfs></code>。该系统调用类似于传统的 <a href=https://man7.org/linux/man-pages/man2/chroot.2.html target=_blank rel="noopener noreffer"><code>chroot(2)</code></a> 但 <a href=https://tbhaxor.com/pivot-root-vs-chroot-for-containers/ target=_blank rel="noopener noreffer">更安全</a>。</p><p>容器的 rootfs 与主机的结构非常相似，但它对 <code>/proc</code>、<code>/sys</code> 和 <code>/dev</code> 有一些限制。例如，</p><ul><li><code>/proc/sys</code> 目录被重新挂载为只读绑定以禁止 sysctl。</li><li>通过挂载 <code>/dev/null</code> 来屏蔽 <code>/proc/kcore</code> 文件（RAM）。</li><li>通过挂载空的只读 tmpfs 来屏蔽 <code>/sys/firmware</code> 目录（固件数据）。</li><li>对 <code>/dev</code> 目录的访问受到 Cgroup 的限制（稍后讨论）。</li></ul><p><img class=lazyload src=/svg/loading.min.svg data-src=https://miro.medium.com/1*T-hPJqFAR6UIZ-yDHETOMQ.png data-srcset="https://miro.medium.com/1*T-hPJqFAR6UIZ-yDHETOMQ.png, https://miro.medium.com/1*T-hPJqFAR6UIZ-yDHETOMQ.png 1.5x, https://miro.medium.com/1*T-hPJqFAR6UIZ-yDHETOMQ.png 2x" data-sizes=auto alt=https://miro.medium.com/1*T-hPJqFAR6UIZ-yDHETOMQ.png title=https://miro.medium.com/1*T-hPJqFAR6UIZ-yDHETOMQ.png></p><p><a href=https://man7.org/linux/man-pages/man7/network_namespaces.7.html target=_blank rel="noopener noreffer">Network namespace</a> 允许为容器分配专用 IP 地址，以便它们可以通过 IP 相互通信。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://miro.medium.com/1*fDuES0pJVmlZ-JLDNM1gSw.png data-srcset="https://miro.medium.com/1*fDuES0pJVmlZ-JLDNM1gSw.png, https://miro.medium.com/1*fDuES0pJVmlZ-JLDNM1gSw.png 1.5x, https://miro.medium.com/1*fDuES0pJVmlZ-JLDNM1gSw.png 2x" data-sizes=auto alt=https://miro.medium.com/1*fDuES0pJVmlZ-JLDNM1gSw.png title=https://miro.medium.com/1*fDuES0pJVmlZ-JLDNM1gSw.png></p><p><a href=https://man7.org/linux/man-pages/man7/pid_namespaces.7.html target=_blank rel="noopener noreffer">PID namespace</a> 隔离进程树，以便容器无法控制其外部的进程。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://miro.medium.com/1*ZZdXqUyVmpRb1ZK9yk8OBQ.png data-srcset="https://miro.medium.com/1*ZZdXqUyVmpRb1ZK9yk8OBQ.png, https://miro.medium.com/1*ZZdXqUyVmpRb1ZK9yk8OBQ.png 1.5x, https://miro.medium.com/1*ZZdXqUyVmpRb1ZK9yk8OBQ.png 2x" data-sizes=auto alt=https://miro.medium.com/1*ZZdXqUyVmpRb1ZK9yk8OBQ.png title=https://miro.medium.com/1*ZZdXqUyVmpRb1ZK9yk8OBQ.png></p><p><a href=https://man7.org/linux/man-pages/man7/user_namespaces.7.html target=_blank rel="noopener noreffer">User namespace</a>（不要与<a href=https://en.wikipedia.org/wiki/User_space_and_kernel_space target=_blank rel="noopener noreffer">用户空间</a> 混淆）通过将主机上的非 root 用户映射到容器中的伪 root 来隔离 root 权限。伪 root 可以像容器中的root 一样运行 <code>apt-get</code>、<code>dnf</code> 等，但它没有对容器外部资源的特权访问。</p><p>用户命名空间显着减轻了潜在的容器突破攻击，但 <a href=https://docs.docker.com/engine/security/userns-remap/ target=_blank rel="noopener noreffer">Docker 中默认不使用它</a>。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://miro.medium.com/1*yUzEpHCWi-vw1suk5ncFaw.png data-srcset="https://miro.medium.com/1*yUzEpHCWi-vw1suk5ncFaw.png, https://miro.medium.com/1*yUzEpHCWi-vw1suk5ncFaw.png 1.5x, https://miro.medium.com/1*yUzEpHCWi-vw1suk5ncFaw.png 2x" data-sizes=auto alt=https://miro.medium.com/1*yUzEpHCWi-vw1suk5ncFaw.png title=https://miro.medium.com/1*yUzEpHCWi-vw1suk5ncFaw.png></p><p>其他命名空间：</p><ul><li><a href=https://man7.org/linux/man-pages/man7/ipc_namespaces.7.html target=_blank rel="noopener noreffer"><strong>IPC命名空间</strong></a>：隔离 System V 进程间通信对象等。</li><li><a href=https://man7.org/linux/man-pages/man7/uts_namespaces.7.html target=_blank rel="noopener noreffer"><strong>UTS 命名空间</strong></a>：隔离主机名。&ldquo;UTS&rdquo;（Unix Time Sharing system）似乎对这个命名空间来说是个用词不当的称呼。</li><li><a href=https://man7.org/linux/man-pages/man7/uts_namespaces.7.html target=_blank rel="noopener noreffer"><strong>（可选）Cgroup 命名空间</strong></a>：隔离 <code>/sys/fs/cgroup</code> 层次结构。</li><li><a href=https://man7.org/linux/man-pages/man7/time_namespaces.7.html target=_blank rel="noopener noreffer"><strong>（可选）Time 命名空间</strong></a>：隔离时钟。<a href=https://github.com/opencontainers/runtime-spec/pull/1151 target=_blank rel="noopener noreffer">大多数容器尚未使用</a>。</li></ul><h3 id=cgroups>Cgroups</h3><p><a href=https://man7.org/linux/man-pages/man7/cgroups.7.html target=_blank rel="noopener noreffer">Cgroups</a>（控制组）施加多种资源配额，例如 CPU 使用率、内存使用率、block I/O 以及容器中的进程数量。</p><p>Cgroup 还控制对设备节点的访问。<a href=https://github.com/opencontainers/runtime-spec/blob/v1.0.2/config-linux.md#default-devices target=_blank rel="noopener noreffer">Docker默认配置</a> 允许无限制访问 <code>/dev/null</code>、<code>/dev/zero</code>、<code>/dev/urandom</code> 等，不允许访问 <code>/dev/sda</code>（磁盘设备）、<code>/dev/mem</code>（内存）等。</p><h3 id=capabilities>Capabilities</h3><p>在 Linux 上，root 权限由 <a href=https://man7.org/linux/man-pages/man7/capabilities.7.html target=_blank rel="noopener noreffer">64-bit capability</a> 标记。目前使用了 <a href=https://github.com/torvalds/linux/blob/v6.3/include/uapi/linux/capability.h#L420 target=_blank rel="noopener noreffer">41 位</a>。</p><p>Docker 的默认配置删除了系统范围的管理功能，例如 <code>CAP_SYS_ADMIN</code>。</p><p><a href=https://github.com/moby/moby/blob/v24.0.2/oci/caps/defaults.go target=_blank rel="noopener noreffer">保留的能力</a>包括：</p><ul><li><code>CAP_CHOWN</code>：用于在容器内运行 <code>chown</code>。</li><li><code>CAP_NET_BIND_SERVICE</code>：用于绑定容器内 1024 以下的 TCP 和 UDP 端口。</li><li><code>CAP_NET_RAW</code>：用于运行需要制作原始以太网数据包的<a href=https://github.com/moby/moby/issues/41886#issuecomment-1590736893 target=_blank rel="noopener noreffer">旧版 <code>ping</code> 实现</a>。这种功能非常危险，因为它允许在容器网络中进行<a href=https://blog.aquasec.com/dns-spoofing-kubernetes-clusters target=_blank rel="noopener noreffer">ARP 欺骗和 DNS 欺骗</a>。Docker 的未来版本可能会<a href=https://github.com/moby/moby/issues/41886 target=_blank rel="noopener noreffer">默认禁用它</a>。</li></ul><h3 id=可选seccomp>（可选）Seccomp</h3><p><a href=https://man7.org/linux/man-pages/man2/seccomp.2.html target=_blank rel="noopener noreffer">Seccomp</a>（安全计算）允许指定系统调用的显式允许列表（或拒绝列表）。Docker 的默认配置允许大约 <a href=https://github.com/moby/moby/blob/v24.0.2/profiles/seccomp/default.json target=_blank rel="noopener noreffer">350 个系统调用</a>。</p><p>Seccomp 用于<a href=https://en.wikipedia.org/wiki/Defense_in_depth_%28computing%29 target=_blank rel="noopener noreffer"><em>纵深防御</em></a>；对于容器来说这并不是硬性要求。为了向后兼容，Kubernetes 仍然默认不使用 seccomp，并且<a href=https://github.com/kubernetes/enhancements/issues/2413#issuecomment-1581231097 target=_blank rel="noopener noreffer">在可预见的将来可能永远不会改变默认配置</a>。用户仍然可以通过 <a href=https://kubernetes.io/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration target=_blank rel="noopener noreffer">KubeletConfiguration</a> 选择启用 seccomp 。</p><h3 id=可选apparmor-或-selinux>（可选）AppArmor 或 SELinux</h3><p><a href=https://apparmor.net/ target=_blank rel="noopener noreffer">AppArmor</a> 和 <a href=https://github.com/SELinuxProject target=_blank rel="noopener noreffer">SELinux</a>（安全增强型 Linux）是 <a href=https://www.kernel.org/doc/html/v6.3/admin-guide/LSM/index.html target=_blank rel="noopener noreffer">LSM</a>（Linux 安全模块），可提供更细粒度的配置旋钮。</p><p>这些是相互排斥的；由主机操作系统发行商（而不是容器镜像发行商）选择：</p><ul><li><strong>AppArmor</strong>：Debian、Ubuntu、SUSE 等选择的。</li><li><strong>SELinux</strong>：由 Fedora、Red Hat Enterprise Linux 和类似的主机操作系统发行版选择。</li></ul><p>为了进行纵深防御，Docker 的 <a href=https://github.com/moby/moby/blob/v24.0.2/profiles/apparmor/template.go target=_blank rel="noopener noreffer">默认 AppArmor 配置文件</a> 几乎与其功能、挂载掩码等默认配置重叠。用户可以添加自定义设置以提高安全性。</p><p>但 SELinux 的情况则不同。要在 <a href=https://docs.docker.com/engine/reference/commandline/dockerd/ target=_blank rel="noopener noreffer">selinux-enabled</a> 模式下运行容器，您必须在绑定挂载上附加选项 <code>:z</code>（小写字符）或 <code>:Z</code>（大写字符），或者自己运行复杂的 <code>chcon</code> 命令避免权限错误。</p><p><code>:z</code>（小写字符）选项用于类型强制。类型强制通过为进程和文件分配“类型”来保护主机文件免受容器的影响。以 <code>container_t</code> 类型运行的进程可以读取 <code>container_share_t</code> 类型的文件，并读/写 <code>container_file_t</code> 类型的文件，但无法访问其他类型的文件。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://miro.medium.com/1*KoTwjHe3dUEYQRzfOl_Q2A.png data-srcset="https://miro.medium.com/1*KoTwjHe3dUEYQRzfOl_Q2A.png, https://miro.medium.com/1*KoTwjHe3dUEYQRzfOl_Q2A.png 1.5x, https://miro.medium.com/1*KoTwjHe3dUEYQRzfOl_Q2A.png 2x" data-sizes=auto alt=https://miro.medium.com/1*KoTwjHe3dUEYQRzfOl_Q2A.png title=https://miro.medium.com/1*KoTwjHe3dUEYQRzfOl_Q2A.png></p><p><code>:Z</code>（大写字符）选项用于多类别安全性。多类别安全性通过为进程和文件分配类别号来保护一个容器免受另一个容器的影响。例如，类别 42 的进程无法访问标记为类别 43 的文件。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://miro.medium.com/1*bQoe2Cca_wWLXrYBlj_t1w.png data-srcset="https://miro.medium.com/1*bQoe2Cca_wWLXrYBlj_t1w.png, https://miro.medium.com/1*bQoe2Cca_wWLXrYBlj_t1w.png 1.5x, https://miro.medium.com/1*bQoe2Cca_wWLXrYBlj_t1w.png 2x" data-sizes=auto alt=https://miro.medium.com/1*bQoe2Cca_wWLXrYBlj_t1w.png title=https://miro.medium.com/1*bQoe2Cca_wWLXrYBlj_t1w.png></p><h3 id=适用于-macwin-的-docker>适用于 Mac/Win 的 Docker</h3><p><a href=https://www.docker.com/products/docker-desktop/ target=_blank rel="noopener noreffer">Docker Desktop</a> 产品支持在 Mac 和 Windows 上运行 Linux 容器，但它们只是在底层运行 Linux 虚拟机来在其上运行容器。这些容器不直接在 macOS 和 Windows 上运行。</p><hr><h2 id=3容器运行时的最新趋势>3.容器运行时的最新趋势</h2><h3 id=docker-的替代品作为-kubernetes-运行时>Docker 的替代品（作为 Kubernetes 运行时）</h3><p>Kubernetes 的第一个版本（2014 年）是专门为 Docker 制作的。Kubernetes <a href=https://kubernetes.io/blog/2016/07/kubernetes-1-3-bridging-cloud-native-and-enterprise-workloads/ target=_blank rel="noopener noreffer">v1.3</a> (2016) 添加了对名为 <code>rkt</code> 的替代容器运行时的临时支持，但 <code>rkt</code> 已于<a href=https://www.cncf.io/blog/2019/08/16/cncf-archives-the-rkt-project/ target=_blank rel="noopener noreffer">2019 年</a>退役。支持替代容器运行时的努力在 Kubernetes <a href=https://github.com/kubernetes/kubernetes/blob/v1.5.0/docs/devel/container-runtime-interface.md target=_blank rel="noopener noreffer">v1.5</a> (2016) 中产生了容器运行时接口 <code>CRI</code> API。CRI 首次亮相后，业界已趋同于使用 <a href=https://containerd.io/ target=_blank rel="noopener noreffer">containerd</a> 和 <a href=https://cri-o.io/ target=_blank rel="noopener noreffer">CRI-O</a> 这两种运行时其中之一：。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://miro.medium.com/1*04Edb0wEnXci2c5ye9F8dA.png data-srcset="https://miro.medium.com/1*04Edb0wEnXci2c5ye9F8dA.png, https://miro.medium.com/1*04Edb0wEnXci2c5ye9F8dA.png 1.5x, https://miro.medium.com/1*04Edb0wEnXci2c5ye9F8dA.png 2x" data-sizes=auto alt=https://miro.medium.com/1*04Edb0wEnXci2c5ye9F8dA.png title=https://miro.medium.com/1*04Edb0wEnXci2c5ye9F8dA.png></p><p>Kubernetes 仍然内置了对 Docker 的支持，但最终在 Kubernetes <a href=https://kubernetes.io/blog/2022/03/31/ready-for-dockershim-removal/ target=_blank rel="noopener noreffer">v1.24</a>（2022年）中被删除。Docker 仍然继续作为第三方运行时为 Kubernetes 工作（通过 <a href=https://github.com/Mirantis/cri-dockerd target=_blank rel="noopener noreffer"><code>cri-dockerd</code></a> shim），但 Docker 现在在 Kubernetes 中的使用率越来越低。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://miro.medium.com/1*ttq05nTH21UT577xW-FIRg.png data-srcset="https://miro.medium.com/1*ttq05nTH21UT577xW-FIRg.png, https://miro.medium.com/1*ttq05nTH21UT577xW-FIRg.png 1.5x, https://miro.medium.com/1*ttq05nTH21UT577xW-FIRg.png 2x" data-sizes=auto alt=https://miro.medium.com/1*ttq05nTH21UT577xW-FIRg.png title=https://miro.medium.com/1*ttq05nTH21UT577xW-FIRg.png></p><p>业界知名大厂已经从 Docker 转向了 containerd 或者 CRI-O：</p><ul><li><strong>containerd 的采用者</strong>：<a href=https://docs.aws.amazon.com/eks/latest/userguide/dockershim-deprecation.html target=_blank rel="noopener noreffer">Amazon Elastic Kubernetes Service (EKS)</a>、<a href=https://learn.microsoft.com/en-us/azure/aks/cluster-configuration#container-runtime-configuration target=_blank rel="noopener noreffer">Azure Kubernetes Service (AKS)</a>、<a href=https://cloud.google.com/kubernetes-engine/docs/how-to/migrate-containerd target=_blank rel="noopener noreffer">Google Kubernetes Engine (GKE)</a>、<a href=https://docs.k3s.io/advanced#configuring-containerd target=_blank rel="noopener noreffer">k3s</a> 等（很多）。</li><li><strong>CRI-O 的采用者</strong>：<a href=https://docs.openshift.com/container-platform/4.13/architecture/architecture.html#architecture-custom-os_architecture target=_blank rel="noopener noreffer">Red Hat OpenShift</a>、<a href=https://docs.oracle.com/en-us/iaas/Content/ContEng/Concepts/contengaboutk8sversions.htm target=_blank rel="noopener noreffer">Oracle Container Engine for Kubernetes (OKE)</a> 等。</li></ul><p>Containerd 注重可扩展性，支持非 Kubernetes 工作负载以及 Kubernetes 工作负载。相比之下，CRI-O 注重简单性，并且仅支持 Kubernetes。</p><h3 id=docker-的替代方案作为-cli>Docker 的替代方案（作为 CLI）</h3><p>尽管 Kubernetes 已成为多节点生产集群的标准，但用户仍然希望使用类似 Docker 的 CLI 在笔记本电脑上本地构建和测试容器。Docker 基本上满足了这个需求，但是社区中的运行时开发人员希望构建自己的“实验室”CLI，以先于 Docker 和 Kubernetes 孵化新功能，因为通常很难向 Docker 和 Kubernetes 提出新功能，由于一些技术/技术因素原因。</p><p><a href=https://podman.io/ target=_blank rel="noopener noreffer">Podman</a>（以前称为 kpod ）是由 Red Hat 等公司创建的兼容 Docker 的独立容器引擎。它与 Docker 的主要区别在于它默认没有守护进程。此外，Podman 的独特之处在于它为管理 Pod（共享相同网络命名空间的容器组，通常共享同一主机上的数据卷以实现高效通信）以及容器提供一流的支持。然而，大多数用户似乎只将 Podman 用于非 Pod 容器。</p><p><a href=https://github.com/containerd/nerdctl target=_blank rel="noopener noreffer">nerdctl</a>（我于 2020 年创立）是一个适用于 containerd 的兼容 Docker 的 CLI。nerdctl 最初是为了试验新功能，例如延迟拉取（稍后讨论），但它对于调试运行 containerd 的 Kubernetes 节点也很有用。</p><h3 id=在-mac-上运行容器>在 Mac 上运行容器</h3><p><a href=https://www.docker.com/products/docker-desktop/ target=_blank rel="noopener noreffer">Docker Desktop</a> 的 Mac 和 Windows 产品是专有的。Windows 用户可以在 WSL2 中运行 Docker 的 Linux 版本（Apache License 2.0，无图形界面），但迄今为止，Mac 用户还没有相应的解决方案。</p><p><a href=https://lima-vm.io/ target=_blank rel="noopener noreffer">Lima</a>（也是我于 2021 年创立的）是一个命令行工具，用于在 macOS 上创建类似 WSL2 的环境来运行容器。Lima 默认使用 nerdctl，但它也支持 Docker 和 Podman。</p><p>Lima 还被 <a href=https://github.com/abiosoft/colima target=_blank rel="noopener noreffer">colima</a> (2021)、<a href=https://rancherdesktop.io/ target=_blank rel="noopener noreffer">Rancher Desktop</a> (2021) 和 <a href=https://github.com/runfinch/finch target=_blank rel="noopener noreffer">Finch</a> (2022)等第三方项目采用。</p><p>Podman 社区发布了 <a href=https://docs.podman.io/en/latest/markdown/podman-machine.1.html target=_blank rel="noopener noreffer">Podman Machine</a>（命令行工具，2021 年）和 <a href=https://podman-desktop.io/ target=_blank rel="noopener noreffer">Podman Desktop</a>（GUI，2022 年）作为 Docker Desktop 的替代品。Podman Desktop 也支持 Lima（可选）。</p><h3 id=docker-正在重构>Docker 正在重构</h3><p>containerd 主要提供两个子系统：运行时子系统和镜像子系统。然而，后者并未被Docker使用。这是一个问题，因为 Docker 自身的传统镜像子系统远远落后于 containerd 的现代镜像子系统（这也导致我启动了nerdctl项目）：</p><ul><li>不支持 <a href=https://github.com/containerd/stargz-snapshotter target=_blank rel="noopener noreffer">lazy-pulling 惰性拉取</a>（按需镜像拉取）</li><li><a href=https://github.com/moby/moby/issues/44582 target=_blank rel="noopener noreffer">对多平台镜像的有限支持</a>（例如 AMD64/ARM64 双平台镜像）</li><li><a href=https://github.com/moby/moby/issues/25779 target=_blank rel="noopener noreffer">OCI 规范的有限合规性</a></li></ul><p>这个长期存在的问题终于得到解决。Docker v24 (2023) 在 <code>/etc/docker/daemon.json</code> 中添加了对使用 containerd 的镜像子系统和 <a href=https://github.com/moby/moby/blob/v24.0.2/daemon/daemon.go#L801 target=_blank rel="noopener noreffer">undocumented option</a> 的实验性支持：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span><span class=nt>&#34;features&#34;</span><span class=p>:{</span><span class=nt>&#34;containerd-snapshotter&#34;</span><span class=p>:</span> <span class=kc>true</span><span class=p>}}</span>
</span></span></code></pre></td></tr></table></div></div><p>Docker 的未来版本（2024？2025？）很可能默认使用 containerd 的镜像子系统。</p><h3 id=lazy-pulling-惰性拉取>Lazy-pulling 惰性拉取</h3><p>容器镜像中的大多数文件从未被使用：</p><blockquote><p><strong>“拉取包占容器启动时间的 76%，但其中只有 6.4％ 的数据被读取”</strong>
摘自“ <a href=https://www.usenix.org/conference/fast16/technical-sessions/presentation/harter target=_blank rel="noopener noreffer">Slacker：使用 Lazy Docker 容器进行快速分发</a>”（Harter 等人，FAST 2016）</p></blockquote><p>“惰性拉取”是一种通过按需拉取部分镜像内容来减少容器启动时间的技术。对于 <a href=https://github.com/opencontainers/image-spec/blob/v1.0.2/layer.md target=_blank rel="noopener noreffer">OCI 标准 tar.gz 镜像</a> 来说这是不可能的，因为它们不支持 <code>seek()</code> 操作。人们提出了几种替代格式来支持惰性拉取：</p><ul><li><a href=https://github.com/containerd/stargz-snapshotter target=_blank rel="noopener noreffer"><strong>eStargz</strong></a> (2019) ：优化 seek() 能力的 gzip 粒度；向前兼容 OCI v1 tar.gz。</li><li><a href=https://github.com/awslabs/soci-snapshotter target=_blank rel="noopener noreffer"><strong>SOCI</strong></a> (2022)：捕获 tar.gz 解码器状态的检查点；向前兼容 OCI v1 tar.gz。</li><li><a href=https://github.com/containerd/nydus-snapshotter target=_blank rel="noopener noreffer"><strong>Nydus</strong></a> (2022)：另一种图像格式；
与 OCI v1 tar.gz 不兼容。</li><li><a href=https://github.com/containerd/overlaybd target=_blank rel="noopener noreffer"><strong>OverlayBD</strong></a> (2021)：将块设备作为容器镜像；与 OCI v1 tar.gz 不兼容。</li></ul><p>下图显示了 eStargz 的基准测试结果。惰性拉动（+额外优化）可以将容器启动时间减少到 1/9。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://miro.medium.com/1*MoC4Bvx7V4t6gtRD9UbGkg.png data-srcset="https://miro.medium.com/1*MoC4Bvx7V4t6gtRD9UbGkg.png, https://miro.medium.com/1*MoC4Bvx7V4t6gtRD9UbGkg.png 1.5x, https://miro.medium.com/1*MoC4Bvx7V4t6gtRD9UbGkg.png 2x" data-sizes=auto alt=https://miro.medium.com/1*MoC4Bvx7V4t6gtRD9UbGkg.png title=https://miro.medium.com/1*MoC4Bvx7V4t6gtRD9UbGkg.png></p><h3 id=扩大-user-namespace-的采用>扩大 User namespace 的采用</h3><p>尽管 Docker 自 <a href=https://github.com/moby/moby/pull/12648 target=_blank rel="noopener noreffer">v1.9</a>（2015）以来一直支持用户命名空间，但在 Docker 和 Kubernetes 生态系统中仍然很少使用。</p><p>原因之一是 “chowning” 容器 rootfs 作为伪根的复杂性和开销。Linux 内核 <a href=https://kernelnewbies.org/Linux_5.12#ID_mapping_in_mounts target=_blank rel="noopener noreffer">v5.12</a> (2021) 添加了 “idmapped mounts” 以消除 chown 的必要性。计划在 <a href=https://github.com/opencontainers/runc/pull/3717 target=_blank rel="noopener noreffer">runc v1.2</a> 中支持这一点。</p><p>runc v1.2 发布后，用户命名空间预计将在 Docker 和 Kubernetes 中更加流行，而 Docker 和 Kubernetes 刚刚在 <a href=https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.25.md target=_blank rel="noopener noreffer">v1.25</a>（2022）中添加了对用户命名空间的 <a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/127-user-namespaces/README.md target=_blank rel="noopener noreffer">初步支持</a>。出于兼容性考虑，Kubernetes 不太可能默认启用用户命名空间。然而，Docker <a href=https://github.com/moby/moby/pull/38795 target=_blank rel="noopener noreffer">将来</a> 仍有可能默认启用用户命名空间。不过，一切还没有决定。</p><h3 id=rootless-容器>Rootless 容器</h3><p><a href=https://rootlesscontaine.rs/ target=_blank rel="noopener noreffer">Rootless 容器</a> 是一种将容器运行时以及容器放置在由非 root 用户创建的用户命名空间中的技术，以减轻运行时的潜在漏洞。</p><p>即使容器运行时存在允许攻击者逃离容器的错误，攻击者也无法拥有对其他用户的文件、内核、固件和设备的特权访问权限。</p><p>以下是 rootless 容器的简史：</p><ul><li><strong>2014</strong>：<a href=https://stgraber.org/2014/01/17/lxc-1-0-unprivileged-containers/ target=_blank rel="noopener noreffer">LXC v1.0</a> 引入了对 rootless 容器的支持。当时 rootless 容器被称为“非特权容器”。LXC 的非特权容器与现代 rootless 容器略有不同，因为它们需要 <a href=https://man7.org/linux/man-pages/man1/lxc-user-nic.1.html target=_blank rel="noopener noreffer">SETUID 二进制文件</a> 来 <a href=https://man7.org/linux/man-pages/man5/lxc-usernet.5.html target=_blank rel="noopener noreffer">启动网络</a>。</li><li><strong>2017</strong>：runc <a href=https://github.com/opencontainers/runc/releases/tag/v1.0.0-rc4 target=_blank rel="noopener noreffer">v1.0-rc4</a> 获得对 rootless容器的初步支持。</li><li><strong>2018</strong>：一些工具已经开始支持，<a href=https://twitter.com/_AkihiroSuda_/status/953231819008180224 target=_blank rel="noopener noreffer">containerd</a>、<a href=https://twitter.com/_AkihiroSuda_/status/955698849560997888 target=_blank rel="noopener noreffer">BuildKit</a>（<code>docker build</code>的后端）、<a href=https://github.com/AkihiroSuda/docker/commit/588a4e91fc8cb99af040dcde795ba6722a162127 target=_blank rel="noopener noreffer">Docker</a>、<a href=https://github.com/containers/podman/commit/19f5a504ffb1470991f331db412be456e41caab5 target=_blank rel="noopener noreffer">Podman</a>。<a href=https://github.com/rootless-containers/slirp4netns target=_blank rel="noopener noreffer">slirp4netns</a> 被我自己创建，以通过转换以太网来允许 SETUID-less 网络数据包发送至非特权套接字系统调用。</li><li><strong>2019</strong>：Docker <a href=https://docs.docker.com/engine/release-notes/19.03/#19030 target=_blank rel="noopener noreffer">v19.03</a> 发布，对 rootless 容器提供实验性支持。Podman <a href=https://github.com/containers/podman/releases/tag/v1.1.0 target=_blank rel="noopener noreffer">v1.1</a> 也在今年发布，具有相同的功能，略领先于 Docker v19.03。</li><li><strong>2020</strong>：Docker <a href=/nttlabs/docker-20-10-59cc4bd59d37 rel>v20.10</a> 发布，rootless 容器全面可用。</li></ul><p><img class=lazyload src=/svg/loading.min.svg data-src=https://miro.medium.com/1*41peAl7SSpEZqQGpkRmmUw.png data-srcset="https://miro.medium.com/1*41peAl7SSpEZqQGpkRmmUw.png, https://miro.medium.com/1*41peAl7SSpEZqQGpkRmmUw.png 1.5x, https://miro.medium.com/1*41peAl7SSpEZqQGpkRmmUw.png 2x" data-sizes=auto alt=https://miro.medium.com/1*41peAl7SSpEZqQGpkRmmUw.png title=https://miro.medium.com/1*41peAl7SSpEZqQGpkRmmUw.png></p><p>从 2020 年到 2022 年，我们还致力于 <a href=https://github.com/rootless-containers/bypass4netns target=_blank rel="noopener noreffer">bypass4netns</a>，通过在容器内挂钩套接字文件描述符并在容器外重建它们来消除 slirp4netns 的开销。所实现的吞吐量甚至比 “rootful” 容器更快。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://miro.medium.com/1*h5_2ZjoGixRrOfZdOu8ysA.png data-srcset="https://miro.medium.com/1*h5_2ZjoGixRrOfZdOu8ysA.png, https://miro.medium.com/1*h5_2ZjoGixRrOfZdOu8ysA.png 1.5x, https://miro.medium.com/1*h5_2ZjoGixRrOfZdOu8ysA.png 2x" data-sizes=auto alt=https://miro.medium.com/1*h5_2ZjoGixRrOfZdOu8ysA.png title=https://miro.medium.com/1*h5_2ZjoGixRrOfZdOu8ysA.png></p><p>Rootless 容器已经成功普及，但也有人对 rootless 容器提出批评。特别是，是否应该允许非root用户创建运行无根容器所需的用户命名空间是有争议的。对于容器用户，我的回答是“是”，因为无根容器至少比以根身份运行所有内容要安全得多。但是，对于不使用容器的人，我宁愿回答“否”，因为用户命名空间也可能是攻击面。例如，<a href=https://www.tarlogic.com/blog/cve-2023-32233-vulnerability/ target=_blank rel="noopener noreffer"><strong>CVE-2023–32233 漏洞</strong>：“Privilege escalation in Linux Kernel due to a Netfilter nf_tables vulnerability.”</a>。</p><p>社区已经在寻求解决这一困境的方法。Ubuntu（自 13.10 起）和 Debian 提供了一个 sysctl 设置 <code>kernel.unprivileged_userns_clone=&lt;bool></code> 来指定是否允许或禁止创建非特权用户命名空间。然而，他们的<a href="https://git.launchpad.net/~ubuntu-kernel/ubuntu/+source/linux/+git/jammy/commit/kernel/user_namespace.c?id=342276469714b5a307745d1a3b9bdc146c804e4e" target=_blank rel="noopener noreffer">补丁</a>并没有合并到上游 Linux 内核中。</p><p>相反，上游内核在 Linux <a href=https://github.com/torvalds/linux/commit/7cd4c5c2101cb092db00f61f69d24380cf7a0ee8 target=_blank rel="noopener noreffer">v6.1</a> (2022) 中引入了新的 LSM（Linux 安全模块）钩子 <code>userns_create</code> ，以便 LSM 可以动态决定是否允许或禁止创建用户命名空间。该钩子可从 <a href=https://docs.kernel.org/bpf/prog_lsm.html target=_blank rel="noopener noreffer">eBPF (<code>bpf_program__atttach_lsm()</code>)</a> 调用，因此预计将有一个不依赖于 AppArmor 或 SELinux 的细粒度且非特定于发行版的旋钮。然而，eBPF + LSM 的用户空间实用程序尚未成熟，无法为此提供良好的用户体验。</p><h3 id=更多-lsm>更多 LSM</h3><p><a href=https://landlock.io/ target=_blank rel="noopener noreffer">Landlock</a> LSM 已合并到 Linux <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=17ae69aba89dbfa2139b7f8024b757ab3cc42f59" target=_blank rel="noopener noreffer">v5.13</a> (2021) 中。Landlock 与 AppArmor 类似，它通过路径（<code>LANDLOCK_ACCESS_FS_EXECUTE</code>、<code>LANDLOCK_ACCESS_FS_READ_FILE</code> 等）限制文件访问，但 Landlock 不需要 root 权限来设置新配置文件。Landlock 也与 OpenBSD 的 <a href=https://man.openbsd.org/pledge.2 target=_blank rel="noopener noreffer"><code>promise(2)</code></a> 非常相似。</p><p>Landlock 仍然 <a href=https://github.com/opencontainers/runtime-spec/pull/1111 target=_blank rel="noopener noreffer">不受 OCI Runtime Spec 支持</a>，但我猜它可以包含在 OCI Runtime Spec v1.2 中。</p><h3 id=kata-containers>Kata Containers</h3><p>正如我在第一部分中提到的，“容器”并不是一个定义明确的术语。任何东西只要能与现有的容器生态系统提供良好的兼容性，就可以称为“容器”。</p><p><a href=https://katacontainers.io/ target=_blank rel="noopener noreffer">Kata Containers</a> (2017) 就是这样一种“容器”，实际上并不是狭义上的容器。Kata 容器实际上是虚拟机，但支持 OCI 运行时规范。Kata 容器比 runc 容器安全得多，但是它们在性能方面存在缺陷，并且在不支持嵌套虚拟化的典型非裸机 IaaS 实例上无法正常工作。</p><p>Kata Containers 作为一个 containerd 运行时插件，并接收与 runc 容器相同的镜像和运行时配置。它的用户体验与 runc 容器几乎没有区别。</p><h3 id=gvisor>gVisor</h3><p><a href=https://gvisor.dev/ target=_blank rel="noopener noreffer">gVisor</a> (2018) 是另一个奇特的容器运行时。gVisor 捕获系统调用并在 Linux 兼容的用户模式内核中执行它们以减轻攻击。gVisor 目前具有 <a href=https://gvisor.dev/docs/architecture_guide/platforms/ target=_blank rel="noopener noreffer">三种</a> 捕获系统调用的模式：</p><ul><li><strong>KVM 模式</strong>：很少使用，但是裸机主机的最佳选择</li><li><strong>ptrace 模式</strong>：最常见的选项，但速度较慢</li><li><strong>SIGSYS trap 模式</strong>（自 2023 年起）：预计最终取代 ptrace 模式</li></ul><p>gVisor 已用于 Google 的多个产品中，包括 Google Cloud Run。然而，Google Cloud Run 已于 2023 年从 gVisor 转向 microVM。这意味着 gVisor 的性能和兼容性问题对于他们的业务来说是不可忽视的。</p><h3 id=webassembly>WebAssembly</h3><p><a href=https://webassembly.org/ target=_blank rel="noopener noreffer">WebAssembly (WASM) </a>是一种独立于平台的字节代码格式，最初于 <a href=https://blog.mozilla.org/luke/2015/06/17/webassembly/ target=_blank rel="noopener noreffer">2015 年</a> 为 Web 浏览器设计。WebAssembly 与 Java applet (1995) 有点相似，但它更注重可移植性和安全性。WebAssembly 的一个有趣的方面是它将代码地址空间与数据地址空间分开；没有像 <code>JMP &lt;immediate></code> 和 <code>JMP *&lt;reg></code> 这样的指令。它仅支持 <a href=https://webassembly.github.io/spec/core/syntax/instructions.html#control-instructions target=_blank rel="noopener noreffer">跳转到在编译时解析的标签</a>。这种设计减少了任意代码执行错误，尽管它也牺牲了 JIT 将其他字节代码格式编译为 WebAssembly 的可行性。</p><p>WebAssembly 作为容器的潜在替代品也受到关注。为了在浏览器之外运行 WebAssembly，<a href=https://wasi.dev/ target=_blank rel="noopener noreffer">WASI</a>（WebAssembly 系统接口）于 2019 年提出，提供低级 API（例如 <a href=https://github.com/WebAssembly/WASI/blob/main/legacy/preview1/docs.md target=_blank rel="noopener noreffer"><code>fd_read()</code>、<code>fd_write()</code>、<code>sock_recv()</code>、<code>sock_send()</code></a>）可用于在其上实现类似 POSIX 的层。containerd 在 2022 年添加了 <a href=https://github.com/containerd/runwasi target=_blank rel="noopener noreffer">runWASI</a> 插件，将 WASI 工作负载视为容器。</p><p>2023年，<a href=https://wasix.org/docs/api-reference target=_blank rel="noopener noreffer">WASIX</a> 被提议扩展 WASI 以提供更方便（也有些争议）的功能：</p><ul><li><strong>线程</strong>：<a href=https://wasix.org/docs/api-reference/wasix/thread_spawn target=_blank rel="noopener noreffer"><code>thread_spawn()</code></a>, <a href=https://wasix.org/docs/api-reference/wasix/thread_join target=_blank rel="noopener noreffer"><code>thread_join()</code></a>`, &mldr;</li><li><strong>进程：</strong> <a href=https://wasix.org/docs/api-reference/wasix/proc_fork target=_blank rel="noopener noreffer"><code>proc_fork()</code></a>, <a href=https://wasix.org/docs/api-reference/wasix/proc_exec target=_blank rel="noopener noreffer"><code>proc_exec()</code></a>, &mldr;</li><li><strong>套接字</strong>：<a href=https://wasix.org/docs/api-reference/wasix/sock_listen target=_blank rel="noopener noreffer"><code>sock_listen()</code></a>, <a href=https://wasix.org/docs/api-reference/wasix/sock_connect target=_blank rel="noopener noreffer"><code>sock_connect()</code></a>, &mldr;</li></ul><p>最终，这些技术可能会取代很大一部分（但不是 100%）的容器。Docker 的创始人 Solomon Hykes 表示：“<em>如果 WASM+WASI 在 2008 年就存在，我们就不需要创建 Docker 了</em> ”。</p><h2 id=总结>总结</h2><ul><li>容器比虚拟机更高效，但安全性往往也更低。人们正在引入许多安全技术来强化容器。（用户命名空间、无根容器、Linux 安全模块……）</li><li>Docker 的替代品不断涌现（containerd、CRI-O、Podman、nerdctl、Finch 等），但 Docker 并没有消失。</li><li>“Non-container” 容器也是趋势。（<strong>Kata</strong>：基于 VM，<strong>gVisor</strong>：用户模式内核，<strong>runWASI</strong>：WebAssembly，&mldr;）</li></ul><p>下图显示了著名的运行时的概况。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://miro.medium.com/1*_x0ujgxNUyzBIco_J6O-mw.png data-srcset="https://miro.medium.com/1*_x0ujgxNUyzBIco_J6O-mw.png, https://miro.medium.com/1*_x0ujgxNUyzBIco_J6O-mw.png 1.5x, https://miro.medium.com/1*_x0ujgxNUyzBIco_J6O-mw.png 2x" data-sizes=auto alt=https://miro.medium.com/1*_x0ujgxNUyzBIco_J6O-mw.png title=https://miro.medium.com/1*_x0ujgxNUyzBIco_J6O-mw.png></p><p>更多内容另请参阅 <a href=https://github.com/AkihiroSuda/AkihiroSuda/raw/5d9f0b1cd9b8c37cb1951768a3bebdb08a3a469e/slides/2023/20230615%20%5BKyoto%20University%5D%20The%20internals%20and%20the%20latest%20trends%20of%20container%20runtimes.pdf target=_blank rel="noopener noreffer">PPT</a> 的其余部分，了解本文中无法涵盖的其他主题。</p><hr><p><em>文本翻译自: <a href=https://medium.com/nttlabs/the-internals-and-the-latest-trends-of-container-runtimes-2023-22aa111d7a93 target=_blank rel="noopener noreffer">https://medium.com/nttlabs/the-internals-and-the-latest-trends-of-container-runtimes-2023-22aa111d7a93</a></em></p><hr></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2023-07-11</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://rifewang.github.io/the-internals-and-the-latest-trends-of-container-runtimes/ data-title=容器运行时的内部结构和最新趋势（2023） data-hashtags=Container,Docker,Kubernetes><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://rifewang.github.io/the-internals-and-the-latest-trends-of-container-runtimes/ data-hashtag=Container><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=https://rifewang.github.io/the-internals-and-the-latest-trends-of-container-runtimes/ data-title=容器运行时的内部结构和最新趋势（2023）><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=https://rifewang.github.io/the-internals-and-the-latest-trends-of-container-runtimes/ data-title=容器运行时的内部结构和最新趋势（2023）><i data-svg-src=/lib/simple-icons/icons/line.min.svg aria-hidden=true></i></a><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=https://rifewang.github.io/the-internals-and-the-latest-trends-of-container-runtimes/ data-title=容器运行时的内部结构和最新趋势（2023）><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/container/>Container</a>,&nbsp;<a href=/tags/docker/>Docker</a>,&nbsp;<a href=/tags/kubernetes/>Kubernetes</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/k8s-memory-management-for-java-applications/ class=prev rel=prev title="Java 应用程序在 Kubernetes 上棘手的内存管理"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>Java 应用程序在 Kubernetes 上棘手的内存管理</a>
<a href=/k8s-crd-operator/ class=next rel=next title="Kubernetes CRD & Operator 简介">Kubernetes CRD & Operator 简介<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2017 - 2024</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>凌虚</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=/lib/katex/katex.min.css><script type=text/javascript src=/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/lib/lunr/lunr.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/sharer/sharer.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/contrib/auto-render.min.js></script><script type=text/javascript src=/lib/katex/contrib/copy-tex.min.js></script><script type=text/javascript src=/lib/katex/contrib/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrIndexURL:"/index.json",maxResultLength:10,noResultsFound:"No results found",snippetLength:50,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>