<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Translations on 凌虚 Blog</title><link>https://rifewang.github.io/translation/</link><description>Recent content in Translations on 凌虚 Blog</description><generator>Hugo</generator><language>zh-CN</language><copyright>Attribution-NonCommercial 4.0 International (CC BY-NC 4.0)</copyright><lastBuildDate>Tue, 21 Feb 2023 17:49:24 +0800</lastBuildDate><atom:link href="https://rifewang.github.io/translation/index.xml" rel="self" type="application/rss+xml"/><item><title>web 安全之 Server-side template injection</title><link>https://rifewang.github.io/translation/web-security/server-side-template-injection/server-side-template-injection/</link><pubDate>Wed, 10 Mar 2021 01:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/server-side-template-injection/server-side-template-injection/</guid><description>&lt;h1 id="server-side-template-injection">Server-side template injection&lt;/h1>
&lt;p>在本节中，我们将介绍什么是服务端模板注入，并概述利用此漏洞的基本方法，同时也将提供一些避免此漏洞的建议。&lt;/p>
&lt;h2 id="什么是服务端模板注入">什么是服务端模板注入&lt;/h2>
&lt;p>服务端模板注入是指攻击者能够利用模板自身语法将恶意负载注入模板，然后在服务端执行。&lt;/p></description></item><item><title>Exploiting server-side template injection vulnerabilities</title><link>https://rifewang.github.io/translation/web-security/server-side-template-injection/exploiting-server-side-template-injection-vulnerabilities/</link><pubDate>Wed, 10 Mar 2021 00:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/server-side-template-injection/exploiting-server-side-template-injection-vulnerabilities/</guid><description>&lt;h1 id="利用服务端模板注入漏洞">利用服务端模板注入漏洞&lt;/h1>
&lt;p>在本节中，我们将更仔细地了解一些典型的服务端模板注入漏洞，并演示如何利用之前归纳的方法。通过付诸实践，你可以潜在地发现和利用各种不同的服务端模板注入漏洞。&lt;/p></description></item><item><title>web 安全之 CSRF</title><link>https://rifewang.github.io/translation/web-security/csrf/csrf/</link><pubDate>Tue, 09 Mar 2021 01:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/csrf/csrf/</guid><description>&lt;h1 id="cross-site-request-forgery-csrf">Cross-site request forgery (CSRF)&lt;/h1>
&lt;p>在本节中，我们将解释什么是跨站请求伪造，并描述一些常见的 &lt;code>CSRF&lt;/code> 漏洞示例，同时说明如何防御 &lt;code>CSRF&lt;/code> 攻击。&lt;/p>
&lt;h2 id="什么是-csrf">什么是 CSRF&lt;/h2>
&lt;p>跨站请求伪造（&lt;code>CSRF&lt;/code>）是一种 web 安全漏洞，它允许攻击者诱使用户执行他们不想执行的操作。攻击者进行 &lt;code>CSRF&lt;/code> 能够部分规避同源策略。&lt;/p></description></item><item><title>CSRF tokens</title><link>https://rifewang.github.io/translation/web-security/csrf/csrf-tokens/</link><pubDate>Tue, 09 Mar 2021 00:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/csrf/csrf-tokens/</guid><description>&lt;h1 id="csrf-tokens">CSRF tokens&lt;/h1>
&lt;p>在本节中，我们将解释什么是 CSRF token，它们是如何防御的 CSRF 攻击，以及如何生成和验证CSRF token 。&lt;/p>
&lt;h2 id="什么是-csrf-token">什么是 CSRF token&lt;/h2>
&lt;p>CSRF token 是一个唯一的、秘密的、不可预测的值，它由服务端应用程序生成，并以这种方式传输到客户端，使得它包含在客户端发出的后续 HTTP 请求中。当发出后续请求时，服务端应用程序将验证请求是否包含预期的 token ，并在 token 丢失或无效时拒绝该请求。&lt;/p></description></item><item><title>SameSite cookies</title><link>https://rifewang.github.io/translation/web-security/csrf/samesite-cookies/</link><pubDate>Tue, 09 Mar 2021 00:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/csrf/samesite-cookies/</guid><description>&lt;h1 id="samesite-cookies">SameSite cookies&lt;/h1>
&lt;p>某些网站使用 SameSite cookies 防御 &lt;code>CSRF&lt;/code> 攻击。&lt;/p>
&lt;p>这个 &lt;code>SameSite&lt;/code> 属性可用于控制是否以及如何在跨站请求中提交 cookie 。通过设置会话 cookie 的属性，应用程序可以防止浏览器默认自动向请求添加 cookie 的行为，而不管cookie 来自何处。&lt;/p></description></item><item><title>XSS vs CSRF</title><link>https://rifewang.github.io/translation/web-security/csrf/xss-vs-csrf/</link><pubDate>Tue, 09 Mar 2021 00:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/csrf/xss-vs-csrf/</guid><description>&lt;h1 id="xss-vs-csrf">XSS vs CSRF&lt;/h1>
&lt;p>在本节中，我们将解释 &lt;code>XSS&lt;/code> 和 &lt;code>CSRF&lt;/code> 之间的区别，并讨论 &lt;code>CSRF token&lt;/code> 是否有助于防御 &lt;code>XSS&lt;/code> 攻击。&lt;/p>
&lt;h2 id="xss-和-csrf-之间有啥区别">XSS 和 CSRF 之间有啥区别&lt;/h2>
&lt;p>跨站脚本攻击 &lt;code>XSS&lt;/code> 允许攻击者在受害者用户的浏览器中执行任意 JavaScript 。&lt;/p></description></item><item><title>web 安全之 DOM-based vulnerabilities</title><link>https://rifewang.github.io/translation/web-security/dom-based/dom-based-vulnerabilities/</link><pubDate>Sun, 07 Mar 2021 01:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/dom-based/dom-based-vulnerabilities/</guid><description>&lt;h1 id="dom-based-vulnerabilities">DOM-based vulnerabilities&lt;/h1>
&lt;p>在本节中，我们将描述什么是 &lt;code>DOM&lt;/code> ，解释对 &lt;code>DOM&lt;/code> 数据的不安全处理是如何引入漏洞的，并建议如何在您的网站上防止基于 &lt;code>DOM&lt;/code> 的漏洞。&lt;/p>
&lt;h2 id="什么是-dom">什么是 DOM&lt;/h2>
&lt;p>Document Object Model（&lt;code>DOM&lt;/code>）文档对象模型是 web 浏览器对页面上元素的层次表示。网站可以使用 JavaScript 来操作 &lt;code>DOM&lt;/code> 的节点和对象，以及它们的属性。&lt;code>DOM&lt;/code> 操作本身不是问题，事实上，它也是现代网站中不可或缺的一部分。然而，不安全地处理数据的 JavaScript 可能会引发各种攻击。当网站包含的 JavaScript 接受攻击者可控制的值（称为 source 源）并将其传递给一个危险函数（称为 sink 接收器）时，就会出现基于 &lt;code>DOM&lt;/code> 的漏洞。&lt;/p></description></item><item><title>DOM clobbering</title><link>https://rifewang.github.io/translation/web-security/dom-based/dom-clobbering/</link><pubDate>Sun, 07 Mar 2021 00:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/dom-based/dom-clobbering/</guid><description>&lt;h1 id="dom-clobbering">DOM clobbering&lt;/h1>
&lt;p>在本节中，我们将描述什么是 DOM clobbing ，演示如何使用 clobbing 技术来利用 DOM 漏洞，并提出防御 DOM clobbing 攻击的方法。&lt;/p>
&lt;h2 id="什么是-dom-clobbering">什么是 DOM clobbering&lt;/h2>
&lt;p>DOM clobbering 是一种将 HTML 注入页面以操作 DOM 并最终改变页面上 JavaScript 行为的技术。在无法使用 XSS ，但是可以控制页面上 HTML 白名单属性如 id 或 name 时，DOM clobbering 就特别有用。DOM clobbering 最常见的形式是使用 anchor 元素覆盖全局变量，然后该变量将会被应用程序以不安全的方式使用，例如生成动态脚本 URL 。&lt;/p></description></item><item><title>web 安全之 HTTP Host header attacks</title><link>https://rifewang.github.io/translation/web-security/http-host-header-attacks/http-host-header-attacks/</link><pubDate>Sat, 06 Mar 2021 01:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/http-host-header-attacks/http-host-header-attacks/</guid><description>&lt;h1 id="http-host-header-attacks">HTTP Host header attacks&lt;/h1>
&lt;p>在本节中，我们将讨论错误的配置和有缺陷的业务逻辑如何通过 HTTP Host 头使网站遭受各种攻击。我们将概述识别易受 HTTP Host 头攻击的网站的高级方法，并演示如何利用此方法。最后，我们将提供一些有关如何保护自己网站的一般建议。&lt;/p></description></item><item><title>Exploiting HTTP Host header vulnerabilities</title><link>https://rifewang.github.io/translation/web-security/http-host-header-attacks/exploiting-http-host-header-vulnerabilities/</link><pubDate>Sat, 06 Mar 2021 00:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/http-host-header-attacks/exploiting-http-host-header-vulnerabilities/</guid><description>&lt;h1 id="如何识别和利用-http-host-头漏洞">如何识别和利用 HTTP Host 头漏洞&lt;/h1>
&lt;p>在本节中，我们将更仔细地了解如何识别网站是否存在 HTTP Host 头漏洞。然后，我们将提供一些示例，说明如何利用此漏洞。&lt;/p>
&lt;h2 id="如何使用-http-host-头测试漏洞">如何使用 HTTP Host 头测试漏洞&lt;/h2>
&lt;p>要测试网站是否易受 HTTP Host 攻击，你需要一个拦截代理（如 Burp proxy ）和手动测试工具（如 Burp Repeater 和 Burp intruiter ）。&lt;/p></description></item><item><title>Password reset poisoning</title><link>https://rifewang.github.io/translation/web-security/http-host-header-attacks/password-reset-poisoning/</link><pubDate>Sat, 06 Mar 2021 00:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/http-host-header-attacks/password-reset-poisoning/</guid><description>&lt;h1 id="password-reset-poisoning">Password reset poisoning&lt;/h1>
&lt;p>密码重置中毒是一种技术，攻击者可以利用该技术来操纵易受攻击的网站，以生成指向其控制下的域的密码重置链接。这种行为可以用来窃取重置任意用户密码所需的秘密令牌，并最终危害他们的帐户。&lt;/p></description></item><item><title>web 安全之 Clickjacking</title><link>https://rifewang.github.io/translation/web-security/clickjacking/clickjacking/</link><pubDate>Fri, 05 Mar 2021 00:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/clickjacking/clickjacking/</guid><description>&lt;h1 id="clickjacking--ui-redressing-">Clickjacking ( UI redressing )&lt;/h1>
&lt;p>在本节中，我们将解释什么是 clickjacking 点击劫持，并描述常见的点击劫持攻击示例，以及讨论如何防御这些攻击。&lt;/p>
&lt;h2 id="什么是点击劫持">什么是点击劫持&lt;/h2>
&lt;p>点击劫持是一种基于界面的攻击，通过诱导用户点击钓鱼网站中的被隐藏了的可操作的危险内容。&lt;/p></description></item><item><title>web 安全之 HTTP request smuggling</title><link>https://rifewang.github.io/translation/web-security/request-smuggling/http-request-smuggling/</link><pubDate>Thu, 04 Mar 2021 01:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/request-smuggling/http-request-smuggling/</guid><description>&lt;h1 id="http-request-smuggling">HTTP request smuggling&lt;/h1>
&lt;p>在本节中，我们将解释什么是 HTTP 请求走私，并描述常见的请求走私漏洞是如何产生的。&lt;/p>
&lt;h2 id="什么是-http-请求走私">什么是 HTTP 请求走私&lt;/h2>
&lt;p>HTTP 请求走私是一种干扰网站处理多个 HTTP 请求序列的技术。请求走私漏洞危害很大，它使攻击者可以绕过安全控制，未经授权访问敏感数据并直接危害其他应用程序用户。&lt;/p></description></item><item><title>Exploiting request smuggling</title><link>https://rifewang.github.io/translation/web-security/request-smuggling/exploiting-request-smuggling/</link><pubDate>Thu, 04 Mar 2021 00:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/request-smuggling/exploiting-request-smuggling/</guid><description>&lt;h1 id="利用-http-请求走私漏洞">利用 HTTP 请求走私漏洞&lt;/h1>
&lt;p>在本节中，我们将描述 HTTP 请求走私漏洞的几种利用方法，这也取决于应用程序的预期功能和其他行为。&lt;/p>
&lt;h2 id="利用-http-请求走私漏洞绕过前端服务器转发服务安全控制">利用 HTTP 请求走私漏洞绕过前端服务器（转发服务）安全控制&lt;/h2>
&lt;p>在某些应用程序中，前端服务器（转发服务）不仅用来转发请求，也用来实现了一些安全控制，以决定单个请求能否被转发到后端处理，而后端服务认为接受到的所有请求都已经通过了安全验证。&lt;/p></description></item><item><title>Finding request smuggling</title><link>https://rifewang.github.io/translation/web-security/request-smuggling/finding-request-smuggling/</link><pubDate>Thu, 04 Mar 2021 00:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/request-smuggling/finding-request-smuggling/</guid><description>&lt;h1 id="查找-http-请求走私漏洞">查找 HTTP 请求走私漏洞&lt;/h1>
&lt;p>在本节中，我们将介绍用于查找 HTTP 请求走私漏洞的不同技术。&lt;/p>
&lt;h2 id="计时技术">计时技术&lt;/h2>
&lt;p>检测 HTTP 请求走私漏洞的最普遍有效的方法就是计时技术。发送请求，如果存在漏洞，则应用程序的响应会出现时间延迟。&lt;/p></description></item><item><title>web 安全之 OS command injection</title><link>https://rifewang.github.io/translation/web-security/command-injection/os-command-injection/</link><pubDate>Wed, 03 Mar 2021 00:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/command-injection/os-command-injection/</guid><description>&lt;h1 id="os-command-injection">OS command injection&lt;/h1>
&lt;p>在本节中，我们将解释什么是操作系统命令注入，描述如何检测和利用此漏洞，为不同的操作系统阐明一些有用的命令和技术，并总结如何防止操作系统命令注入。&lt;/p></description></item><item><title>web 安全之 Server-side request forgery</title><link>https://rifewang.github.io/translation/web-security/ssrf/ssrf/</link><pubDate>Mon, 01 Mar 2021 01:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/ssrf/ssrf/</guid><description>&lt;h1 id="server-side-request-forgery-ssrf">Server-side request forgery (SSRF)&lt;/h1>
&lt;p>在本节中，我们将解释 server-side request forgery（服务端请求伪造）是什么，并描述一些常见的示例，以及解释如何发现和利用各种 &lt;code>SSRF&lt;/code> 漏洞。&lt;/p>
&lt;h2 id="ssrf-是什么">SSRF 是什么&lt;/h2>
&lt;p>&lt;code>SSRF&lt;/code> 服务端请求伪造是一个 web 漏洞，它允许攻击者诱导服务端程序向攻击者选择的任何地址发起 HTTP 请求。&lt;/p></description></item><item><title>Blind SSRF</title><link>https://rifewang.github.io/translation/web-security/ssrf/blind-ssrf/</link><pubDate>Mon, 01 Mar 2021 00:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/ssrf/blind-ssrf/</guid><description>&lt;h1 id="blind-ssrf">Blind SSRF&lt;/h1>
&lt;p>在本节中，我们将解释什么是不可见的服务端请求伪造，并描述一些常见的不可见 &lt;code>SSRF&lt;/code> 示例，以及解释如何发现和利用不可见 &lt;code>SSRF&lt;/code> 漏洞。&lt;/p>
&lt;h2 id="什么是不可见-ssrf">什么是不可见 SSRF&lt;/h2>
&lt;p>不可见 &lt;code>SSRF&lt;/code> 漏洞是指，可以诱导应用程序向提供的 URL 发出后端 HTTP 请求，但来自后端请求的响应没有在应用程序的前端响应中返回。&lt;/p></description></item><item><title>web 安全之 Directory traversal</title><link>https://rifewang.github.io/translation/web-security/directory-traversal/directory-traversal/</link><pubDate>Mon, 01 Mar 2021 00:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/directory-traversal/directory-traversal/</guid><description>&lt;h1 id="directory-traversal---目录遍历">Directory traversal - 目录遍历&lt;/h1>
&lt;p>在本节中，我们将介绍什么是目录遍历，描述如何执行路径遍历攻击和绕过常见障碍，并阐明如何防止路径遍历漏洞。&lt;/p>
&lt;p>&lt;img
 class="lazyload"
 src="https://rifewang.github.io/svg/loading.min.svg"
 data-src="https://raw.githubusercontent.com/RifeWang/images/master/web-security/directory-traversal.png"
 data-srcset="https://raw.githubusercontent.com/RifeWang/images/master/web-security/directory-traversal.png, https://raw.githubusercontent.com/RifeWang/images/master/web-security/directory-traversal.png 1.5x, https://raw.githubusercontent.com/RifeWang/images/master/web-security/directory-traversal.png 2x"
 data-sizes="auto"
 alt="https://raw.githubusercontent.com/RifeWang/images/master/web-security/directory-traversal.png"
 title="directory traversal" />&lt;/p>
&lt;h2 id="什么是目录遍历">什么是目录遍历？&lt;/h2>
&lt;p>目录遍历（也称为文件路径遍历）是一个 web 安全漏洞，此漏洞使攻击者能够读取运行应用程序的服务器上的任意文件。这可能包括应用程序代码和数据、后端系统的凭据以及操作系统相关敏感文件。在某些情况下，攻击者可能能够对服务器上的任意文件进行写入，从而允许他们修改应用程序数据或行为，并最终完全控制服务器。&lt;/p></description></item><item><title>web 安全之 CORS</title><link>https://rifewang.github.io/translation/web-security/cors/cors/</link><pubDate>Sun, 28 Feb 2021 01:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/cors/cors/</guid><description>&lt;h1 id="cross-origin-resource-sharing-cors">Cross-origin resource sharing (CORS)&lt;/h1>
&lt;p>在本节中，我们将解释什么是跨域资源共享（&lt;code>CORS&lt;/code>），并描述一些基于 &lt;code>CORS&lt;/code> 的常见攻击示例，以及讨论如何防御这些攻击。&lt;/p>
&lt;h2 id="cors跨域资源共享是什么">CORS（跨域资源共享）是什么？&lt;/h2>
&lt;p>&lt;code>CORS&lt;/code>（跨域资源共享）是一种浏览器机制，它允许对位于当前访问域之外的资源进行受控访问。它扩展并增加了同源策略的灵活性。然而，如果一个网站的 &lt;code>CORS&lt;/code> 策略配置和实现不当，它也可能导致基于跨域的攻击。&lt;code>CORS&lt;/code> 不是针对跨源攻击（例如跨站请求伪造 &lt;code>CSRF&lt;/code>）的保护。&lt;/p></description></item><item><title>CORS 和 Access-Control-Allow-Origin 响应头</title><link>https://rifewang.github.io/translation/web-security/cors/access-control-allow-origin/</link><pubDate>Sun, 28 Feb 2021 00:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/cors/access-control-allow-origin/</guid><description>&lt;h1 id="cors-和-access-control-allow-origin-响应头">CORS 和 Access-Control-Allow-Origin 响应头&lt;/h1>
&lt;p>在本节中，我们将解释有关 &lt;code>CORS&lt;/code> 的 &lt;code>Access-Control-Allow-Origin&lt;/code> 响应头，以及后者如何构成 &lt;code>CORS&lt;/code> 实现的一部分。&lt;/p>
&lt;p>&lt;code>CORS&lt;/code> 通过使用一组 HTTP 头部提供了同源策略的可控制放宽，浏览器允许访问基于这些头部的跨域请求的响应。&lt;/p></description></item><item><title>Same-origin policy (SOP)</title><link>https://rifewang.github.io/translation/web-security/cors/same-origin-policy/</link><pubDate>Sun, 28 Feb 2021 00:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/cors/same-origin-policy/</guid><description>&lt;h1 id="same-origin-policy-sop---同源策略">Same-origin policy (SOP) - 同源策略&lt;/h1>
&lt;p>在本节中，我们将解释什么是同源策略以及它是如何实现的。&lt;/p>
&lt;h2 id="什么是同源策略">什么是同源策略？&lt;/h2>
&lt;p>同源策略是一种旨在防止网站互相攻击的 web 浏览器的安全机制。&lt;/p>
&lt;p>同源策略限制一个源上的脚本访问另一个源的数据。&lt;/p></description></item></channel></rss>