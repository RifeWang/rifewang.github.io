<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Translations on 凌虚 Blog</title><link>https://rifewang.github.io/translation/</link><description>Recent content in Translations on 凌虚 Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 09 Mar 2021 01:00:00 +0800</lastBuildDate><atom:link href="https://rifewang.github.io/translation/index.xml" rel="self" type="application/rss+xml"/><item><title>web 安全之 CSRF</title><link>https://rifewang.github.io/translation/web-security/csrf/csrf/</link><pubDate>Tue, 09 Mar 2021 01:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/csrf/csrf/</guid><description>Cross-site request forgery (CSRF) Link to heading 在本节中，我们将解释什么是跨站请求伪造，并描述一些常见的 CSRF 漏洞示例，同时说明如何防御 CSRF 攻击。
什么是 CSRF Link to heading 跨站请求伪造（CSRF）是一种 web 安全漏洞，它允许攻击者诱使用户执行他们不想执行的操作。攻击者进行 CSRF 能够部分规避同源策略。
CSRF 攻击能造成什么影响 Link to heading 在成功的 CSRF 攻击中，攻击者会使受害用户无意中执行某个操作。例如，这可能是更改他们帐户上的电子邮件地址、更改密码或进行资金转账。根据操作的性质，攻击者可能能够完全控制用户的帐户。如果受害用户在应用程序中具有特权角色，则攻击者可能能够完全控制应用程序的所有数据和功能。
CSRF 是如何工作的 Link to heading 要使 CSRF 攻击成为可能，必须具备三个关键条件：
相关的动作。攻击者有理由诱使应用程序中发生某种动作。这可能是特权操作（例如修改其他用户的权限），也可能是针对用户特定数据的任何操作（例如更改用户自己的密码）。 基于 Cookie 的会话处理。执行该操作涉及发出一个或多个 HTTP 请求，应用程序仅依赖会话cookie 来标识发出请求的用户。没有其他机制用于跟踪会话或验证用户请求。 没有不可预测的请求参数。执行该操作的请求不包含攻击者无法确定或猜测其值的任何参数。例如，当导致用户更改密码时，如果攻击者需要知道现有密码的值，则该功能不会受到攻击。 假设应用程序包含一个允许用户更改其邮箱地址的功能。当用户执行此操作时，会发出如下 HTTP 请求：
POST /email/change HTTP/1.1 Host: vulnerable-website.com Content-Type: application/x-www-form-urlencoded Content-Length: 30 Cookie: session=yvthwsztyeQkAPzeQ5gHgTvlyxHfsAfE email=wiener@normal-user.com 这个例子符合 CSRF 要求的条件：
更改用户帐户上的邮箱地址的操作会引起攻击者的兴趣。执行此操作后，攻击者通常能够触发密码重置并完全控制用户的帐户。 应用程序使用会话 cookie 来标识发出请求的用户。没有其他标记或机制来跟踪用户会话。 攻击者可以轻松确定执行操作所需的请求参数的值。 具备这些条件后，攻击者可以构建包含以下 HTML 的网页：</description></item><item><title>CSRF tokens</title><link>https://rifewang.github.io/translation/web-security/csrf/csrf-tokens/</link><pubDate>Tue, 09 Mar 2021 00:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/csrf/csrf-tokens/</guid><description>CSRF tokens Link to heading 在本节中，我们将解释什么是 CSRF token，它们是如何防御的 CSRF 攻击，以及如何生成和验证CSRF token 。
什么是 CSRF token Link to heading CSRF token 是一个唯一的、秘密的、不可预测的值，它由服务端应用程序生成，并以这种方式传输到客户端，使得它包含在客户端发出的后续 HTTP 请求中。当发出后续请求时，服务端应用程序将验证请求是否包含预期的 token ，并在 token 丢失或无效时拒绝该请求。
由于攻击者无法确定或预测用户的 CSRF token 的值，因此他们无法构造出一个应用程序验证所需全部参数的请求。所以 CSRF token 可以防止 CSRF 攻击。
CSRF token 应该如何生成 Link to heading CSRF token 应该包含显著的熵，并且具有很强的不可预测性，其通常与会话令牌具有相同的特性。
您应该使用加密强度伪随机数生成器（PRNG），该生成器附带创建时的时间戳以及静态密码。
如果您需要 PRNG 强度之外的进一步保证，可以通过将其输出与某些特定于用户的熵连接来生成单独的令牌，并对整个结构进行强哈希。这给试图分析令牌的攻击者带来了额外的障碍。
如何传输 CSRF token Link to heading CSRF token 应被视为机密，并在其整个生命周期中以安全的方式进行处理。一种通常有效的方法是将令牌传输到使用 POST 方法提交的 HTML 表单的隐藏字段中的客户端。提交表单时，令牌将作为请求参数包含：
&amp;lt;input type=&amp;#34;hidden&amp;#34; name=&amp;#34;csrf-token&amp;#34; value=&amp;#34;CIwNZNlR4XbisJF39I8yWnWX9wX4WFoz&amp;#34; /&amp;gt; 为了安全起见，包含 CSRF token 的字段应该尽早放置在 HTML 文档中，最好是在任何非隐藏的输入字段之前，以及在 HTML 中嵌入用户可控制数据的任何位置之前。这可以对抗攻击者使用精心编制的数据操纵 HTML 文档并捕获其部分内容的各种技术。</description></item><item><title>SameSite cookies</title><link>https://rifewang.github.io/translation/web-security/csrf/samesite-cookies/</link><pubDate>Tue, 09 Mar 2021 00:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/csrf/samesite-cookies/</guid><description>SameSite cookies Link to heading 某些网站使用 SameSite cookies 防御 CSRF 攻击。
这个 SameSite 属性可用于控制是否以及如何在跨站请求中提交 cookie 。通过设置会话 cookie 的属性，应用程序可以防止浏览器默认自动向请求添加 cookie 的行为，而不管cookie 来自何处。
这个 SameSite 属性在服务器的 Set-Cookie 响应头中设置，该属性可以设为 Strict 严格或者 Lax 松懈。例如：
SetCookie: SessionId=sYMnfCUrAlmqVVZn9dqevxyFpKZt30NN; SameSite=Strict; SetCookie: SessionId=sYMnfCUrAlmqVVZn9dqevxyFpKZt30NN; SameSite=Lax; 如果 SameSite 属性设置为 Strict ，则浏览器将不会在来自其他站点的任何请求中包含cookie。这是最具防御性的选择，但它可能会损害用户体验，因为如果登录的用户通过第三方链接访问某个站点，那么他们将不会登录，并且需要重新登录，然后才能以正常方式与站点交互。
如果 SameSite 属性设置为 Lax ，则浏览器将在来自另一个站点的请求中包含cookie，但前提是满足以下两个条件：
请求使用 GET 方法。使用其他方法（如 POST ）的请求将不会包括 cookie 。 请求是由用户的顶级导航（如单击链接）产生的。其他请求（如由脚本启动的请求）将不会包括 cookie 。 使用 SameSite 的 Lax 模式确实对 CSRF 攻击提供了部分防御，因为 CSRF 攻击的目标用户操作通常使用 POST 方法实现。这里有两个重要的注意事项：
有些应用程序确实使用 GET 请求实现敏感操作。 许多应用程序和框架能够容忍不同的 HTTP 方法。在这种情况下，即使应用程序本身设计使用的是 POST 方法，但它实际上也会接受被切换为使用 GET 方法的请求。 出于上述原因，不建议仅依赖 SameSite Cookie 来抵御 CSRF 攻击。当其与 CSRF token 结合使用时，SameSite cookies 可以提供额外的防御层，并减轻基于令牌的防御中的任何缺陷。</description></item><item><title>XSS vs CSRF</title><link>https://rifewang.github.io/translation/web-security/csrf/xss-vs-csrf/</link><pubDate>Tue, 09 Mar 2021 00:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/csrf/xss-vs-csrf/</guid><description>XSS vs CSRF Link to heading 在本节中，我们将解释 XSS 和 CSRF 之间的区别，并讨论 CSRF token 是否有助于防御 XSS 攻击。
XSS 和 CSRF 之间有啥区别 Link to heading 跨站脚本攻击 XSS 允许攻击者在受害者用户的浏览器中执行任意 JavaScript 。
跨站请求伪造 CSRF 允许攻击者伪造受害用户执行他们不打算执行的操作。
XSS 漏洞的后果通常比 CSRF 漏洞更严重：
CSRF 通常只适用于用户能够执行的操作的子集。通常，许多应用程序都实现 CSRF 防御，但是忽略了暴露的一两个操作。相反，成功的 XSS 攻击通常可以执行用户能够执行的任何操作，而不管该漏洞是在什么功能中产生的。 CSRF 可以被描述为一个“单向”漏洞，因为尽管攻击者可以诱导受害者发出 HTTP 请求，但他们无法从该请求中检索响应。相反，XSS 是“双向”的，因为攻击者注入的脚本可以发出任意请求、读取响应并将数据传输到攻击者选择的外部域。 CSRF token 能否防御 XSS 攻击 Link to heading 一些 XSS 攻击确实可以通过有效使用 CSRF token 来进行防御。假设有一个简单的反射型 XSS 漏洞，其可以被利用如下：
https://insecure-website.com/status?message=&amp;lt;script&amp;gt;/*+Bad+stuff+here...+*/&amp;lt;/script&amp;gt; 现在，假设漏洞函数包含一个 CSRF token :
https://insecure-website.com/status?csrf-token=CIwNZNlR4XbisJF39I8yWnWX9wX4WFoz&amp;amp;message=&amp;lt;script&amp;gt;/*+Bad+stuff+here...+*/&amp;lt;/script&amp;gt; 如果服务器正确地验证了 CSRF token ，并拒绝了没有有效令牌的请求，那么该令牌确实可以防止此 XSS 漏洞的利用。这里的关键点是“跨站脚本”的攻击中涉及到了跨站请求，因此通过防止攻击者伪造跨站请求，该应用程序可防止对 XSS 漏洞的轻度攻击。</description></item><item><title>web 安全之 DOM-based vulnerabilities</title><link>https://rifewang.github.io/translation/web-security/dom-based/dom-based-vulnerabilities/</link><pubDate>Sun, 07 Mar 2021 01:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/dom-based/dom-based-vulnerabilities/</guid><description>DOM-based vulnerabilities Link to heading 在本节中，我们将描述什么是 DOM ，解释对 DOM 数据的不安全处理是如何引入漏洞的，并建议如何在您的网站上防止基于 DOM 的漏洞。
什么是 DOM Link to heading Document Object Model（DOM）文档对象模型是 web 浏览器对页面上元素的层次表示。网站可以使用 JavaScript 来操作 DOM 的节点和对象，以及它们的属性。DOM 操作本身不是问题，事实上，它也是现代网站中不可或缺的一部分。然而，不安全地处理数据的 JavaScript 可能会引发各种攻击。当网站包含的 JavaScript 接受攻击者可控制的值（称为 source 源）并将其传递给一个危险函数（称为 sink 接收器）时，就会出现基于 DOM 的漏洞。
污染流漏洞 Link to heading 许多基于 DOM 的漏洞可以追溯到客户端代码在处理攻击者可以控制的数据时存在问题。
什么是污染流 Link to heading 要利用或者缓解这些漏洞，首先要熟悉 source 源与 sink 接收器之间的污染流的基本概念。
Source 源是一个 JavaScript 属性，它接受可能由攻击者控制的数据。源的一个示例是 location.search 属性，因为它从 query 字符串中读取输入，这对于攻击者来说比较容易控制。总之，攻击者可以控制的任何属性都是潜在的源。包括引用 URL（ document.referrer ）、用户的 cookies（ document.cookie ）和 web messages 。</description></item><item><title>DOM clobbering</title><link>https://rifewang.github.io/translation/web-security/dom-based/dom-clobbering/</link><pubDate>Sun, 07 Mar 2021 00:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/dom-based/dom-clobbering/</guid><description>DOM clobbering Link to heading 在本节中，我们将描述什么是 DOM clobbing ，演示如何使用 clobbing 技术来利用 DOM 漏洞，并提出防御 DOM clobbing 攻击的方法。
什么是 DOM clobbering Link to heading DOM clobbering 是一种将 HTML 注入页面以操作 DOM 并最终改变页面上 JavaScript 行为的技术。在无法使用 XSS ，但是可以控制页面上 HTML 白名单属性如 id 或 name 时，DOM clobbering 就特别有用。DOM clobbering 最常见的形式是使用 anchor 元素覆盖全局变量，然后该变量将会被应用程序以不安全的方式使用，例如生成动态脚本 URL 。
术语 clobbing 来自以下事实：你正在 “clobbing”（破坏） 一个全局变量或对象属性，并用 DOM 节点或 HTML 集合去覆盖它。例如，可以使用 DOM 对象覆盖其他 JavaScript 对象并利用诸如 submit 这样不安全的名称，去干扰表单真正的 submit() 函数。
如何利用 DOM-clobbering 漏洞 Link to heading 某些 JavaScript 开发者经常会使用以下模式：</description></item><item><title>web 安全之 HTTP Host header attacks</title><link>https://rifewang.github.io/translation/web-security/http-host-header-attacks/http-host-header-attacks/</link><pubDate>Sat, 06 Mar 2021 01:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/http-host-header-attacks/http-host-header-attacks/</guid><description>HTTP Host header attacks Link to heading 在本节中，我们将讨论错误的配置和有缺陷的业务逻辑如何通过 HTTP Host 头使网站遭受各种攻击。我们将概述识别易受 HTTP Host 头攻击的网站的高级方法，并演示如何利用此方法。最后，我们将提供一些有关如何保护自己网站的一般建议。
什么是 HTTP Host 头 Link to heading 从 HTTP/1.1 开始，HTTP Host 头是一个必需的请求头，其指定了客户端想要访问的域名。例如，当用户访问 https://portswigger.net/web-security 时，浏览器将会发出一个包含 Host 头的请求：
GET /web-security HTTP/1.1 Host: portswigger.net 在某些情况下，例如当请求被中介系统转发时，Host 值可能在到达预期的后端组件之前被更改。我们将在下面更详细地讨论这种场景。
HTTP Host 头的作用是什么 Link to heading HTTP Host 头的作用就是标识客户端想要与哪个后端组件通信。如果请求没有 Host 头或者 Host 格式不正确，则把请求路由到预期的应用程序时会出现问题。
历史上因为每个 IP 地址只会托管单个域名的内容，所以并不存在模糊性。但是如今，由于基于云的解决方案和相关架构的不断增长，使得多个网站和应用程序在同一个 IP 地址访问变得很常见，这种方式也越来越受欢迎，部分原因是 IPv4 地址耗尽。
当多个应用程序通过同一个 IP 地址访问时，通常是以下情况之一。
虚拟主机 Link to heading 一种可能的情况是，一台 web 服务器部署多个网站或应用程序，这可能是同一个所有者拥有多个网站，也有可能是不同网站的所有者部署在同一个共享平台上。这在以前不太常见，但在一些基于云的 SaaS 解决方案中仍然会出现。</description></item><item><title>Exploiting HTTP Host header vulnerabilities</title><link>https://rifewang.github.io/translation/web-security/http-host-header-attacks/exploiting-http-host-header-vulnerabilities/</link><pubDate>Sat, 06 Mar 2021 00:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/http-host-header-attacks/exploiting-http-host-header-vulnerabilities/</guid><description>如何识别和利用 HTTP Host 头漏洞 Link to heading 在本节中，我们将更仔细地了解如何识别网站是否存在 HTTP Host 头漏洞。然后，我们将提供一些示例，说明如何利用此漏洞。
如何使用 HTTP Host 头测试漏洞 Link to heading 要测试网站是否易受 HTTP Host 攻击，你需要一个拦截代理（如 Burp proxy ）和手动测试工具（如 Burp Repeater 和 Burp intruiter ）。
简而言之，你需要能够修改 Host 标头，并且你的请求能够到达目标应用程序。如果是这样，则可以使用此标头来探测应用程序，并观察其对响应的影响。
提供一个任意的 Host 头 Link to heading 在探测 Host 头注入漏洞时，第一步测试是给 Host 头设置任意的、无法识别的域名，然后看看会发生什么。
一些拦截代理直接从 Host 头连接目标 IP 地址，这使得这种测试几乎不可能；对报头所做的任何更改都会导致请求发送到完全不同的 IP 地址。然而，Burp Suite 精确地保持了主机头和目标 IP 地址之间的分离，这种分离允许你提供所需的任意或格式错误的主机头，同时仍然确保将请求发送到预期目标。
有时，即使你提供了一个意外的 Host 头，你仍然可以访问目标网站。这可能有很多原因。例如，服务器有时设置了默认或回退选项，以处理无法识别的域名请求。如果你的目标网站碰巧是默认的，那你就走运了。在这种情况下，你可以开始研究应用程序对 Host 头做了什么，以及这种行为是否可利用。
另一方面，由于 Host 头是网站工作的基本部分，篡改它通常意味着你将无法访问目标应用程序。接收到你的请求的反向代理或负载平衡器可能根本不知道将其转发到何处，从而响应 &amp;ldquo;Invalid Host header&amp;rdquo; 这种错误。如果你的目标很可能是通过 CDN 访问的。在这种情况下，你应该继续尝试下面概述的一些技术。</description></item><item><title>Password reset poisoning</title><link>https://rifewang.github.io/translation/web-security/http-host-header-attacks/password-reset-poisoning/</link><pubDate>Sat, 06 Mar 2021 00:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/http-host-header-attacks/password-reset-poisoning/</guid><description>Password reset poisoning Link to heading 密码重置中毒是一种技术，攻击者可以利用该技术来操纵易受攻击的网站，以生成指向其控制下的域的密码重置链接。这种行为可以用来窃取重置任意用户密码所需的秘密令牌，并最终危害他们的帐户。
密码重置是如何工作的 Link to heading 几乎所有需要登录的网站都实现了允许用户在忘记密码时重置密码的功能。实现这个功能有好几种方法，其中一个最常见的方法是：
用户输入用户名或电子邮件地址，然后提交密码重置请求。 网站检查该用户是否存在，然后生成一个临时的、唯一的、高熵的 token 令牌，并在后端将该令牌与用户的帐户相关联。 网站向用户发送一封包含重置密码链接的电子邮件。用户的 token 令牌作为 query 参数包含在相应的 URL 中，如 https://normal-website.com/reset?token=0a1b2c3d4e5f6g7h8i9j。 当用户访问此 URL 时，网站会检查所提供的 token 令牌是否有效，并使用它来确定要重置的帐户。如果一切正常，用户就可以设置新密码了。最后，token 令牌被销毁。 与其他一些方法相比，这个过程足够简单并且相对安全。然而，它的安全性依赖于这样一个前提：只有目标用户才能访问他们的电子邮件收件箱，从而使用他们的 token 令牌。而密码重置中毒就是一种窃取此 token 令牌以更改其他用户密码的方法。
如何构造一个密码重置中毒攻击 Link to heading 如果发送给用户的 URL 是基于可控制的输入（例如 Host 头）动态生成的，则可以构造如下所示的密码重置中毒攻击：
攻击者根据需要获取受害者的电子邮件地址或用户名，并代表受害者提交密码重置请求，但是这个请求被修改了 Host 头，以指向他们控制的域。我们假设使用的是 evil-user.net 。 受害者收到了网站发送的真实的密码重置电子邮件，其中包含一个重置密码的链接，以及与他们的帐户相关联的 token 令牌。但是，URL 中的域名指向了攻击者的服务器：https://evil-user.net/reset?token=0a1b2c3d4e5f6g7h8i9j 。 如果受害者点击了此链接，则密码重置的 token 令牌将被传递到攻击者的服务器。 攻击者现在可以访问网站的真实 URL ，并使用盗取的受害者的 token 令牌，将用户的密码重置为自己的密码，然后就可以登录到用户的帐户了。 在真正的攻击中，攻击者可能会伪造一个假的警告通知来提高受害者点击链接的概率。
即使不能控制密码重置的链接，有时也可以使用 Host 头将 HTML 注入到敏感的电子邮件中。请注意，电子邮件客户端通常不执行 JavaScript ，但其他 HTML 注入技术如悬挂标记攻击可能仍然适用。</description></item><item><title>web 安全之 Clickjacking</title><link>https://rifewang.github.io/translation/web-security/clickjacking/clickjacking/</link><pubDate>Fri, 05 Mar 2021 00:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/clickjacking/clickjacking/</guid><description>Clickjacking ( UI redressing ) Link to heading 在本节中，我们将解释什么是 clickjacking 点击劫持，并描述常见的点击劫持攻击示例，以及讨论如何防御这些攻击。
什么是点击劫持 Link to heading 点击劫持是一种基于界面的攻击，通过诱导用户点击钓鱼网站中的被隐藏了的可操作的危险内容。
例如：某个用户被诱导访问了一个钓鱼网站（可能是点击了电子邮件中的链接），然后点击了一个赢取大奖的按钮。实际情况则是，攻击者在这个赢取大奖的按钮下面隐藏了另一个网站上向其他账户进行支付的按钮，而结果就是用户被诱骗进行了支付。这就是一个点击劫持攻击的例子。这项技术实际上就是通过 iframe 合并两个页面，真实操作的页面被隐藏，而诱骗用户点击的页面则显示出来。点击劫持攻击与 CSRF 攻击的不同之处在于，点击劫持需要用户执行某种操作，比如点击按钮，而 CSRF 则是在用户不知情或者没有输入的情况下伪造整个请求。
针对 CSRF 攻击的防御措施通常是使用 CSRF token（针对特定会话、一次性使用的随机数）。而点击劫持无法则通过 CSRF token 缓解攻击，因为目标会话是在真实网站加载的内容中建立的，并且所有请求均在域内发生。CSRF token 也会被放入请求中，并作为正常行为的一部分传递给服务器，与普通会话相比，差异就在于该过程发生在隐藏的 iframe 中。
如何构造一个基本的点击劫持攻击 Link to heading 点击劫持攻击使用 CSS 创建和操作图层。攻击者将目标网站通过 iframe 嵌入并隐藏。使用样式标签和参数的示例如下：
&amp;lt;head&amp;gt; &amp;lt;style&amp;gt; #target_website { position:relative; width:128px; height:128px; opacity:0.00001; z-index:2; } #decoy_website { position:absolute; width:300px; height:400px; z-index:1; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; ... &amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;decoy_website&amp;#34;&amp;gt; ...decoy web content here.</description></item><item><title>web 安全之 HTTP request smuggling</title><link>https://rifewang.github.io/translation/web-security/request-smuggling/http-request-smuggling/</link><pubDate>Thu, 04 Mar 2021 01:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/request-smuggling/http-request-smuggling/</guid><description>HTTP request smuggling Link to heading 在本节中，我们将解释什么是 HTTP 请求走私，并描述常见的请求走私漏洞是如何产生的。
什么是 HTTP 请求走私 Link to heading HTTP 请求走私是一种干扰网站处理多个 HTTP 请求序列的技术。请求走私漏洞危害很大，它使攻击者可以绕过安全控制，未经授权访问敏感数据并直接危害其他应用程序用户。
HTTP 请求走私到底发生了什么 Link to heading 现在的应用架构中经常会使用诸如负载均衡、反向代理、网关等服务，这些服务在链路上起到了一个转发请求给后端服务器的作用，因为位置位于后端服务器的前面，所以本文把他们称为前端服务器。
当前端服务器（转发服务）将 HTTP 请求转发给后端服务器时，它通常会通过与后端服务器之间的同一个网络连接发送多个请求，因为这样做更加高效。协议非常简单：HTTP 请求被一个接一个地发送，接受请求的服务器则解析 HTTP 请求头以确定一个请求的结束位置和下一个请求的开始位置，如下图所示： 在这种情况下，前端服务器（转发服务）与后端系统必须就请求的边界达成一致。否则，攻击者可能会发送一个模棱两可的请求，该请求被前端服务器（转发服务）与后端系统以不同的方式解析：
如上图所示，攻击者使上一个请求的一部分被后端服务器解析为下一个请求的开始，这时就会干扰应用程序处理该请求的方式。这就是请求走私攻击，其可能会造成毁灭性的后果。
HTTP 请求走私漏洞是怎么产生的 Link to heading 绝大多数 HTTP 请求走私漏洞的出现是因为 HTTP 规范提供了两种不同的方法来指定请求的结束位置：Content-Length 头和 Transfer-Encoding 头。
Content-Length 头很简单，直接以字节为单位指定消息体的长度。例如：
POST /search HTTP/1.1 Host: normal-website.com Content-Type: application/x-www-form-urlencoded Content-Length: 11 q=smuggling Transfer-Encoding 头则可以声明消息体使用了 chunked 编码，就是消息体被拆分成了一个或多个分块传输，每个分块的开头是当前分块大小（以十六进制表示），后面紧跟着 \r\n，然后是分块内容，后面也是 \r\n。消息的终止分块也是同样的格式，只是其长度为零。例如：
POST /search HTTP/1.1 Host: normal-website.com Content-Type: application/x-www-form-urlencoded Transfer-Encoding: chunked b q=smuggling 0 由于 HTTP 规范提供了两种不同的方法来指定 HTTP 消息的长度，因此单个消息中完全可以同时使用这两种方法，从而使它们相互冲突。HTTP 规范为了避免这种歧义，其声明如果 Content-Length 和 Transfer-Encoding 同时存在，则 Content-Length 应该被忽略。当只有一个服务运行时，这种歧义似乎可以避免，但是当多个服务被连接在一起时，这种歧义就无法避免了。在这种情况下，出现问题有两个原因：</description></item><item><title>Exploiting request smuggling</title><link>https://rifewang.github.io/translation/web-security/request-smuggling/exploiting-request-smuggling/</link><pubDate>Thu, 04 Mar 2021 00:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/request-smuggling/exploiting-request-smuggling/</guid><description>利用 HTTP 请求走私漏洞 Link to heading 在本节中，我们将描述 HTTP 请求走私漏洞的几种利用方法，这也取决于应用程序的预期功能和其他行为。
利用 HTTP 请求走私漏洞绕过前端服务器（转发服务）安全控制 Link to heading 在某些应用程序中，前端服务器（转发服务）不仅用来转发请求，也用来实现了一些安全控制，以决定单个请求能否被转发到后端处理，而后端服务认为接受到的所有请求都已经通过了安全验证。
假设，某个应用程序使用前端服务器（转发服务）来做访问控制，只有当用户被授权访问的请求才会被转发给后端服务器，后端服务器接受的所有请求都无需进一步检查。在这种情况下，可以使用 HTTP 请求走私漏洞绕过访问控制，将请求走私到后端服务器。
假设当前用户可以访问 /home ，但不能访问 /admin 。他们可以使用以下请求走私攻击绕过此限制：
前端服务器（转发服务）将其视为一个请求，然后进行访问验证，由于用户拥有访问 /home 的权限，因此把请求转发给后端服务器。然而，后端服务器则将其视为 /home 和 /admin 两个单独的请求，并且认为请求都通过了权限验证，此时 /admin 的访问控制实际上就被绕过了。
前端服务器（转发服务）对请求重写 Link to heading 在许多应用程序中，请求被转发给后端服务之前会进行一些重写，通常是添加一些额外的请求头之类的。例如，转发请求重写可能：
终止 TLS 连接并添加一些描述使用的协议和密钥之类的头。 添加 X-Forwarded-For 头用来标记用户的 IP 地址。 根据用户的会话令牌确定用户 ID ，并添加用于标识用户的头。 添加一些其他攻击感兴趣的敏感信息。 在某些情况下，如果你走私的请求缺少一些前端服务器（转发服务）添加的头，那么后端服务可能不会正常处理，从而导致走私请求无法达到预期的效果。
通常有一些简单的方法可以准确地得知前端服务器（转发服务）是如何重写请求的。为此，需要执行以下步骤：
找到一个将请求参数的值反映到应用程序响应中的 POST 请求。 随机排列参数，以使反映的参数出现在消息体的最后。 将这个请求走私到后端服务器，然后直接发送一个要显示其重写形式的普通请求。 假设应用程序有个登录的功能，其会反映 email 参数：
POST /login HTTP/1.1 Host: vulnerable-website.com Content-Type: application/x-www-form-urlencoded Content-Length: 28 email=wiener@normal-user.</description></item><item><title>Finding request smuggling</title><link>https://rifewang.github.io/translation/web-security/request-smuggling/finding-request-smuggling/</link><pubDate>Thu, 04 Mar 2021 00:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/request-smuggling/finding-request-smuggling/</guid><description>查找 HTTP 请求走私漏洞 Link to heading 在本节中，我们将介绍用于查找 HTTP 请求走私漏洞的不同技术。
计时技术 Link to heading 检测 HTTP 请求走私漏洞的最普遍有效的方法就是计时技术。发送请求，如果存在漏洞，则应用程序的响应会出现时间延迟。
使用计时技术查找 CL.TE 漏洞 Link to heading 如果应用存在 CL.TE 漏洞，那么发送如下请求通常会导致时间延迟：
前端服务器（转发服务）使用 Content-Length 认为消息体只有 4 个字节，即 1\r\nA，因此后面的 X 被忽略了，然后把这个请求转发给后端。而后端服务使用 Transfer-Encoding 则会一直等待终止分块 0\r\n 。这就会导致明显的响应延迟。
使用计时技术查找 TE.CL 漏洞 Link to heading 如果应用存在 TE.CL 漏洞，那么发送如下请求通常会导致时间延迟：
前端服务器（转发服务）使用 Transfer-Encoding，由于第一个分块就是 0\r\n 终止分块，因此后面的 X 直接被忽略了，然后把这个请求转发给后端。而后端服务使用 Content-Length 则会一直等到后续 6 个字节的内容。这就会导致明显的延迟。
注意：如果应用程序易受 CL.TE 漏洞的攻击，则基于时间的 TE.CL 漏洞测试可能会干扰其他应用程序用户。因此，为了隐蔽并尽量减少干扰，你应该先进行 CL.TE 测试，只有在失败了之后再进行 TE.CL 测试。
使用差异响应确认 HTTP 请求走私漏洞 Link to heading 当检测到可能的请求走私漏洞时，可以通过利用该漏洞触发应用程序响应内容的差异来获取该漏洞进一步的证据。这包括连续向应用程序发送两个请求：</description></item><item><title>web 安全之 OS command injection</title><link>https://rifewang.github.io/translation/web-security/command-injection/os-command-injection/</link><pubDate>Wed, 03 Mar 2021 00:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/command-injection/os-command-injection/</guid><description>OS command injection Link to heading 在本节中，我们将解释什么是操作系统命令注入，描述如何检测和利用此漏洞，为不同的操作系统阐明一些有用的命令和技术，并总结如何防止操作系统命令注入。
什么是操作系统命令注入 Link to heading OS 命令注入（也称为 shell 注入）是一个 web 安全漏洞，它允许攻击者在运行应用程序的服务器上执行任意的操作系统命令，这通常会对应用程序及其所有数据造成严重危害。并且，攻击者也常常利用此漏洞危害基础设施中的其他部分，利用信任关系攻击组织内的其他系统。
执行任意命令 Link to heading 假设某个购物应用程序允许用户查看某个商品在特定商店中是否有库存，此信息可以通过以下 URL 获取：
https://insecure-website.com/stockStatus?productID=381&amp;amp;storeID=29 为了提供返回信息，应用程序必须查询各种遗留系统。由于历史原因，此功能通过调用 shell 命令并传递参数来实现如下：
stockreport.pl 381 29 此命令输出特定商店中某个商品的库存信息，并将其返回给用户。
由于应用程序没有对 OS 命令注入进行防御，那么攻击者可以提交类似以下输入来执行任意命令：
&amp;amp; echo aiwefwlguh &amp;amp; 如果这个输入被当作 productID 参数，那么应用程序执行的命令就是：
stockreport.pl &amp;amp; echo aiwefwlguh &amp;amp; 29 echo 命令就是让提供的字符串在输出中显示的作用，其是测试某些 OS 命令注入的有效方法。&amp;amp; 符号就是一个 shell 命令分隔符，因此上例实际执行的是一个接一个的三个单独的命令。因此，返回给用户的输出为：
Error - productID was not provided aiwefwlguh 29: command not found 这三行输出表明：
原来的 stockreport.pl 命令由于没有收到预期的参数，因此返回错误信息。 注入的 echo 命令执行成功。 原始的参数 29 被当成了命令执行，也导致了异常。 将命令分隔符 &amp;amp; 放在注入命令之后通常是有用的，因为它会将注入的命令与注入点后面的命令分开，这减少了随后发生的事情将阻止注入命令执行的可能性。</description></item><item><title>web 安全之 Server-side request forgery</title><link>https://rifewang.github.io/translation/web-security/ssrf/ssrf/</link><pubDate>Mon, 01 Mar 2021 01:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/ssrf/ssrf/</guid><description>Server-side request forgery (SSRF) Link to heading 在本节中，我们将解释 server-side request forgery（服务端请求伪造）是什么，并描述一些常见的示例，以及解释如何发现和利用各种 SSRF 漏洞。
SSRF 是什么 Link to heading SSRF 服务端请求伪造是一个 web 漏洞，它允许攻击者诱导服务端程序向攻击者选择的任何地址发起 HTTP 请求。
在典型的 SSRF 示例中，攻击者可能会使服务端建立一个到服务端自身、或组织基础架构中的其它基于 web 的服务、或外部第三方系统的连接。
SSRF 攻击的影响 Link to heading 成功的 SSRF 攻击通常会导致未经授权的操作或对组织内部数据的访问，无论是在易受攻击的应用程序本身，还是应用程序可以通信的其它后端系统。在某些情况下，SSRF 漏洞可能允许攻击者执行任意的命令。
利用 SSRF 漏洞可能可以操作服务端应用程序使其向与之连接的外部第三方系统发起恶意请求，这将导致潜在的法律责任和声誉受损。
常见的 SSRF 攻击 Link to heading SSRF 攻击通常利用服务端应用程序的信任关系发起攻击并执行未经授权的操作。这种信任关系可能包括：对服务端自身的信任，或同组织内其它后端系统的信任。
SSRF 攻击服务端自身 Link to heading 在针对服务端本身的 SSRF 攻击中，攻击者诱导应用程序向其自身发出 HTTP 请求，这通常需要提供一个主机名是 127.0.0.1 或者 localhost 的 URL 。
例如，假设某个购物应用程序，其允许用户查看某个商品在特定商店中是否有库存。为了提供库存信息，应用程序需要通过 REST API 查询其他后端服务，而其他后端服务的 URL 地址直接包含在前端 HTTP 请求中。因此，当用户查看商品的库存状态时，浏览器可能发出如下请求：</description></item><item><title>Blind SSRF</title><link>https://rifewang.github.io/translation/web-security/ssrf/blind-ssrf/</link><pubDate>Mon, 01 Mar 2021 00:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/ssrf/blind-ssrf/</guid><description>Blind SSRF Link to heading 在本节中，我们将解释什么是不可见的服务端请求伪造，并描述一些常见的不可见 SSRF 示例，以及解释如何发现和利用不可见 SSRF 漏洞。
什么是不可见 SSRF Link to heading 不可见 SSRF 漏洞是指，可以诱导应用程序向提供的 URL 发出后端 HTTP 请求，但来自后端请求的响应没有在应用程序的前端响应中返回。
不可见 SSRF 漏洞的影响 Link to heading 不可见 SSRF 漏洞的影响往往低于完全可见的 SSRF 漏洞，因为其单向性，虽然在某些情况下，可以利用它们从后端系统检索敏感数据，但不能轻易地利用它们来实现完整的远程代码执行。
如何发现和利用不可见 SSRF 漏洞 Link to heading 检测不可见 SSRF 漏洞最可靠的方法是使用 out-of-band（OAST）带外技术。这包括尝试触发对你控制的外部系统的 HTTP 请求，并监视与该系统的网络交互。
使用 OAST 技术最简单有效的方式是使用 Burp Collaborator (付费软件)。你可以使用 Burp Collaborator client 生成唯一的域名，将这个域名以有效负载的形式发送到检测漏洞的应用程序，并监视与这个域名的任何交互，如果观察到来自应用程序传入的 HTTP 请求，则说明应用程序存在 SSRF 漏洞。
注意：在测试 SSRF 漏洞时，通常会观察到所提供域名的 DNS 查找，但是却没有后续的 HTTP 请求。这通常是应用程序视图向该域名发出 HTTP 请求，这导致了初始的 DNS 查找，但实际的 HTTP 请求被网络拦截了。基础设施允许出站的 DNS 流量是相对常见的，因为出于很多目的需要，但是会阻止到意外目的地的 HTTP 连接。</description></item><item><title>web 安全之 Directory traversal</title><link>https://rifewang.github.io/translation/web-security/directory-traversal/directory-traversal/</link><pubDate>Mon, 01 Mar 2021 00:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/directory-traversal/directory-traversal/</guid><description>Directory traversal - 目录遍历 Link to heading 在本节中，我们将介绍什么是目录遍历，描述如何执行路径遍历攻击和绕过常见障碍，并阐明如何防止路径遍历漏洞。
什么是目录遍历？ Link to heading 目录遍历（也称为文件路径遍历）是一个 web 安全漏洞，此漏洞使攻击者能够读取运行应用程序的服务器上的任意文件。这可能包括应用程序代码和数据、后端系统的凭据以及操作系统相关敏感文件。在某些情况下，攻击者可能能够对服务器上的任意文件进行写入，从而允许他们修改应用程序数据或行为，并最终完全控制服务器。
通过目录遍历读取任意文件 Link to heading 假设某个应用程序通过如下 HTML 加载图像：
&amp;lt;img src=&amp;#34;/loadImage?filename=218.png&amp;#34;&amp;gt; 这个 loadImage URL 通过 filename 文件名参数来返回指定文件的内容，假设图像本身存储在路径为 /var/www/images/ 的磁盘上。应用程序基于此基准路径与请求的 filename 文件名返回如下路径的图像：
/var/www/images/218.png 如果该应用程序没有针对目录遍历攻击采取任何防御措施，那么攻击者可以请求类似如下 URL 从服务器的文件系统中检索任意文件：
https://insecure-website.com/loadImage?filename=../../../etc/passwd 这将导致如下路径的文件被返回：
/var/www/images/../../../etc/passwd ../ 表示上级目录，因此这个文件其实就是：
/etc/passwd 在 Unix 操作系统上，这个文件是一个内容为该服务器上注册用户详细信息的标准文件。
在 Windows 系统上，..\ 和 ../ 的作用相同，都表示上级目录，因此检索标准操作系统文件可以通过如下方式：
https://insecure-website.com/loadImage?filename=..\..\..\windows\win.ini 利用文件路径遍历漏洞的常见障碍 Link to heading 许多将用户输入放入文件路径的应用程序实现了某种应对路径遍历攻击的防御措施，然而这些措施却通常可以被规避。
如果应用程序从用户输入的 filename 中剥离或阻止 ..\ 目录遍历序列，那么也可以使用各种技巧绕过防御。
你可以使用从系统根目录开始的绝对路径，例如 filename=/etc/passwd 这样直接引用文件而不使用任何 ..\ 形式的遍历序列。</description></item><item><title>web 安全之 CORS</title><link>https://rifewang.github.io/translation/web-security/cors/cors/</link><pubDate>Sun, 28 Feb 2021 01:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/cors/cors/</guid><description>Cross-origin resource sharing (CORS) Link to heading 在本节中，我们将解释什么是跨域资源共享（CORS），并描述一些基于 CORS 的常见攻击示例，以及讨论如何防御这些攻击。
CORS（跨域资源共享）是什么？ Link to heading CORS（跨域资源共享）是一种浏览器机制，它允许对位于当前访问域之外的资源进行受控访问。它扩展并增加了同源策略的灵活性。然而，如果一个网站的 CORS 策略配置和实现不当，它也可能导致基于跨域的攻击。CORS 不是针对跨源攻击（例如跨站请求伪造 CSRF）的保护。
Same-origin policy（同源策略） Link to heading 同源策略是一种限制性的跨域规范，它限制了网站与源域之外资源交互的能力。同源策略是多年前定义的，用于应对潜在的恶意跨域交互，例如一个网站从另一个网站窃取私人数据。它通常允许域向其他域发出请求，但不允许访问响应。
更多内容请参考 Same-origin-policy 。
同源策略的放宽 Link to heading 同源策略具有很大的限制性，因此人们设计了很多方法去规避这些限制。许多网站与子域或第三方网站的交互方式要求完全的跨域访问。使用跨域资源共享（CORS）可以有控制地放宽同源策略。
CORS 协议使用一组 HTTP header 来定义可信的 web 域和相关属性，例如是否允许通过身份验证的访问。浏览器和它试图访问的跨域网站之间进行这些 header 的交换。
更多内容请参考 CORS and the Access-Control-Allow-Origin response header 。
CORS 配置不当引发的漏洞 Link to heading 现在许多网站使用 CORS 来允许来自子域和可信的第三方的访问。他们对 CORS 的实现可能包含有错误或过于放宽，这可能导致可利用的漏洞。
服务端 ACAO 直接返回客户端的 Origin Link to heading 有些应用程序需要允许很多其它域的访问。维护一个允许域的列表需要付出持续的努力，任何差错都有可能造成破坏。因此，应用程序可能使用一些更加简单的方法来达到最终目的。
一种方法是从请求头中读取 Origin，然后将其作为 Access-Control-Allow-Origin 响应头返回。例如，应用程序接受了以下请求：</description></item><item><title>CORS 和 Access-Control-Allow-Origin 响应头</title><link>https://rifewang.github.io/translation/web-security/cors/access-control-allow-origin/</link><pubDate>Sun, 28 Feb 2021 00:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/cors/access-control-allow-origin/</guid><description>CORS 和 Access-Control-Allow-Origin 响应头 Link to heading 在本节中，我们将解释有关 CORS 的 Access-Control-Allow-Origin 响应头，以及后者如何构成 CORS 实现的一部分。
CORS 通过使用一组 HTTP 头部提供了同源策略的可控制放宽，浏览器允许访问基于这些头部的跨域请求的响应。
什么是 Access-Control-Allow-Origin 响应头？ Link to heading Access-Control-Allow-Origin 响应头标识了跨域请求允许的请求来源，浏览器会将 Access-Control-Allow-Origin 与请求网站 origin 进行比较，如果两者匹配则允许访问响应。
实现简单的 CORS Link to heading CORS 规范规定了 web 服务器和浏览器之间交换的头内容，其中 Access-Control-Allow-Origin 是最重要的。当网站发起跨域资源请求时，浏览器将会自动添加 Origin 头，随后服务器返回 Access-Control-Allow-Origin 响应头。
例如，origin 为 normal-website.com 的网站发起了如下跨域请求：
GET /data HTTP/1.1 Host: robust-website.com Origin : https://normal-website.com 服务器响应：
HTTP/1.1 200 OK ... Access-Control-Allow-Origin: https://normal-website.com 浏览器将会允许 normal-website.com 网站代码访问响应，因为 Access-Control-Allow-Origin 与 Origin 匹配。</description></item><item><title>Same-origin policy (SOP)</title><link>https://rifewang.github.io/translation/web-security/cors/same-origin-policy/</link><pubDate>Sun, 28 Feb 2021 00:00:00 +0800</pubDate><guid>https://rifewang.github.io/translation/web-security/cors/same-origin-policy/</guid><description>Same-origin policy (SOP) - 同源策略 Link to heading 在本节中，我们将解释什么是同源策略以及它是如何实现的。
什么是同源策略？ Link to heading 同源策略是一种旨在防止网站互相攻击的 web 浏览器的安全机制。
同源策略限制一个源上的脚本访问另一个源的数据。
Origin 源由三个部分组成：schema、domain、port ，所谓的同源就是要求这三个部分全部相同。 例如下面这个 URL：
http://normal-website.com/example/example.html 其 schema 是 http，domain 是 normal-website.com，port 是 80 。下表显示了如果上述 URL 中的内容尝试访问其它源将会是什么情况：
访问的 URL 是否可以访问 http://normal-website.com/example/ 是，同源 http://normal-website.com/example2/ 是，同源 https://normal-website.com/example/ 否: scheme 和 port 都不同 http://en.normal-website.com/example/ 否: domain 不同 http://www.normal-website.com/example/ 否: domain 不同 http://normal-website.com:8080/example/ 否: port 不同* *IE 浏览器将会允许访问，因为 IE 浏览器在应用同源策略时不考虑端口号。
为什么同源策略是必要的？ Link to heading 当浏览器从一个源发送 HTTP 请求到另一个源时，与另一个源相关的任何 cookie （包括身份验证会话cookie）也将会作为请求的一部分一起发送。这意味着响应将在用户会话中返回，并包含此特定用户的相关数据。如果没有同源策略，如果你访问了一个恶意网站，它将能够读取你 GMail 中的电子邮件、Facebook 上的私人消息等。</description></item></channel></rss>