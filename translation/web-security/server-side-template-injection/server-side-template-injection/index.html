<!doctype html><html lang=en><head><title>web 安全之 Server-side template injection · 凌虚 Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="凌虚"><meta name=description content="web 安全之 Server-side template injection"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="web 安全之 Server-side template injection"><meta name=twitter:description content="web 安全之 Server-side template injection"><meta property="og:title" content="web 安全之 Server-side template injection"><meta property="og:description" content="web 安全之 Server-side template injection"><meta property="og:type" content="article"><meta property="og:url" content="https://rifewang.github.io/translation/web-security/server-side-template-injection/server-side-template-injection/"><meta property="article:section" content="translation"><meta property="article:published_time" content="2021-03-10T01:00:00+08:00"><meta property="article:modified_time" content="2021-03-10T01:00:00+08:00"><link rel=canonical href=https://rifewang.github.io/translation/web-security/server-side-template-injection/server-side-template-injection/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.0fa2dc75ed1b76894ac0e062b10a6c4730daa745096fa120114b290ed8a48788.css integrity="sha256-D6Lcde0bdolKwOBisQpsRzDap0UJb6EgEUspDtikh4g=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.593028e7f7ac55c003b79c230d1cd411bb4ca53b31556c3abb7f027170e646e9.css integrity="sha256-WTAo5/esVcADt5wjDRzUEbtMpTsxVWw6u38CcXDmRuk=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.110.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>凌虚 Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>博客</a></li><li class=navigation-item><a class=navigation-link href=/translation/>译文</a></li><li class=navigation-item><a class=navigation-link href=/about/>关于</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://rifewang.github.io/translation/web-security/server-side-template-injection/server-side-template-injection/>web 安全之 Server-side template injection</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2021-03-10T01:00:00+08:00>March 10, 2021</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
2-minute read</span></div><div class=categories><i class="fa fa-folder" aria-hidden=true></i>
<a href=/categories/web-security/>web security</a></div></div></header><div class=post-content><h1 id=server-side-template-injection>Server-side template injection
<a class=heading-link href=#server-side-template-injection><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>在本节中，我们将介绍什么是服务端模板注入，并概述利用此漏洞的基本方法，同时也将提供一些避免此漏洞的建议。</p><h2 id=什么是服务端模板注入>什么是服务端模板注入
<a class=heading-link href=#%e4%bb%80%e4%b9%88%e6%98%af%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%a8%a1%e6%9d%bf%e6%b3%a8%e5%85%a5><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>服务端模板注入是指攻击者能够利用模板自身语法将恶意负载注入模板，然后在服务端执行。</p><p>模板引擎被设计成通过结合固定模板和可变数据来生成网页。当用户输入直接拼接到模板中，而不是作为数据传入时，可能会发生服务端模板注入攻击。这使得攻击者能够注入任意模板指令来操纵模板引擎，从而能够完全控制服务器。顾名思义，服务端模板注入有效负载是在服务端交付和执行的，这可能使它们比典型的客户端模板注入更危险。</p><h2 id=服务端模板注入会造成什么影响>服务端模板注入会造成什么影响
<a class=heading-link href=#%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%a8%a1%e6%9d%bf%e6%b3%a8%e5%85%a5%e4%bc%9a%e9%80%a0%e6%88%90%e4%bb%80%e4%b9%88%e5%bd%b1%e5%93%8d><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>服务端模板注入漏洞会使网站面临各种攻击，具体取决于所讨论的模板引擎以及应用程序如何使用它。在极少数情况下，这些漏洞不会带来真正的安全风险。然而，大多数情况下，服务端模板注入的影响可能是灾难性的。</p><p>最严重的情况是，攻击者有可能完成远程代码执行，从而完全控制后端服务器，并利用它对内部基础设施进行其他攻击。</p><p>即使在不可能完全执行远程代码的情况下，攻击者通常仍可以使用服务端模板注入作为许多其他攻击的基础，从而可能获得服务器上敏感数据和任意文件的访问权限。</p><h2 id=服务端模板注入漏洞是如何产生的>服务端模板注入漏洞是如何产生的
<a class=heading-link href=#%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%a8%a1%e6%9d%bf%e6%b3%a8%e5%85%a5%e6%bc%8f%e6%b4%9e%e6%98%af%e5%a6%82%e4%bd%95%e4%ba%a7%e7%94%9f%e7%9a%84><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>当用户输入直接拼接到模板中而不是作为数据传入时，就会出现服务端模板注入漏洞。</p><p>简单地提供占位符并在其中呈现动态内容的静态模板通常不会受到服务端模板注入的攻击。典型的例子如提取用户名作为电子邮件的开头，例如以下从 Twig 模板中提取的内容：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>$output = $twig-&gt;render(&#34;Dear {first_name},&#34;, array(&#34;first_name&#34; =&gt; $user.first_name) );
</span></span></code></pre></div><p>这不容易受到服务端模板注入的攻击，因为用户的名字只是作为数据传递到模板中的。</p><p>但是，Web 开发人员有时可能将用户输入直接连接到模板中，如：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>$output = $twig-&gt;render(&#34;Dear &#34; . $_GET[&#39;name&#39;]);
</span></span></code></pre></div><p>此时，不是将静态值传递到模板中，而是使用 GET name 动态生成模板本身的一部分。由于模板语法是在服务端执行的，这可能允许攻击者使用 name 参数如下：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>http://vulnerable-website.com/?name={{bad-stuff-here}}
</span></span></code></pre></div><p>像这样的漏洞有时是由于不熟悉安全概念的人设计了有缺陷的模板造成的。与上面的例子一样，你可能会看到不同的组件，其中一些组件包含用户输入，连接并嵌入到模板中。在某些方面，这类似于 SQL 注入漏洞，都是编写了不当的语句。</p><p>然而，有时这种行为实际上是有意为之。例如，有些网站故意允许某些特权用户（如内容编辑器）通过设计来编辑或提交自定义模板。如果攻击者能够利用特权帐户，这显然会带来巨大的安全风险。</p><h2 id=构造服务端模板注入攻击>构造服务端模板注入攻击
<a class=heading-link href=#%e6%9e%84%e9%80%a0%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%a8%a1%e6%9d%bf%e6%b3%a8%e5%85%a5%e6%94%bb%e5%87%bb><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>识别服务端模板注入漏洞并策划成功的攻击通常涉及以下抽象过程。</p><p><img src=https://raw.githubusercontent.com/RifeWang/images/master/web-security/ssti-methodology-diagram.png alt></p><h3 id=探测>探测
<a class=heading-link href=#%e6%8e%a2%e6%b5%8b><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>服务端模板注入漏洞常常不被注意到，这不是因为它们很复杂，而是因为它们只有在明确寻找它们的审计人员面前才真正明显。如果你能够检测到存在漏洞，则利用它将非常容易。在非沙盒环境中尤其如此。</p><p>与任何漏洞一样，利用漏洞的第一步就是先找到它。也许最简单的初始方法就是注入模板表达式中常用的一系列特殊字符，例如 ${{&lt;%[%&rsquo;"}}%\ ，去尝试模糊化模板。如果引发异常，则表明服务器可能以某种方式解释了注入的模板语法，从而表明服务端模板注入可能存在漏洞。</p><p>服务端模板注入漏洞发生在两个不同的上下文中，每个上下文都需要自己的检测方法。不管模糊化尝试的结果如何，也要尝试以下特定于上下文的方法。如果模糊化是不确定的，那么使用这些方法之一，漏洞可能会暴露出来。即使模糊化确实表明存在模板注入漏洞，你仍然需要确定其上下文才能利用它。</p><h4 id=plaintext-context>Plaintext context
<a class=heading-link href=#plaintext-context><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h4><p>纯文本上下文。</p><p>大多数模板语言允许你通过直接使用 HTML tags 或模板语法自由地输入内容，后端在发送 HTTP 响应之前，会把这些内容渲染为 HTML 。例如，在 Freemarker 模板中，<code>render('Hello ' + username)</code> 可能会渲染为 <code>Hello Carlos</code> 。</p><p>这有时经常被误认为是一个简单的 XSS 漏洞并用于 XSS 攻击。但是，通过将数学运算设置为参数的值，我们可以测试其是否也是服务端模板注入攻击的潜在攻击点。</p><p>例如，考虑包含以下模板代码：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>render(&#39;Hello &#39; + username)
</span></span></code></pre></div><p>在审查过程中，我们可以通过请求以下 URL 来测试服务端模板注入：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>http://vulnerable-website.com/?username=${7*7}
</span></span></code></pre></div><p>如果结果输出包含 <code>Hello 49</code> ，这表明数学运算被服务端执行了。这是服务端模板注入漏洞的一个很好的证明。</p><p>请注意，成功计算数学运算所需的特定语法将因使用的模板引擎而异。我们将在 Identify 步骤详细说明。</p><h4 id=code-context>Code context
<a class=heading-link href=#code-context><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h4><p>代码上下文。</p><p>在其他情况下，漏洞暴露是因为将用户输入放在了模板表达式中，就像上文中的电子邮件示例中看到的那样。这可以采用将用户可控制的变量名放置在参数中的形式，例如：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>greeting = getQueryParameter(&#39;greeting&#39;)
</span></span><span style=display:flex><span>engine.render(&#34;Hello {{&#34;+greeting+&#34;}}&#34;, data)
</span></span></code></pre></div><p>在网站上生成的 URL 类似于：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>http://vulnerable-website.com/?greeting=data.username
</span></span></code></pre></div><p>渲染的输出可能为 <code>Hello Carlos</code> 。</p><p>在评估过程中很容易忽略这个上下文，因为它不会产生明显的 XSS，并且与简单的 hashmap 查找几乎没有区别。在这种情况下，测试服务端模板注入的一种方法是首先通过向值中注入任意 HTML 来确定参数不包含直接的 XSS 漏洞：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>http://vulnerable-website.com/?greeting=data.username&lt;tag&gt;
</span></span></code></pre></div><p>在没有 XSS 的情况下，这通常会导致输出中出现空白（只有 Hello，没有 username ），编码标签或错误信息。下一步是尝试使用通用模板语法来跳出该语句，并尝试在其后注入任意 HTML ：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>http://vulnerable-website.com/?greeting=data.username}}&lt;tag&gt;
</span></span></code></pre></div><p>如果这再次导致错误或空白输出，则说明你使用了错误的模板语法。或者，模板样式的语法均无效，此时则无法进行服务端模板注入。如果输出与任意 HTML 一起正确呈现，则这是服务端模板注入漏洞存在的关键证明：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Hello Carlos&lt;tag&gt;
</span></span></code></pre></div><h3 id=识别>识别
<a class=heading-link href=#%e8%af%86%e5%88%ab><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>一旦检测到潜在的模板注入，下一步就是确定模板引擎。</p><p>尽管有大量的模板语言，但许多都使用非常相似的语法，这些语法是专门为避免与 HTML 字符冲突而选择的。因此，构造试探性载荷来测试正在使用哪个模板引擎可能相对简单。</p><p>简单地提交无效的语法就足够了，因为生成的错误消息会告诉你用了哪个模板引擎，有时甚至能具体到哪个版本。例如，非法的表达式 <code>&lt;%=foobar%></code> 触发了基于 Ruby 的 ERB 引擎的如下响应：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>(erb):1:in `&lt;main&gt;&#39;: undefined local variable or method `foobar&#39; for main:Object (NameError)
</span></span><span style=display:flex><span>from /usr/lib/ruby/2.5.0/erb.rb:876:in `eval&#39;
</span></span><span style=display:flex><span>from /usr/lib/ruby/2.5.0/erb.rb:876:in `result&#39;
</span></span><span style=display:flex><span>from -e:4:in `&lt;main&gt;&#39;
</span></span></code></pre></div><p>否则，你将需要手动测试不同语言特定的有效负载，并研究模板引擎如何解释它们。使用基于语法有效或无效的排除过程，你可以比你想象的更快地缩小选项范围。一种常见的方法是使用来自不同模板引擎的语法注入任意的数学运算。然后，观察它们是否被成功执行。要完成此过程，可以使用类似于以下内容的决策树：
<img src=https://raw.githubusercontent.com/RifeWang/images/master/web-security/template-decision-tree.png alt></p><p>你应该注意，同样的有效负载有时可以获得多个模板语言的成功响应。例如，有效载荷 <code>{{7*'7'}}</code> 在 <code>Twig</code> 中返回 <code>49</code> ，在 <code>Jinja2</code> 中返回 <code>7777777</code> 。因此，不要只因为成功响应了就草率下结论。</p><h3 id=利用>利用
<a class=heading-link href=#%e5%88%a9%e7%94%a8><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>在检测到存在潜在漏洞并成功识别模板引擎之后，就可以开始尝试寻找利用它的方法。详细请翻阅下文。</p><h2 id=如何防止服务端模板注入漏洞>如何防止服务端模板注入漏洞
<a class=heading-link href=#%e5%a6%82%e4%bd%95%e9%98%b2%e6%ad%a2%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%a8%a1%e6%9d%bf%e6%b3%a8%e5%85%a5%e6%bc%8f%e6%b4%9e><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>防止服务端模板注入的最佳方法是不允许任何用户修改或提交新模板。然而，由于业务需求，这有时是不可避免的。</p><p>避免引入服务端模板注入漏洞的最简单方法之一是，除非绝对必要，始终使用“无逻辑”模板引擎，如 <code>Mustache</code>。尽可能的将逻辑与表示分离，这可以大大减少高危险性的基于模板的攻击的风险。</p><p>另一措施是仅在完全删除了潜在危险模块和功能的沙盒环境中执行用户的代码。不幸的是，对不可信的代码进行沙盒处理本身就很困难，而且容易被绕过。</p><p>最后，对于接受任意代码执行无法避免的情况，另一种补充方法是，通过在锁定的例如 Docker 容器中部署模板环境，来应用你自己的沙盒。</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2019 -
2023
凌虚
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>