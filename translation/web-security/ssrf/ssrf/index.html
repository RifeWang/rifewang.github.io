<!doctype html><html lang=en><head><title>web 安全之 Server-side request forgery · 凌虚 Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="凌虚"><meta name=description content="web 安全之 Server-side request forgery"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="web 安全之 Server-side request forgery"><meta name=twitter:description content="web 安全之 Server-side request forgery"><meta property="og:title" content="web 安全之 Server-side request forgery"><meta property="og:description" content="web 安全之 Server-side request forgery"><meta property="og:type" content="article"><meta property="og:url" content="https://rifewang.github.io/translation/web-security/ssrf/ssrf/"><meta property="article:section" content="translation"><meta property="article:published_time" content="2021-03-01T01:00:00+08:00"><meta property="article:modified_time" content="2021-03-01T01:00:00+08:00"><link rel=canonical href=https://rifewang.github.io/translation/web-security/ssrf/ssrf/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.0fa2dc75ed1b76894ac0e062b10a6c4730daa745096fa120114b290ed8a48788.css integrity="sha256-D6Lcde0bdolKwOBisQpsRzDap0UJb6EgEUspDtikh4g=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.593028e7f7ac55c003b79c230d1cd411bb4ca53b31556c3abb7f027170e646e9.css integrity="sha256-WTAo5/esVcADt5wjDRzUEbtMpTsxVWw6u38CcXDmRuk=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.110.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>凌虚 Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>博客</a></li><li class=navigation-item><a class=navigation-link href=/translation/>译文</a></li><li class=navigation-item><a class=navigation-link href=/about/>关于</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://rifewang.github.io/translation/web-security/ssrf/ssrf/>web 安全之 Server-side request forgery</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2021-03-01T01:00:00+08:00>March 1, 2021</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
2-minute read</span></div><div class=categories><i class="fa fa-folder" aria-hidden=true></i>
<a href=/categories/web-security/>web security</a></div></div></header><div class=post-content><h1 id=server-side-request-forgery-ssrf>Server-side request forgery (SSRF)
<a class=heading-link href=#server-side-request-forgery-ssrf><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>在本节中，我们将解释 server-side request forgery（服务端请求伪造）是什么，并描述一些常见的示例，以及解释如何发现和利用各种 <code>SSRF</code> 漏洞。</p><h2 id=ssrf-是什么>SSRF 是什么
<a class=heading-link href=#ssrf-%e6%98%af%e4%bb%80%e4%b9%88><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p><code>SSRF</code> 服务端请求伪造是一个 web 漏洞，它允许攻击者诱导服务端程序向攻击者选择的任何地址发起 HTTP 请求。</p><p>在典型的 <code>SSRF</code> 示例中，攻击者可能会使服务端建立一个到服务端自身、或组织基础架构中的其它基于 web 的服务、或外部第三方系统的连接。</p><p><img src=https://raw.githubusercontent.com/RifeWang/images/master/web-security/ssrf.png alt=SSRF></p><h2 id=ssrf-攻击的影响>SSRF 攻击的影响
<a class=heading-link href=#ssrf-%e6%94%bb%e5%87%bb%e7%9a%84%e5%bd%b1%e5%93%8d><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>成功的 <code>SSRF</code> 攻击通常会导致未经授权的操作或对组织内部数据的访问，无论是在易受攻击的应用程序本身，还是应用程序可以通信的其它后端系统。在某些情况下，<code>SSRF</code> 漏洞可能允许攻击者执行任意的命令。</p><p>利用 <code>SSRF</code> 漏洞可能可以操作服务端应用程序使其向与之连接的外部第三方系统发起恶意请求，这将导致潜在的法律责任和声誉受损。</p><h2 id=常见的-ssrf-攻击>常见的 SSRF 攻击
<a class=heading-link href=#%e5%b8%b8%e8%a7%81%e7%9a%84-ssrf-%e6%94%bb%e5%87%bb><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p><code>SSRF</code> 攻击通常利用服务端应用程序的信任关系发起攻击并执行未经授权的操作。这种信任关系可能包括：对服务端自身的信任，或同组织内其它后端系统的信任。</p><h3 id=ssrf-攻击服务端自身>SSRF 攻击服务端自身
<a class=heading-link href=#ssrf-%e6%94%bb%e5%87%bb%e6%9c%8d%e5%8a%a1%e7%ab%af%e8%87%aa%e8%ba%ab><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>在针对服务端本身的 <code>SSRF</code> 攻击中，攻击者诱导应用程序向其自身发出 HTTP 请求，这通常需要提供一个主机名是 <code>127.0.0.1</code> 或者 <code>localhost</code> 的 URL 。</p><p>例如，假设某个购物应用程序，其允许用户查看某个商品在特定商店中是否有库存。为了提供库存信息，应用程序需要通过 REST API 查询其他后端服务，而其他后端服务的 URL 地址直接包含在前端 HTTP 请求中。因此，当用户查看商品的库存状态时，浏览器可能发出如下请求：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>POST /product/stock HTTP/1.0
</span></span><span style=display:flex><span>Content-Type: application/x-www-form-urlencoded
</span></span><span style=display:flex><span>Content-Length: 118
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>stockApi=http://stock.weliketoshop.net:8080/product/stock/check%3FproductId%3D6%26storeId%3D1
</span></span></code></pre></div><p>这将导致服务端向指定的 URL 发出请求，检索库存状态，然后将结果返回给用户。</p><p>在这种情况下，攻击者可以修改请求以指定服务器本地的 URL ，例如：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>POST /product/stock HTTP/1.0
</span></span><span style=display:flex><span>Content-Type: application/x-www-form-urlencoded
</span></span><span style=display:flex><span>Content-Length: 118
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>stockApi=http://localhost/admin
</span></span></code></pre></div><p>此时，服务端将会访问本地 /admin URL 并将其内容返回给用户。</p><p>当然，攻击者可以直接访问 /admin URL ，但是这通常没用，因为管理功能基本都需要进行适当的身份验证，而如果对 /admin URL 的请求来自机器本地，则正常情况下的访问控制可能会被绕过。该服务端应用程序可能会授予对管理功能的完全访问权限，因为请求似乎来自受信任的位置。</p><p>为什么应用程序会以这种方式运行，并且隐式信任来自本地的请求？这可能有多种原因：</p><ul><li>访问控制检查可能是另外的一个微服务。当服务器连接自身时，将会绕过访问控制检查。</li><li>出于灾难恢复的目的，应用程序可能允许来自本地机器的任何用户在不登录的情况下进行管理访问。这为管理员在丢失凭证时恢复系统提供了一种方法。这里的假设是只有完全可信的用户才能直接来自服务器本地。</li><li>管理接口可能与主应用是不同的端口号，因为用户可能无法直接访问。</li></ul><p>在这种信任关系中，来自本地机器的请求的处理方式与普通请求不同，这常常使 <code>SSRF</code> 成为一个严重的漏洞。</p><h3 id=针对其他后端系统的-ssrf-攻击>针对其他后端系统的 SSRF 攻击
<a class=heading-link href=#%e9%92%88%e5%af%b9%e5%85%b6%e4%bb%96%e5%90%8e%e7%ab%af%e7%b3%bb%e7%bb%9f%e7%9a%84-ssrf-%e6%94%bb%e5%87%bb><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p><code>SSRF</code> 利用的另外一种信任关系是应用服务端与用户无法直接访问的内部后端系统之间进行的交互，这些后端系统通常具有不可路由的专用 IP 地址，由于受到网络拓扑结构的保护，它们的安全性往往较弱。在许多情况下，内部后端系统包含一些敏感功能，任何能够与系统交互的人都可以在不进行身份验证的情况下访问这些功能。</p><p>在前面的示例中，假设后端系统有一个管理接口 <code>https://192.168.0.68/admin</code> 。此时，攻击者可以通过提交以下请求利用 SSRF 漏洞访问管理接口：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>POST /product/stock HTTP/1.0
</span></span><span style=display:flex><span>Content-Type: application/x-www-form-urlencoded
</span></span><span style=display:flex><span>Content-Length: 118
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>stockApi=http://192.168.0.68/admin
</span></span></code></pre></div><h2 id=规避常见的-ssrf-防御>规避常见的 SSRF 防御
<a class=heading-link href=#%e8%a7%84%e9%81%bf%e5%b8%b8%e8%a7%81%e7%9a%84-ssrf-%e9%98%b2%e5%be%a1><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>通常应用程序包含 SSRF 行为以及防止恶意攻击的防御措施，然而这些防御措施是可以被规避的。</p><h3 id=基于黑名单过滤的-ssrf>基于黑名单过滤的 SSRF
<a class=heading-link href=#%e5%9f%ba%e4%ba%8e%e9%bb%91%e5%90%8d%e5%8d%95%e8%bf%87%e6%bb%a4%e7%9a%84-ssrf><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>某些应用程序禁止例如 <code>127.0.0.1</code>、<code>localhost</code> 等主机名、或 <code>/admin</code> 等敏感 URL 。这种情况下，可以使用各种技巧绕过过滤：</p><ul><li>使用 <code>127.0.0.1</code> 的替代 IP 地址表示，例如 <code>2130706433</code>，<code>017700000001</code>，<code>127.1</code> 。</li><li>注册自己的域名，并解析为 <code>127.0.0.1</code> ，你可以直接使用 <code>spoofed.burpcollaborator.net</code> 。</li><li>使用 URL 编码或大小写变化来混淆被阻止的字符串。</li></ul><h3 id=基于白名单过滤的-ssrf>基于白名单过滤的 SSRF
<a class=heading-link href=#%e5%9f%ba%e4%ba%8e%e7%99%bd%e5%90%8d%e5%8d%95%e8%bf%87%e6%bb%a4%e7%9a%84-ssrf><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>有些应用程序只允许输入匹配、或包含白名单中的值，或以白名单中的值开头。在这种情况下，有时可以利用 URL 解析的不一致来绕过过滤器。</p><p>URL 规范包含有许多在实现 URL 的解析和验证时容易被忽略的特性：</p><ul><li>你可以在主机名之前使用 <code>@</code> 符号嵌入凭证。例如 <code>https://expected-host@evil-host</code> 。</li><li>你可以使用 <code>#</code> 符号表示一个 URL 片段。例如 <code>https://evil-host#expected-host</code> 。</li><li>你可以利用 DNS 命令层次结构将所需的输入放入你控制的标准 DNS 名称中。例如 <code>https://expected-host.evil-host</code> 。</li><li>你可以使用 URL 编码字符来迷惑 URL 解析代码。如果处理 URL 编码的过滤器的实现不同与执行后端 HTTP 请求的代码，这一点尤其有用。</li><li>你可以把这些技巧结合起来使用。</li></ul><h3 id=通过开放重定向绕过-ssrf-过滤器>通过开放重定向绕过 SSRF 过滤器
<a class=heading-link href=#%e9%80%9a%e8%bf%87%e5%bc%80%e6%94%be%e9%87%8d%e5%ae%9a%e5%90%91%e7%bb%95%e8%bf%87-ssrf-%e8%bf%87%e6%bb%a4%e5%99%a8><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>有时利用开放重定向漏洞可以绕过任何基于过滤器的防御。</p><p>在前面的示例中，假设用户提交的 URL 经过严格验证，以防止恶意利用 SSRF 的行为，但是，允许使用 URL 的应用程序包含一个开放重定向漏洞。如果用于发起后端 HTTP 请求的 API 支持重定向，那么你可以构造一个满足过滤器的要求的 URL ，并将请求重定向到所需的后端目标。</p><p>例如，假设应用程序包含一个开放重定向漏洞，例如下面 URL 的形式：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>/product/nextProduct?currentProductId=6&amp;path=http://evil-user.net
</span></span></code></pre></div><p>重定向到：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>http://evil-user.net
</span></span></code></pre></div><p>你可以利用开放重定向漏洞绕过 URL 过滤器，并利用 SSRF 漏洞进行攻击，如：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>POST /product/stock HTTP/1.0
</span></span><span style=display:flex><span>Content-Type: application/x-www-form-urlencoded
</span></span><span style=display:flex><span>Content-Length: 118
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>stockApi=http://weliketoshop.net/product/nextProduct?currentProductId=6&amp;path=http://192.168.0.68/admin
</span></span></code></pre></div><p>这个 SSRF 攻击之所有有效，是因为首先 stockAPI URL 在应用程序允许的域上，然后应用程序向提供的 URL 发起请求，触发了重定向，最终向重定向的内部 URL 发起了请求。</p><h2 id=blind-ssrf---不可见-ssrf-漏洞>Blind SSRF - 不可见 SSRF 漏洞
<a class=heading-link href=#blind-ssrf---%e4%b8%8d%e5%8f%af%e8%a7%81-ssrf-%e6%bc%8f%e6%b4%9e><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>所谓 Blind SSRF（不可见 SSRF）漏洞是指，可以诱导应用程序向提供的 URL 发起后端 HTTP 请求，但是请求的响应并没有在应用程序的前端响应中返回。</p><p>不可见 SSRF 漏洞通常较难利用，但有时会导致服务器或其他后端组件上的远程代码执行。</p><h2 id=寻找-ssrf-漏洞的隐藏攻击面>寻找 SSRF 漏洞的隐藏攻击面
<a class=heading-link href=#%e5%af%bb%e6%89%be-ssrf-%e6%bc%8f%e6%b4%9e%e7%9a%84%e9%9a%90%e8%97%8f%e6%94%bb%e5%87%bb%e9%9d%a2><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>许多 SSRF 漏洞之所以相对容易发现，是因为应用程序的正常通信中就包含了完整的 URL 请求参数。而其它情况就比较难搞了。</p><h3 id=请求中的部分-url>请求中的部分 URL
<a class=heading-link href=#%e8%af%b7%e6%b1%82%e4%b8%ad%e7%9a%84%e9%83%a8%e5%88%86-url><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>有时应用程序只将主机名或 URL 路径的一部分放入请求参数中，然后，提交的值被合并到服务端请求的完整 URL 中。如果该值很容易被识别为主机名或 URL 路径，那么潜在的攻击面可能很明显。但是，因为你不能控制最终请求的 URL，所以 SSRF 的可利用性会受到限制。</p><h3 id=数据格式内的-url>数据格式内的 URL
<a class=heading-link href=#%e6%95%b0%e6%8d%ae%e6%a0%bc%e5%bc%8f%e5%86%85%e7%9a%84-url><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>有些应用程序以某种数据格式传输数据，URL 则包含在指定数据格式中。这里的数据格式的一个明显的例子就是 XML ，当应用程序接受 XML 格式的数据并对其进行解析时，可能会受到 <code>XXE</code> 注入，进而通过 <code>XXE</code> 完成 <code>SSRF</code> 攻击。有关 <code>XXE</code> 注入漏洞会有专门的章节讲解。</p><h3 id=通过-referer-头的-ssrf>通过 Referer 头的 SSRF
<a class=heading-link href=#%e9%80%9a%e8%bf%87-referer-%e5%a4%b4%e7%9a%84-ssrf><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>一些应用程序使用服务端分析软件来跟踪访问者，这种软件经常在请求中记录 <code>Referer</code> 头，因为这对于跟踪传入链接特别有用。通常，分析软件实际上会访问 <code>Referer</code> 头中出现的任何第三方 URL 。这通常用于分析引用站点的内容，包括传入链接中使用的锚文本。因此，<code>Referer</code> 头通常是 <code>SSRF</code> 漏洞的有效攻击面。有关涉及 <code>Referer</code> 头的漏洞示例请参阅 <code>Blind SSRF</code> 。</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2019 -
2023
凌虚
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>