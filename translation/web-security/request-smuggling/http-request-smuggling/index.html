<!doctype html><html lang=en><head><title>web 安全之 HTTP request smuggling · 凌虚 Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="凌虚"><meta name=description content="web 安全之 HTTP request smuggling"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="web 安全之 HTTP request smuggling"><meta name=twitter:description content="web 安全之 HTTP request smuggling"><meta property="og:title" content="web 安全之 HTTP request smuggling"><meta property="og:description" content="web 安全之 HTTP request smuggling"><meta property="og:type" content="article"><meta property="og:url" content="https://rifewang.github.io/translation/web-security/request-smuggling/http-request-smuggling/"><meta property="article:section" content="translation"><meta property="article:published_time" content="2021-03-04T01:00:00+08:00"><meta property="article:modified_time" content="2021-03-04T01:00:00+08:00"><link rel=canonical href=https://rifewang.github.io/translation/web-security/request-smuggling/http-request-smuggling/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.0fa2dc75ed1b76894ac0e062b10a6c4730daa745096fa120114b290ed8a48788.css integrity="sha256-D6Lcde0bdolKwOBisQpsRzDap0UJb6EgEUspDtikh4g=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.593028e7f7ac55c003b79c230d1cd411bb4ca53b31556c3abb7f027170e646e9.css integrity="sha256-WTAo5/esVcADt5wjDRzUEbtMpTsxVWw6u38CcXDmRuk=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.110.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>凌虚 Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>博客</a></li><li class=navigation-item><a class=navigation-link href=/translation/>译文</a></li><li class=navigation-item><a class=navigation-link href=/about/>关于</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://rifewang.github.io/translation/web-security/request-smuggling/http-request-smuggling/>web 安全之 HTTP request smuggling</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2021-03-04T01:00:00+08:00>March 4, 2021</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
2-minute read</span></div><div class=categories><i class="fa fa-folder" aria-hidden=true></i>
<a href=/categories/web-security/>web security</a></div></div></header><div class=post-content><h1 id=http-request-smuggling>HTTP request smuggling
<a class=heading-link href=#http-request-smuggling><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>在本节中，我们将解释什么是 HTTP 请求走私，并描述常见的请求走私漏洞是如何产生的。</p><h2 id=什么是-http-请求走私>什么是 HTTP 请求走私
<a class=heading-link href=#%e4%bb%80%e4%b9%88%e6%98%af-http-%e8%af%b7%e6%b1%82%e8%b5%b0%e7%a7%81><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>HTTP 请求走私是一种干扰网站处理多个 HTTP 请求序列的技术。请求走私漏洞危害很大，它使攻击者可以绕过安全控制，未经授权访问敏感数据并直接危害其他应用程序用户。</p><p><img src=https://raw.githubusercontent.com/RifeWang/images/master/web-security/req-smuggling.png alt="request smuggling"></p><h2 id=http-请求走私到底发生了什么>HTTP 请求走私到底发生了什么
<a class=heading-link href=#http-%e8%af%b7%e6%b1%82%e8%b5%b0%e7%a7%81%e5%88%b0%e5%ba%95%e5%8f%91%e7%94%9f%e4%ba%86%e4%bb%80%e4%b9%88><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>现在的应用架构中经常会使用诸如负载均衡、反向代理、网关等服务，这些服务在链路上起到了一个转发请求给后端服务器的作用，因为位置位于后端服务器的前面，所以本文把他们称为前端服务器。</p><p>当前端服务器（转发服务）将 HTTP 请求转发给后端服务器时，它通常会通过与后端服务器之间的同一个网络连接发送多个请求，因为这样做更加高效。协议非常简单：HTTP 请求被一个接一个地发送，接受请求的服务器则解析 HTTP 请求头以确定一个请求的结束位置和下一个请求的开始位置，如下图所示：
<img src=https://raw.githubusercontent.com/RifeWang/images/master/web-security/request-smuggling-flow1.png alt="http flow"></p><p>在这种情况下，前端服务器（转发服务）与后端系统必须就请求的边界达成一致。否则，攻击者可能会发送一个模棱两可的请求，该请求被前端服务器（转发服务）与后端系统以不同的方式解析：</p><p><img src=https://raw.githubusercontent.com/RifeWang/images/master/web-security/request-smuggling-flow2.png alt="http flow with smuggling"></p><p>如上图所示，攻击者使上一个请求的一部分被后端服务器解析为下一个请求的开始，这时就会干扰应用程序处理该请求的方式。这就是请求走私攻击，其可能会造成毁灭性的后果。</p><h2 id=http-请求走私漏洞是怎么产生的>HTTP 请求走私漏洞是怎么产生的
<a class=heading-link href=#http-%e8%af%b7%e6%b1%82%e8%b5%b0%e7%a7%81%e6%bc%8f%e6%b4%9e%e6%98%af%e6%80%8e%e4%b9%88%e4%ba%a7%e7%94%9f%e7%9a%84><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>绝大多数 HTTP 请求走私漏洞的出现是因为 HTTP 规范提供了两种不同的方法来指定请求的结束位置：<code>Content-Length</code> 头和 <code>Transfer-Encoding</code> 头。</p><p><code>Content-Length</code> 头很简单，直接以字节为单位指定消息体的长度。例如：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>POST /search HTTP/1.1
</span></span><span style=display:flex><span>Host: normal-website.com
</span></span><span style=display:flex><span>Content-Type: application/x-www-form-urlencoded
</span></span><span style=display:flex><span>Content-Length: 11
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>q=smuggling
</span></span></code></pre></div><p><code>Transfer-Encoding</code> 头则可以声明消息体使用了 <code>chunked</code> 编码，就是消息体被拆分成了一个或多个分块传输，每个分块的开头是当前分块大小（以十六进制表示），后面紧跟着 <code>\r\n</code>，然后是分块内容，后面也是 <code>\r\n</code>。消息的终止分块也是同样的格式，只是其长度为零。例如：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>POST /search HTTP/1.1
</span></span><span style=display:flex><span>Host: normal-website.com
</span></span><span style=display:flex><span>Content-Type: application/x-www-form-urlencoded
</span></span><span style=display:flex><span>Transfer-Encoding: chunked
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>b
</span></span><span style=display:flex><span>q=smuggling
</span></span><span style=display:flex><span>0
</span></span></code></pre></div><p>由于 HTTP 规范提供了两种不同的方法来指定 HTTP 消息的长度，因此单个消息中完全可以同时使用这两种方法，从而使它们相互冲突。HTTP 规范为了避免这种歧义，其声明如果 <code>Content-Length</code> 和 <code>Transfer-Encoding</code> 同时存在，则 <code>Content-Length</code> 应该被忽略。当只有一个服务运行时，这种歧义似乎可以避免，但是当多个服务被连接在一起时，这种歧义就无法避免了。在这种情况下，出现问题有两个原因：</p><ul><li>某些服务器不支持请求中的 <code>Transfer-Encoding</code> 头。</li><li>某些服务器虽然支持 <code>Transfer-Encoding</code> 头，但是可以通过某种方式进行混淆，以诱导不处理此标头。</li></ul><p>如果前端服务器（转发服务）和后端服务器处理 <code>Transfer-Encoding</code> 的行为不同，则它们可能在连续请求之间的边界上存在分歧，从而导致请求走私漏洞。</p><h2 id=如何进行-http-请求走私攻击>如何进行 HTTP 请求走私攻击
<a class=heading-link href=#%e5%a6%82%e4%bd%95%e8%bf%9b%e8%a1%8c-http-%e8%af%b7%e6%b1%82%e8%b5%b0%e7%a7%81%e6%94%bb%e5%87%bb><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>请求走私攻击需要在 HTTP 请求头中同时使用 <code>Content-Length</code> 和 <code>Transfer-Encoding</code>，以使前端服务器（转发服务）和后端服务器以不同的方式处理该请求。具体的执行方式取决于两台服务器的行为：</p><ul><li><code>CL.TE</code>：前端服务器（转发服务）使用 <code>Content-Length</code> 头，而后端服务器使用 <code>Transfer-Encoding</code> 头。</li><li><code>TE.CL</code>：前端服务器（转发服务）使用 <code>Transfer-Encoding</code> 头，而后端服务器使用 <code>Content-Length</code> 头。</li><li><code>TE.TE</code>：前端服务器（转发服务）和后端服务器都使用 <code>Transfer-Encoding</code> 头，但是可以通过某种方式混淆标头来诱导其中一个服务器不对其进行处理。</li></ul><h3 id=clte-漏洞>CL.TE 漏洞
<a class=heading-link href=#clte-%e6%bc%8f%e6%b4%9e><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>前端服务器（转发服务）使用 <code>Content-Length</code> 头，而后端服务器使用 <code>Transfer-Encoding</code> 头。我们可以构造一个简单的 HTTP 请求走私攻击，如下所示：</p><p>前端服务器（转发服务）使用 <code>Content-Length</code> 确定这个请求体的长度是 13 个字节，直到 <code>SMUGGLED</code> 的结尾。然后请求被转发给了后端服务器。</p><p>后端服务器使用 <code>Transfer-Encoding</code> ，把请求体当成是分块的，然后处理第一个分块，刚好又是长度为零的终止分块，因此直接认为消息结束了，而后面的 <code>SMUGGLED</code> 将不予处理，并将其视为下一个请求的开始。</p><h3 id=tecl-漏洞>TE.CL 漏洞
<a class=heading-link href=#tecl-%e6%bc%8f%e6%b4%9e><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>前端服务器（转发服务）使用 <code>Transfer-Encoding</code> 头，而后端服务器使用 <code>Content-Length</code> 头。我们可以构造一个简单的 HTTP 请求走私攻击，如下所示：</p><p>注意：上面的 0 后面还有 <code>\r\n\r\n</code> 。</p><p>前端服务器（转发服务）使用 <code>Transfer-Encoding</code> 将消息体当作分块编码，第一个分块的长度是 8 个字节，内容是 <code>SMUGGLED</code>，第二个分块的长度是 0 ，也就是终止分块，所以这个请求到这里终止，然后被转发给了后端服务。</p><p>后端服务使用 <code>Content-Length</code> ，认为消息体只有 3 个字节，也就是 <code>8\r\n</code>，而剩下的部分将不会处理，并视为下一个请求的开始。</p><h2 id=tete--混淆-te-头>TE.TE 混淆 TE 头
<a class=heading-link href=#tete--%e6%b7%b7%e6%b7%86-te-%e5%a4%b4><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>前端服务器（转发服务）和后端服务器都使用 <code>Transfer-Encoding</code> 头，但是可以通过某种方式混淆标头来诱导其中一个服务器不对其进行处理。</p><p>混淆 <code>Transfer-Encoding</code> 头的方式可能无穷无尽。例如：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Transfer-Encoding: xchunked
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Transfer-Encoding : chunked
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Transfer-Encoding: chunked
</span></span><span style=display:flex><span>Transfer-Encoding: x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Transfer-Encoding:[tab]chunked
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[space]Transfer-Encoding: chunked
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>X: X[\n]Transfer-Encoding: chunked
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Transfer-Encoding
</span></span><span style=display:flex><span>: chunked
</span></span></code></pre></div><p>这些技术中的每一种都与 HTTP 规范有细微的不同。实现协议规范的实际代码很少以绝对的精度遵守协议规范，并且不同的实现通常会容忍与协议规范的不同变化。要找到 <code>TE.TE</code> 漏洞，必须找到 <code>Transfer-Encoding</code> 标头的某种变体，以便前端服务器（转发服务）或后端服务器其中之一正常处理，而另外一个服务器则将其忽略。</p><p>根据可以混淆诱导不处理 <code>Transfer-Encoding</code> 的是前端服务器（转发服务）还是后端服务，而后的攻击方式则与 <code>CL.TE</code> 或 <code>TE.CL</code> 漏洞相同。</p><h2 id=如何防御-http-请求走私漏洞>如何防御 HTTP 请求走私漏洞
<a class=heading-link href=#%e5%a6%82%e4%bd%95%e9%98%b2%e5%be%a1-http-%e8%af%b7%e6%b1%82%e8%b5%b0%e7%a7%81%e6%bc%8f%e6%b4%9e><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>当前端服务器（转发服务）通过同一个网络连接将多个请求转发给后端服务器，且前端服务器（转发服务）与后端服务器对请求边界存在不一致的判定时，就会出现 HTTP 请求走私漏洞。防御 HTTP 请求走私漏洞的一些通用方法如下：</p><ul><li>禁用到后端服务器连接的重用，以便每个请求都通过单独的网络连接发送。</li><li>对后端服务器连接使用 HTTP/2 ，因为此协议可防止对请求之间的边界产生歧义。</li><li>前端服务器（转发服务）和后端服务器使用完全相同的 Web 软件，以便它们就请求之间的界限达成一致。</li></ul><p>在某些情况下，可以通过使前端服务器（转发服务）规范歧义请求或使后端服务器拒绝歧义请求并关闭网络连接来避免漏洞。然而这种方法比上面的通用方法更容易出错。</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2019 -
2023
凌虚
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>