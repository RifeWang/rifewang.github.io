<!doctype html><html lang=en><head><title>CORS 和 Access-Control-Allow-Origin 响应头 · 凌虚 Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="凌虚"><meta name=description content="CORS 和 Access-Control-Allow-Origin 响应头"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="CORS 和 Access-Control-Allow-Origin 响应头"><meta name=twitter:description content="CORS 和 Access-Control-Allow-Origin 响应头"><meta property="og:title" content="CORS 和 Access-Control-Allow-Origin 响应头"><meta property="og:description" content="CORS 和 Access-Control-Allow-Origin 响应头"><meta property="og:type" content="article"><meta property="og:url" content="https://rifewang.github.io/translation/web-security/cors/access-control-allow-origin/"><meta property="article:section" content="translation"><meta property="article:published_time" content="2021-02-28T00:00:00+08:00"><meta property="article:modified_time" content="2021-02-28T00:00:00+08:00"><link rel=canonical href=https://rifewang.github.io/translation/web-security/cors/access-control-allow-origin/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.0fa2dc75ed1b76894ac0e062b10a6c4730daa745096fa120114b290ed8a48788.css integrity="sha256-D6Lcde0bdolKwOBisQpsRzDap0UJb6EgEUspDtikh4g=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.593028e7f7ac55c003b79c230d1cd411bb4ca53b31556c3abb7f027170e646e9.css integrity="sha256-WTAo5/esVcADt5wjDRzUEbtMpTsxVWw6u38CcXDmRuk=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.110.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>凌虚 Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>博客</a></li><li class=navigation-item><a class=navigation-link href=/translation/>译文</a></li><li class=navigation-item><a class=navigation-link href=/about/>关于</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://rifewang.github.io/translation/web-security/cors/access-control-allow-origin/>CORS 和 Access-Control-Allow-Origin 响应头</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2021-02-28T00:00:00+08:00>February 28, 2021</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
2-minute read</span></div><div class=categories><i class="fa fa-folder" aria-hidden=true></i>
<a href=/categories/web-security/>web security</a></div></div></header><div class=post-content><h1 id=cors-和-access-control-allow-origin-响应头>CORS 和 Access-Control-Allow-Origin 响应头
<a class=heading-link href=#cors-%e5%92%8c-access-control-allow-origin-%e5%93%8d%e5%ba%94%e5%a4%b4><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>在本节中，我们将解释有关 <code>CORS</code> 的 <code>Access-Control-Allow-Origin</code> 响应头，以及后者如何构成 <code>CORS</code> 实现的一部分。</p><p><code>CORS</code> 通过使用一组 HTTP 头部提供了同源策略的可控制放宽，浏览器允许访问基于这些头部的跨域请求的响应。</p><h2 id=什么是-access-control-allow-origin-响应头>什么是 Access-Control-Allow-Origin 响应头？
<a class=heading-link href=#%e4%bb%80%e4%b9%88%e6%98%af-access-control-allow-origin-%e5%93%8d%e5%ba%94%e5%a4%b4><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p><code>Access-Control-Allow-Origin</code> 响应头标识了跨域请求允许的请求来源，浏览器会将 <code>Access-Control-Allow-Origin</code> 与请求网站 origin 进行比较，如果两者匹配则允许访问响应。</p><h2 id=实现简单的-cors>实现简单的 CORS
<a class=heading-link href=#%e5%ae%9e%e7%8e%b0%e7%ae%80%e5%8d%95%e7%9a%84-cors><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p><code>CORS</code> 规范规定了 web 服务器和浏览器之间交换的头内容，其中 <code>Access-Control-Allow-Origin</code> 是最重要的。当网站发起跨域资源请求时，浏览器将会自动添加 <code>Origin</code> 头，随后服务器返回 <code>Access-Control-Allow-Origin</code> 响应头。</p><p>例如，origin 为 <code>normal-website.com</code> 的网站发起了如下跨域请求：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>GET /data HTTP/1.1
</span></span><span style=display:flex><span>Host: robust-website.com
</span></span><span style=display:flex><span>Origin : https://normal-website.com
</span></span></code></pre></div><p>服务器响应：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>HTTP/1.1 200 OK
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>Access-Control-Allow-Origin: https://normal-website.com
</span></span></code></pre></div><p>浏览器将会允许 <code>normal-website.com</code> 网站代码访问响应，因为 <code>Access-Control-Allow-Origin</code> 与 <code>Origin</code> 匹配。</p><p><code>Access-Control-Allow-Origin</code> 允许多个域，或者 <code>null</code> ，或者通配符 <code>*</code> 。但是没有浏览器支持多个 origin ，且通配符的使用有限制。</p><h2 id=带凭证的跨域资源请求>带凭证的跨域资源请求
<a class=heading-link href=#%e5%b8%a6%e5%87%ad%e8%af%81%e7%9a%84%e8%b7%a8%e5%9f%9f%e8%b5%84%e6%ba%90%e8%af%b7%e6%b1%82><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>跨域资源请求的默认行为是传递请求时不会携带如 cookies 和 Authorization 头等凭证的。然而，对于带凭证的跨域请求，服务器通过设置 <code>Access-Control-Allow-Credentials: true</code> 响应头可以允许浏览器读取响应。例如，某个网站使用 JavaScript 去控制发起请求时一起发送 cookies ：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>GET /data HTTP/1.1
</span></span><span style=display:flex><span>Host: robust-website.com
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>Origin: https://normal-website.com
</span></span><span style=display:flex><span>Cookie: JSESSIONID=&lt;value&gt;
</span></span></code></pre></div><p>得到的响应为：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>HTTP/1.1 200 OK
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>Access-Control-Allow-Origin: https://normal-website.com
</span></span><span style=display:flex><span>Access-Control-Allow-Credentials: true
</span></span></code></pre></div><p>那么浏览器将会允许发起请求的网站读取响应，因为 <code>Access-Control-Allow-Credentials</code> 设置为了 <code>true</code>。否则，浏览器将不允许访问响应。</p><h2 id=使用通配符放宽-cors>使用通配符放宽 CORS
<a class=heading-link href=#%e4%bd%bf%e7%94%a8%e9%80%9a%e9%85%8d%e7%ac%a6%e6%94%be%e5%ae%bd-cors><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p><code>Access-Control-Allow-Origin</code> 头支持使用通配符 <code>*</code> ，如</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Access-Control-Allow-Origin: *
</span></span></code></pre></div><p>注意：通配符不能与其他值一起使用，如下方式是非法的：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Access-Control-Allow-Origin: https://*.normal-website.com
</span></span></code></pre></div><p>幸运的是，基于安全考虑，通配符的使用是有限制的，你不能同时使用通配符与带凭证的跨域传输。因此，以下形式的服务器响应是不允许的：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Access-Control-Allow-Origin: *
</span></span><span style=display:flex><span>Access-Control-Allow-Credentials: true
</span></span></code></pre></div><p>因为这是非常危险的，这等于向所有人公开目标网站上所有经过身份验证的内容。</p><h2 id=预检>预检
<a class=heading-link href=#%e9%a2%84%e6%a3%80><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>为了保护遗留资源不受 CORS 允许的扩展请求的影响，预检也是 CORS 规范中的一部分。在某些情况下，当跨域请求包括非标准的 HTTP method 或 header 时，在进行跨域请求之前，浏览器会先发起一次 method 为 <code>OPTIONS</code> 的请求，并且对服务端响应的 <code>Access-Control-*</code> 之类的头进行初步检查，对比 origin、method 和 header 等等，这就叫预检。</p><p>例如，对使用 <code>PUT</code> 方法和 <code>Special-Request-Header</code> 自定义请求头的预检请求为：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>OPTIONS /data HTTP/1.1
</span></span><span style=display:flex><span>Host: &lt;some website&gt;
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>Origin: https://normal-website.com
</span></span><span style=display:flex><span>Access-Control-Request-Method: PUT
</span></span><span style=display:flex><span>Access-Control-Request-Headers: Special-Request-Header
</span></span></code></pre></div><p>服务器可能响应：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>HTTP/1.1 204 No Content
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>Access-Control-Allow-Origin: https://normal-website.com
</span></span><span style=display:flex><span>Access-Control-Allow-Methods: PUT, POST, OPTIONS
</span></span><span style=display:flex><span>Access-Control-Allow-Headers: Special-Request-Header
</span></span><span style=display:flex><span>Access-Control-Allow-Credentials: true
</span></span><span style=display:flex><span>Access-Control-Max-Age: 240
</span></span></code></pre></div><p>这个响应的含义:</p><ul><li><code>Access-Control-Allow-Origin</code> 允许的请求域。</li><li><code>Access-Control-Allow-Methods</code> 允许的请求方法。</li><li><code>Access-Control-Allow-Headers</code> 允许的请求头。</li><li><code>Access-Control-Allow-Credentials</code> 允许带凭证的请求。</li><li><code>Access-Control-Max-Age</code> 设置预检响应的最大缓存时间，通过缓存减少预检请求增加的额外的 HTTP 请求往返的开销。</li></ul><h2 id=cors-能防止-csrf-吗>CORS 能防止 CSRF 吗？
<a class=heading-link href=#cors-%e8%83%bd%e9%98%b2%e6%ad%a2-csrf-%e5%90%97><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>CORS 无法提供对跨站请求伪造（CSRF）攻击的防护，这是一个容易出现误解的地方。</p><p>CORS 是对同源策略的受控放宽，因此配置不当的 CORS 实际上可能会增加 CSRF 攻击的可能性或加剧其影响。</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2019 -
2023
凌虚
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>